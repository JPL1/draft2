(this.webpackJsonpprimer=this.webpackJsonpprimer||[]).push([[0],{10:function(e,t,a){},11:function(e,t,a){"use strict";a.r(t);a(1);var n=a(3),i=a.n(n),o=(a(8),a(0)),r=function(){return Object(o.jsxs)("div",{className:"intro",children:[Object(o.jsx)("h2",{id:"ch0",children:"A brief introduction"}),Object(o.jsx)("p",{children:"Technological progress is a perpetual process of automation and abstraction. Difficult and complex tasks are made simple by software and machines until they are completely taken for granted. Technology moves on, taking down new blockers in the path to progress as it goes. A good example of this is cloud computing, where once complex server administration tasks have been replaced, from the point of view of the consumer, by point-and-click."}),Object(o.jsx)("p",{children:"The Safe (Secure Access For Everyone) Network takes this further, automating the entire network of interconnected machines, making it autonomous, secure, anonymous and capable of\xa0 storing, protecting and delivering data without any human involvement at all."}),Object(o.jsx)("p",{children:"The Safe Network is the vision of MaidSafe, a Scottish software company working in the field of decentralized computer networking. It is an autonomous peer-to-peer network created by linking together users' computers and smartphones that's designed to solve many of the current technical, managerial and societal problems with centralized networks: a lack of privacy and data security, censorship and the massive consolidation of control by a few powerful actors.\xa0"}),Object(o.jsxs)("p",{children:["(In case this sounds familiar, members of MaidSafe acted as advisers for HBO\u2019s ",Object(o.jsx)("i",{children:"Silicon Valley"})," TV series in which a startup tries to reinvent the Internet!)"]}),Object(o.jsx)("p",{children:"The Network is \u2018trustless\u2019, with no central point of control and no single point of failure. With connectivity and security taken care of, the Network is simple from the point of view of developers, with no need to worry about low-level storage, networking, backups and computing resources. For people using the Network to store and share data and messages the burden of ensuring the security of precious information would be drastically reduced."}),Object(o.jsx)("p",{children:"Anyone with a connected device can join the network anonymously (subject to a resource test) as a provider, and anyone can use the network to store data or peruse public information on it. The Network is thus a platform on which new digital worlds can be constructed."}),Object(o.jsx)("p",{children:"This guide outlines how the Safe Network is constructed to achieve these aims. While it is somewhat technical in places, it's intended very much as an overview, and even those with very little technical knowledge should be able to gain a good working understanding of the Safe Network. For those requiring more depth, there are plenty of pointers as to where they can find the relevant information."}),Object(o.jsx)("div",{bgcol:"#1f3a60",height:"10px"}),Object(o.jsx)("h2",{children:"Contents"}),Object(o.jsxs)("p",{children:[Object(o.jsx)("br",{}),Object(o.jsx)("a",{href:"#ch1",children:"1. Background and fundamentals"}),Object(o.jsx)("br",{}),Object(o.jsx)("a",{href:"#ch2",children:"2. A fully autonomous data network"}),Object(o.jsx)("br",{}),Object(o.jsx)("a",{href:"#ch3",children:"3. Nodes and Clients"}),Object(o.jsx)("br",{}),Object(o.jsx)("a",{href:"#ch4",children:"4. The architecture of the Safe Network"}),Object(o.jsx)("br",{}),Object(o.jsx)("a",{href:"#ch5",children:"5. Node Age"}),Object(o.jsx)("br",{}),Object(o.jsx)("a",{href:"#ch6",children:"6. Encryption"}),Object(o.jsx)("br",{}),Object(o.jsx)("a",{href:"#ch7",children:"7. Network-wide consensus not required "}),Object(o.jsx)("br",{}),Object(o.jsx)("a",{href:"#ch8",children:"8. Farming for Safe Network Token"}),Object(o.jsx)("br",{}),Object(o.jsx)("a",{href:"#ch9",children:"9. Node personas"}),Object(o.jsx)("br",{}),Object(o.jsx)("a",{href:"#ch10",children:"10. Data types"}),Object(o.jsx)("br",{}),Object(o.jsx)("a",{href:"#ch11",children:"11. The Safe API"}),Object(o.jsx)("br",{}),Object(o.jsx)("a",{href:"#ch12",children:"12. How Safe Network defends against common types of cyberattack"}),Object(o.jsx)("br",{}),Object(o.jsx)("a",{href:"#ch13",children:"13. The promise of the Safe Network"})]})]})},s=function(){return Object(o.jsxs)("div",{className:"chapter",children:[Object(o.jsx)("h2",{id:"ch1",children:"1.\xa0\xa0 Background and fundamentals"}),Object(o.jsxs)("h3",{children:[Object(o.jsx)("br",{})," Background"]}),Object(o.jsxs)("p",{children:[Object(o.jsx)("br",{})," Decentralized or peer-to-peer (P2P) networks are not new. Since the release of Napster on June 1, 1999, they have taken the world by storm, particularly for file sharing. These networks allow users from all over the world to connect to each other and share data such as movies, books and music. In 2010 more than half of all Internet traffic was attributed to P2P.",Object(o.jsx)("br",{})," ",Object(o.jsx)("br",{})," But the use of these technologies is not limited to simple file sharing. Freenet was launched in March, 2000 allowing people to publish decentralized websites (Freesites). Freesites are not stored on central servers but instead are distributed across the machines of the encrypted network's users.",Object(o.jsx)("br",{})," ",Object(o.jsx)("br",{})," A little after that, the BitTorrent protocol was created by Bram Cohen. BitTorrent was and still is particularly well suited to transferring large files in a P2P fashion, allowing simultaneous downloads from multiple peers.",Object(o.jsx)("br",{})," ",Object(o.jsx)("br",{})," The next notable development arrived after the financial crash which very nearly brought the global economy to its knees. In 2009 Satoshi Nakamoto released Bitcoin and gave the world a 'trustless' decentralized digital currency that is not controlled by bank, government or institution. The blockchain - the immutable ledger that records all Bitcoin transactions - was something very new, solving at a stroke the difficult and long-standing problem of creating a trustless source of the truth for transactions.\xa0 The ownership of 'addresses' in the network can be proven by the usage of private keys in a Public Key Infrastructure (PKI) - hence the term cryptocurrency; however, connections between Bitcoin nodes are not fully encrypted.",Object(o.jsx)("br",{})," ",Object(o.jsx)("br",{})," The Safe Network is the next big step in the evolution of P2P networks, combining the vision of decentralized file sharing and decentralized web sites together with an internal cryptocurrency - Safe Network Token (SN) (formerly known as Safecoin) - and several additional innovations to enhance security, privacy, performance and stability. MaidSafe, a Scottish company with developers around the world, has been researching and developing this project since 2006.\xa0 Since that time, many more people have come to recognize the vital importance of a global, secure and private decentralized platform for storage and communication.",Object(o.jsx)("br",{})," "]}),Object(o.jsx)("h3",{children:"20 Fundamental Principles of the Safe Network"}),Object(o.jsx)("p",{children:" There are a number of core ideas that have driven each stage of the design of the Safe Network. These can be distilled into the following 20 fundamental principles."}),Object(o.jsx)("p",{children:"The Safe Network will:"}),Object(o.jsxs)("ol",{children:[" ",Object(o.jsxs)("li",{children:["Allow a person to create an account and login anonymously and without intervention. ",Object(o.jsx)("br",{})," Creating a new account and logging into the Network will never require a third party."]}),Object(o.jsxs)("li",{children:["Enable users to securely and with no controlling intermediaries share information and messages.",Object(o.jsx)("br",{}),"The Safe Network will never allow third parties to either read or store the information sent by a user without that user\u2019s consent."]}),Object(o.jsx)("li",{children:"Allow the transfer of the Network currency Safe Network Token to any user free of transaction costs."}),Object(o.jsxs)("li",{children:["Enable Users to anonymously create and share data worldwide. ",Object(o.jsx)("br",{}),"The Network will always ensure that the user has the ability to send transaction messages and posts with a temporary single-use ID that is not linked to any known identity on the Network."]}),Object(o.jsx)("li",{children:"Let anyone browse content anonymously and free of charge and without the need to create an account."}),Object(o.jsx)("li",{children:"Allow users to associate multiple identities with their account."}),Object(o.jsx)("li",{children:"Let users utilize any of their identities to send/receive Safe Network Token."}),Object(o.jsx)("li",{children:"Store data in perpetuity. All public/published data on the Network will be immutable and available on the Network indefinitely."}),Object(o.jsx)("li",{children:"Never require passwords to be stored on the Network or on machines used to access the Network."}),Object(o.jsx)("li",{children:"Allow any user, on any machine, to access the Network leaving no trace of their presence or activity on the machine."}),Object(o.jsxs)("li",{children:["Scrub Client IP addresses from the first hop. ",Object(o.jsx)("br",{}),"As soon as you have connected to the network, your IP address is wiped."]}),Object(o.jsxs)("li",{children:["Only accept more Vaults (networked storage provided by users' machines) when it needs them. ",Object(o.jsx)("br",{})," This is to prevent a bad actor from flooding the network with poorly performing or malicious Vaults and also to enable the Network to balance its resources automatically according to demand."]}),Object(o.jsxs)("li",{children:["Increase farming rewards when it needs more resources (e.g. more Vaults to increase storage capacity) and decrease rewards when resources are plentiful. ",Object(o.jsx)("br",{}),"This is the primary mechanism for balancing supply and demand."]}),Object(o.jsxs)("li",{children:["Rank nodes over time and increase trust in higher ranked nodes.",Object(o.jsx)("br",{}),"The aim is to maximize performance and defend against certain attacks."]}),Object(o.jsxs)("li",{children:["Not have servers! ",Object(o.jsx)("br",{}),"The Safe Network will never rely on servers (as the term is traditionally understood) as to do so introduces a third-party weakness that undermines the entire Network."]}),Object(o.jsxs)("li",{children:["Digitally sign all transactions. ",Object(o.jsx)("br",{}),"To ensure that the transactions have been authorized in accordance with the rules of the Network."]}),Object(o.jsx)("li",{children:"Ensure that Client-to-Client direct messages (i.e. those not transmitted via other nodes in the Network) are free."}),Object(o.jsxs)("li",{children:["Never use time as a network tool. ",Object(o.jsx)("br",{})," There can be no concept of time in a truly decentralized network without reaching out to centralized servers and services."]}),Object(o.jsx)("li",{children:"Only use encrypted services and encrypted traffic."}),Object(o.jsxs)("li",{children:["Allow real-time upgrades in a secure manner. ",Object(o.jsx)("br",{}),"The Network will refuse upgrades that could break it."]})," "]}),Object(o.jsx)("p",{children:"We expand on these fundamental principles in the chapters that follow. Combined they aim to give all users the freedom to safely store data on the Network, to share information with others securely, to publish websites cheaply and easily and to communicate using secure channels and apps."}),Object(o.jsxs)("p",{children:["For a fuller version of this list see the Safe Network website. ",Object(o.jsx)("a",{href:"https://safenetwork.tech/fundamentals/",children:"https://safenetwork.tech/fundamentals/"})]})]})},c=a.p+"static/media/networking_layers.f0097177.jpg",h=a.p+"static/media/stack.4ed8d5de.png",l=function(){return Object(o.jsxs)("div",{className:"chapter",children:[Object(o.jsx)("h2",{id:"ch2",children:"2. A fully autonomous data network"}),Object(o.jsx)("p",{children:"To enable Secure Access For Everyone, Safe is an \u2018autonomous data network\u2019. This means it is capable of performing networking and storage tasks such as managing and optimizing workloads, routing, failover, authentication and access control without any human intervention. Opportunities for powerful groups to aggregate control or forbid access are minimized."}),Object(o.jsx)("p",{children:"Unlike the current Internet, Safe infrastructure is not defined by a set of federated servers, VMs, owned storage locations or identifiable nodes. Unlike blockchains, it is designed to store and manage live data rather than pointers to data and to transact in real-time. And unlike BitTorrent, it does not rely on centralized components of the Web to locate and track files."}),Object(o.jsx)("div",{className:"Full-width-pic",align:"center",children:Object(o.jsx)("img",{className:"Img",src:c,alt:"Networking layers",align:"center"})}),Object(o.jsx)("p",{children:"Many features in the Safe Network are innovations, but there is no intention to reinvent the wheel. It builds on existing decentralized technologies such as BitTorrent and Kademlia and is based on the physical and data infrastructure of the Internet. Early development of Safe happened in parallel with blockchain, and it has taken an alternative route to solve the decentralization puzzle."}),Object(o.jsx)("p",{children:"The Safe Network can be seen as a secure, encrypted, intelligent layer that sits on top of the current Internet, complementing the top three layers in the OSI model and adding resources in the application layer. This enables secure, anonymous, decentralized data storage and networking."}),Object(o.jsx)("p",{children:"Going a little deeper, Safe introduces some changes to the networking and application layers as shown below."}),Object(o.jsx)("p",{children:"The Safe Network core libraries are written in the Rust programming language. The diagram below shows the basic hierarchy."}),Object(o.jsx)("div",{className:"Full-width-pic",align:"center",children:Object(o.jsx)("img",{className:"Img",src:h,alt:"Stack",align:"center"})}),Object(o.jsx)("h3",{children:"quic-p2p"}),Object(o.jsx)("p",{children:"quic-p2p (QUIC peer-to-peer or qp2p) is based on the QUIC protocol created at Google. It is a networking library that enables peers on a P2P network to communicate securely, and to re-join the network without requiring a hard-coded list of known peers; such a list would be an obvious security hole. It supports multiple protocols allowing ordinary PCs and smartphones to connect to each other and is cryptographically secure. qp2p supercedes the Crust library."}),Object(o.jsx)("h3",{children:"Routing"}),Object(o.jsx)("p",{children:"On top of qp2p sits the network overlay which forms the \u2018brain\u2019 of the Safe Network. Its purpose is to create a decentralized Internet and route information between the Nodes."}),Object(o.jsx)("p",{children:"Network routing is based on an algorithm that extends Kademlia DHT routing (see Chapter 4). It uses 32-byte (256 bit) XOR addresses to locate data on the network. It is mathematically guaranteed that messages can be routed from any part of the network to any other destination."}),Object(o.jsx)("p",{children:"Routing works on the principle of Group Consensus (see Chapter 4). For actions that mutate data or change the network a supermajority of the Nodes instructed to undertake that action must first agree that it is valid. In order to guarantee strong consistency, the network uses conflict-free replicated data types (CRDTs) for storing data, Byzantine Reliable Broadcast (BRB) for messaging, and Boneh-Lynn-Shacham (BLS) threshold cryptogrophy to reach local consensus (See Chapter 7)."}),Object(o.jsx)("p",{children:"Client connections managed by qp2p are mediated via the Client API. Sitting above that, the Safe Network API allows clients such as end user devices and apps to make use of the network, including storing, sharing and reading data. There is a command line interface (CLI) for this purpose, and apps written in Rust can access network functions directly via the API. Apps written in other languages, including the Safe Browser which is a JavaScript app, do the same via the language bindings layer. "}),Object(o.jsx)("p",{children:"Nodes and Clients provide the main means for users to interact with the Network, either by providing resources in return for payment by running a Node or by storing data and browsing the Safe web as a Client. They are discussed further in the next chapter."}),Object(o.jsx)("p",{children:"All Safe Network code is open source and licensed under GPLv3."}),Object(o.jsx)("h3",{children:"Tell me more\u2026"}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{href:"https://github.com/maidsafe/safe_network",children:" The Safe Network Core. API message definitions, routing and nodes, client core API. (Github)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{href:"https://github.com/maidsafe/quic-p2p",children:" quic-p2p - a peer-to-peer communications library for Rust based on QUIC protocol (Github)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{href:"https://docs.rs/quinn/0.7.2/quinn/index.html",children:" Quinn - QUIC protocol in Rust"})}),Object(o.jsx)("p",{children:"\xa0"})]})},d=a.p+"static/media/app_auth_flow.35eb1829.jpg",p=function(){return Object(o.jsxs)("div",{className:"chapter",children:[Object(o.jsx)("h2",{id:"ch3",children:"3. Nodes and Clients"}),Object(o.jsx)("p",{children:"The existing Internet is formed of servers and clients. Clients request data and servers provide it. When you browse the Web, you enter the address of the page into the browser (client software) and the browser requests data from the website in question which is stored on a specific server (server software)."}),Object(o.jsx)("p",{children:"The Safe Network does not use a client-server model. Instead the data resides across a network that's made up of the spare computing resources of its users. When a request for data is made, a message goes out across the Network and machines that hold the chunks that make up the required data return them to the requester."}),Object(o.jsx)("p",{children:"Safe has two basic components: Nodes and Clients."}),Object(o.jsxs)("div",{className:"Keep-it-simple",children:[Object(o.jsx)("h3",{children:"Keep it simple!"}),Object(o.jsx)("p",{children:"The Safe Network is comprised of its users' machines (nodes) linked together by Node software which routes data and messages securely between them. These machines provide the Network's storage by allocating a portion of their hard drives for this purpose \u2013 and earning the Safe Network Token currency in return."}),Object(o.jsx)("p",{children:"However, you don't have to run a Node to use the Network any more than you have to run a web server to use the Web. Client software allows users to login, store data and browse the Safe web securely and anonymously without being part of the Network. A single computer can run both Node and Client software at the same time.\xa0\xa0 "})]}),Object(o.jsx)("h3",{children:"The Node"}),Object(o.jsx)("p",{children:"The Safe Network is formed of interconnected machines (nodes) running Node software. Node software connects the devices to each other using existing protocols like TCP and UDP, manages data and routes it around the Network. It allows users to store data on their devices, potentially earning Safe Network Token currency in return. This process of providing a service in return for a reward is analogous to Bitcoin mining. On the Safe Network it's called Farming and the people who provide the resources are called Farmers (see Chapter 8)."}),Object(o.jsx)("p",{children:"Node software is a small executable file that connects the user\u2019s machine to the Safe Network, turning it into a routing node and also allocating some disk space for storage. It manages the storage of data chunks on the user\u2019s computer and in that way provides storage capacity to the Network. It also routes and caches data chunks (these are encrypted) over the Network making use of fully encrypted connections to other Nodes. Nodes are clustered logically into small groups, each of which is responsible for looking after the data stored within a certain range of network addresses, called a Section (see Chapter 4)."}),Object(o.jsxs)("div",{className:"What-does-that-mean",children:[Object(o.jsx)("h3",{children:"What does that mean?"}),Object(o.jsx)("p",{children:"quic-p2p \u2013 a software library that allows machines to connect to each other in a secure and reliable peer-to-peer fashion and to reconnect after leaving without requiring a hard-coded list of other devices."}),Object(o.jsx)("p",{children:"Node \u2013 the machines (nodes) that make up the Safe Network run Node software. Nodes provide routing and communications capabilities to the Network and also store data in the form of chunks, for which they can earn Safe Network Token (Farming) when that data is retrieved."}),Object(o.jsx)("p",{children:"Client \u2013 a program that allows users to connect to the network and make use of its services."}),Object(o.jsx)("p",{children:"Safe Browser \u2013 a browser for surfing the Safe web."}),Object(o.jsx)("p",{children:"Authenticator - enables users to create a Network account and login without going via a server (Self-Authentication) and also to approve or deny access to their data by apps."}),Object(o.jsx)("p",{children:"CLI - command line interface for typing commands into a terminal rather than using a GUI."}),Object(o.jsx)("p",{children:"Safe Network App - A desktop app for managing Safe Network applications."}),Object(o.jsx)("p",{children:"Self-Authentication - a feature that enables a user to create an account and log into the decentralized Network securely and anonymously without any central server to mediate the login process."}),Object(o.jsx)("p",{children:"Farming \u2013 earning Safe Network Token by providing resources (Storage, Bandwidth, CPU, online time) to the Network"}),Object(o.jsx)("p",{children:"Safe Network Token \u2013 the currency of the Safe Network, earned by storing data, spent by uploading data."})]}),Object(o.jsx)("p",{children:"The forming and splitting of Sections happens in a fully autonomous way as computers join and leave the Network. The same goes for the routing of chunks across the Network. There are no central servers or agents needed to form this Network (unlike, say, like BitTorrent which uses trackers). Instead, the Nodes follow a set of strict rules to create and maintain the Network, requiring no central authority to do so."}),Object(o.jsx)("p",{children:"Nodes fulfil several different functions. They route and store chunks of data; they cryptographically check messages; they cluster into collections of nodes that will manage certain Sections of the Network; they make decisions about what should and should not happen, such as whether a new Node should be allowed to join the Network."}),Object(o.jsx)("p",{children:"Running a Node in the Safe Network is called Farming because users look after the data until it is needed, at which point they may earn payment for their efforts (see Chapter 8)."}),Object(o.jsx)("h3",{children:"The Client"}),Object(o.jsx)("p",{children:"Just as you don\u2019t need to run a web server to use the Web, so you don\u2019t have to run a Node to access the Safe Network. Ordinary users interact with the network via the Client. Currently the Client provided is the command line interface (CLI) tool. Earlier iterations of the Network included a Browser and a user-friendly Safe Network App together with an  Authenticator. These will be revisitied in due course."}),Object(o.jsx)("p",{children:"Self-Authentication is a key innovation of the Network. At no point does the Network ever store a user\u2019s password. Therefore, there is no chance of that password being attacked on the Network. Instead, the user can create an account and log into the Network securely and anonymously without a central server required to mediate the login process or a trusted third party to store and manage the users\u2019 credentials. With Self-Authentication, the user generates his or her own credentials which are stored on the Safe Network in such a way that they are cryptographically obscured from all other parts of the Network."}),Object(o.jsx)("p",{children:"Because users control their own data, decentralized applications (DApps) such as the Safe Browser, require the user to authorize them to manipulate their data. For the user, the authorization process is simply a matter of clicking a button."}),Object(o.jsx)("div",{className:"Full-width-pic",align:"center",children:Object(o.jsx)("img",{className:"Img",src:d,alt:"App auth flow",width:"70%",align:"center"})}),Object(o.jsx)("p",{children:"Any user (even if they\u2019re not logged in) can request (GET) data from the network for free. For example, they can browse a safe:// site or download a publicly-posted song or movie for zero cost. It\u2019s only when the user wants to store (PUT) data onto the network that an account with Safe Network Token is needed."}),Object(o.jsx)("h3",{children:"Tell me more..."}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{href:"http://www.enterprisenetworkingplanet.com/datacenter/datacenter-blog/on-the-verge-of-autonomous-networking.html",children:"On the Verge of Autonomous Networking (Enterprise Networking Planet)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{href:"http://docs.maidsafe.net/Whitepapers/pdf/AutonomousNetwork.pdf",children:"Autonomous Network (MaidSafe whitepaper, 2010)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{href:"https://github.com/maidsafe/safe_client_libs",children:"Safe Client libraries (Github)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{href:"https://github.com/maidsafe/safe-network-app",children:"Safe Network App (Github)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{href:"https://github.com/maidsafe/safe_browser",children:"Safe Browser (Github)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{href:"https://github.com/maidsafe/safe_browser",children:"Safe Mobile Browser (Github)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{href:"https://github.com/maidsafe/sn_cli#safe-network-cli",children:"Safe CLI User Guide -  a CLI (Command Line Interface) for the Safe Network (Github)"})})]})},u=a.p+"static/media/xor_addresses.0292cd74.jpg",b=function(){return Object(o.jsxs)("div",{className:"chapter",children:[Object(o.jsx)("h2",{id:"ch4",children:"4. The architecture of the Safe Network"}),Object(o.jsx)("p",{children:"Browsing sites and storing data on the Safe Network is as simple as on the current Web but with greatly enhanced privacy, security and control. The Safe Network is designed with ease of use in mind for app developers, too. Developing simple apps for Safe is just a short step from what developers are familiar with in terms of APIs and methodologies. However, those wishing to perform more complex system-level tasks will need to go deeper into its architecture - there are some big differences between traditional client-server systems and decentralized architectures. This chapter provides a brief introduction to the topic."}),Object(o.jsx)("h3",{children:"Sections"}),Object(o.jsx)("p",{children:"The first step in understanding the architecture of the Safe Network is to take a look at distributed hash tables (DHTs)."}),Object(o.jsx)("p",{children:"Petar Maymounkov and David Mazi\xe8res released the Kademlia distributed hash table in 2002. The idea is that nodes form a network overlay, and are identified with a different node identification system. So a Node with an IP address of 96.251.182.97 might have 17846cb8a4b53c9e44c616d2415a15984283eee975a1dac8f488dd91d0aed1cd as its unique 256-bit address in XOR space."}),Object(o.jsx)("p",{children:"Bitwise Exclusive OR (XOR) has the feature that each address is a unique distance from any other address in the entire address range. XOR distance bears no relation to physical distance. Indeed, two pieces of data on the network may be very close XOR-wise but be sitting on machines located on opposite sides of the world."}),Object(o.jsxs)("p",{children:["MaidSafe developed an enhancement to Kademlia by splitting the 256-bit address range into so-called 'Disjoint Sections', or Sections for short. A 256-bit address space has 2",Object(o.jsx)("sup",{children:"256"})," -1 possible addresses which is an extremely large number to manage, but it can be split up into smaller Sections based on address, with each Section being managed by a group of Nodes (also generally known as a Section)."]}),Object(o.jsx)("p",{children:"The Nodes managing a Section must reach agreement (consensus) before authorising any mutation (Network-changing event) happening within that Section. As a collective, they can also provide \u2018section authority\u2019 to messages that travel over the wider Network so that other Nodes and/or Sections can cryptographically verify the validity of the message and the action it contains. These Section signatures are stored in \u2018SectionChains\u2019 which are secured and held by members of that Section, and by neighbouring Sections. This is known as group agreement (or local consensus). ??? group"}),Object(o.jsxs)("div",{className:"What-does-that-mean",children:[Object(o.jsx)("h3",{children:"What does that mean?"}),Object(o.jsx)("p",{children:"Distributed hash table \u2013 a map of where data is stored on a distributed network."}),Object(o.jsx)("p",{children:"XOR networking \u2013 a way of randomizing the physical location of data on a distributed network and ensuring each location is unique."}),Object(o.jsx)("p",{children:"Section \u2013 a subset of the addresses on the network. "}),Object(o.jsx)("p",{children:"Agreement \u2013  when the required proportion of decision-making Nodes (Elders - see Chapter 5) a Section vote the validity of events affecting the Section."}),Object(o.jsx)("p",{children:"group_size \u2013 a parameter stipulating the minimum number of Elders - Nodes that can look after a Section (curently set at 7)."}),Object(o.jsx)("p",{children:"Bootstrapping \u2013 starting up the Safe Network by connecting together a minimum number of Nodes. Bootstrapping is also used to describe a new Node joining the Network."}),Object(o.jsx)("p",{children:"Bootstrap node \u2013 a node to which a new Node initially connects. Any Node can potentially be a bootstrap node, so long as its IP address is written in the Node\u2019s configuration file, or, for subsequent connections, its cache. "}),Object(o.jsx)("p",{children:"Hash function \u2013 a function used to map data of arbitrary size to data of fixed size (e.g. a 256-bit string of characters) called a hash. Any change to the original data will result in a completely different hash. Safe uses the SHA-3 hash function."}),Object(o.jsx)("p",{children:"SectionChain \u2013 a sequence of public keys, each signed by the previous one, that's updated every time an Elder is changed and acts as proof that the Section is valid."}),Object(o.jsx)("p",{children:"Sharding \u2013 on Safe Network this refers to the splitting of the Network into individual sections, each managed by a unique Group of Nodes."}),Object(o.jsx)("p",{children:"Supermajority \u2013 more than a simple majority, so e.g 5 out of 7 rather than 4 out of 7."}),Object(o.jsx)("p",{children:"Elders \u2013 Nodes with decision-making powers, the oldest 7 Nodes in a Section (see Chapter 5)."}),Object(o.jsx)("p",{children:"Adults \u2013 Nodes that perfom storage duties but do not make decisions (see Chapter 5)."})]}),Object(o.jsx)("p",{children:"Importantly, on joining or rejoining the Safe Network a Node cannot simply pick its own XOR address - in other words, it can\u2019t choose the Section it will be part of. Instead, it has to wait to be allocated to a Section that is chosen by the Network. When this occurs, the node receives the Section's Routing Table and learns the exact unique address range (and therefore the data) that it will be responsible for."}),Object(o.jsx)("p",{children:"Data stored on the Safe Network is first broken into chunks, hashed and then encrypted (see Chapter 6). Those chunks are run through a hashing algorithm to create a unique 256-bit hash for each chunk. Only chunks that are exactly identical will have the same hash value. This hash serves as the XOR address on the Network where that chunk will be stored, which in turn determines the Section that will manage it."}),Object(o.jsx)("p",{children:"Chunks with hashes that lie within a certain address range (say 000010... to 000011...) will be secured, stored and managed by a group of Nodes (a Section) that is closest (in XOR terms) to that location. The membership of this Section will change over time as new Nodes join and others leave."}),Object(o.jsx)("p",{children:"When the Network starts up, the initial nodes will be responsible for the whole 256-bit address range. But as more nodes join the Network will split and form new Sections. As still more nodes join, the Sections will continue to split, creating standalone Disjoint Sections running individual consensus algorithms, with votes taken only by the Elders (nodes with decision-making powers, see Chapter 5) within them. This is known as \u2018Sharding\u2019 and is a crucial part of the way in which the Network solves the challenges of scalability."}),Object(o.jsx)("p",{className:"Pullquote",children:'"The hash of a chunk of data serves as the XOR address on the Network where it will be stored, which in turn determines the Group of nodes that will manage it"'}),Object(o.jsx)("div",{className:"Full-width-pic",align:"center",children:Object(o.jsx)("img",{className:"Img",src:u,alt:"Networking layers",width:"70%",align:"center"})}),Object(o.jsx)("p",{children:" Experiments are ongoing to find the optimum group size, but it will probably be around 100."}),Object(o.jsx)("p",{children:"If a particular Section grows significantly in the eyes of the Network, it will split into two smaller Sections (ranges of addresses). "}),Object(o.jsx)("p",{children:"If a Section finds its membership decreasing below a certain limit then it requests that nodes be relocated to it earlier or that it gets priority for Infant nodes joining the network. Given these balancing mechanisms is extremely unlikely that a Section will become too small (~7 nodes) to be viable."}),Object(o.jsx)("h3",{children:"Agreement"}),Object(o.jsx)("p",{children:"The Elder Nodes managing a Section must reach consensus among themselves on Network events under their control before they can happen. They also \u2018Section-sign\u2019 messages that travel over the wider Network. Elders in Sections recieving these messages need to be sure they are from from valid Sections. Because Section membership is fluid, every time it changes (Elder churn) a new public key is created and signed by the current Elders using the previous key. This series of public keys, each signed by the previous one is called a SectionChain and serves to prove the validity of the Section (See BLS-DKG, Anti-Entropy, Chapter 7). "}),Object(o.jsx)("p",{children:"SectionChains allow Section authority to be baked into the data management process, providing a simple decentralized record of which Section signed which data."}),Object(o.jsxs)("div",{className:"Keep-it-simple",children:[Object(o.jsx)("h3",{children:"Keep it simple!"}),Object(o.jsx)("p",{children:"In order for something to occur in their Section that might alter it, the Elder Nodes must first agree that the action is valid. A supermajority (at least 5 out of 7 votes) is required. If consensus is not reached, the actor requesting the change - say, trying to write data to the Network - must try again.  "})]}),Object(o.jsx)("p",{className:"Pullquote",children:'"No node in the Safe Network has a complete overview of the network"'}),Object(o.jsx)("p",{children:"The closer a Node is to a certain address space on the Safe Network, the more information it has about data that is stored at that address. And logically, the further away a Node is, the less information it has. The bigger the Network becomes, the more secure it will get because an individual Node will have influence over a decreasing range of addresses."}),Object(o.jsx)("p",{children:"An action or event happening in a Section is only valid once a supermajority of Elders (5 out of 7) has approved it. "}),Object(o.jsx)("h3",{children:"Tell me more..."}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{href:"http://www.globule.org/publi/SDST_acmcs2009.html",children:"A Survey of DHT Security Techniques (Globule)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{href:"https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf ",children:"Kademlia: A Peer-to-peer information system based on the XOR Metric (Whitepaper, 2010)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{href:"http://docs.maidsafe.net/Whitepapers/pdf/MaidSafeDistributedHashTable.pdf ",children:"Distributed Hash Table (MaidSafe Whitepaper, 2010)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{href:"http://docs.maidsafe.net/Whitepapers/pdf/DHTbasedNATTraversal.pdf ",children:"DHT-based NAT Traversal (MaidSafe Whitepaper)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{href:"https://en.wikipedia.org/wiki/Disjoint-set_data_structure ",children:"Disjoint-set data structure (Wikipedia)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{href:"https://github.com/maidsafe/rfcs/blob/master/text/0037-disjoint-groups/0037-disjoint-groups.md ",children:"Disjoint Sections (MaidSafe RFC)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{href:"https://safenetforum.org/t/fast-ephemeral-routing/32173",children:"Fast Ephemeral Routing (RFC and discussion, introduces concept of SectionChains)"})})]})},f=a.p+"static/media/nodes_journey.7bf35734.png",m=function(){return Object(o.jsxs)("div",{className:"chapter",children:[Object(o.jsx)("h2",{id:"ch5",children:"5. Node Age"}),Object(o.jsx)("p",{children:"Node Age is a measure of how long a Node has been a reliable participant in the Network. It dictates the activities the Node can carry out and ultimately how much it will be paid (Chapter ???) "}),Object(o.jsx)("p",{children:"There are three categories of Node. Infants are Nodes waiting to join a Section, Adults are responsible for storing data and giving it up speedily on request, and Elders are the decision makers. In the current design there are seven Elders per section and around 100 Adults."}),Object(o.jsx)("p",{children:"When a Node first joins the Network asn an Infant, it first needs to discover the IP addresses of some existing Network participants. At launch, MaidSafe will temporarily provide a small number of bootstrap nodes (Internet-connected machines running the Node software). The IP addresses of these bootstrap nodes are included in the new Node's configuration file. Alternatively, if the Node owner already knows the IP addresses of some vaults on the Network, for example machines run by a friend, these may be used instead. Through those bootstrap nodes it can connect to other known Nodes in the Network. The connection itself is fully encrypted (with the randomly-generated public keys of all valid Nodes being stored on the Network) and that initial connection is dropped immediately after the first hop once the new Node has connected to others in the Network."}),Object(o.jsxs)("div",{className:"Keep-it-simple",children:[Object(o.jsx)("h3",{children:"Keep it simple!"}),Object(o.jsx)("p",{children:"Just as children are not allowed to vote in elections, so a Node may not vote on Network events - such as whether a new member is allowed to join or whether a Section should split - until it has proven itself to be reliable. A Node gains trust each time it moves to a new Section whereupon its Node Age increases by 1. Once it is among the oldest in its Section (in terms of Node Age), it may be given voting rights as an Elder. Forcing Nodes to prove themselves in this way is an important security measure."})]}),Object(o.jsx)("p",{children:"A new Node connects to other Nodes over the qp2p layer, sending out a message to a network Elder whose IP address it knows or is in its config file saying it wants to join. At this stage the Infant Node has a Node Age of zero. It is not permitted to join the network until it is needed by the section of which the Elder is a part (say Section X)."}),Object(o.jsx)("p",{children:"A supermajority of Elders in Section X must agree that a new Node is needed before it is allowed to join. When they do, the Elders send out a Resource Proof request which forces the Infant Node to prove that it can perform a simple task (a proof of work)."}),Object(o.jsx)("p",{children:"After being accepted by Section X, the Node becomes an Adult with a Node Age of 5, and resides there for a number of churn events, roughly proportional to 2^age (i.e. 2^5). The jump from zero to age 5 is currently thought to offer a reasonable balance between limiting strain on the network caused by rapid relocations and safety - the Node will have very little opportunity to act maliciously in the Section before it is relocated. This figure may change with more testing. Section X will not accept any new joining Nodes until the relocation has taken place."}),Object(o.jsx)("p",{children:"After a certain amount of time it is relocated to another section, Section Y, selected as being closest to the hash of the Node's ID (public key). Section Y must accept the new Node because relocation requests have Network Authority, meaning it is to be trusted. (See Chapter ???) Before being relocated to Section Y the Node\u2019s age is increased from 5 to 6, meaning it will remain in Section Y for a longer time (proportional to  2^6). So long as it proves itself reliable in Section Y, the Node's age will be upped to 7, it will be given a new ID and it will be relocated to Section Z, where it will remain for a time proportional to 2^7 \u2026 and so on. "}),Object(o.jsx)("p",{children:"The process of increasing Node Age is thus exponential - it becomes increasingly difficult the older the Node is. Newer Nodes are more likely to be moved to a new Section -  and thus increment their Node Age - than older, more trusted ones are. "}),Object(o.jsx)("p",{children:"Nodes can be demoted too. If trust is lost it must be re-earned. If the Adult Node restarts or misbehaves, it will be relocated to a new Section with its age halved. If it is found to be less than half as responsive as its neighbour(s) it will be ejected from the Network and will need to start again as an Infant. "}),Object(o.jsx)("p",{children:"If an Elder proves unreliable, it will also be demoted to an Adult or ejected by the other Elders, following a similar mechanism, with the oldest Adult in the Section promoted to Elder status in its place."}),Object(o.jsx)("p",{children:"Because only Nodes that have proved their value to the Network can vote, it is close to impossible for\xa0 an attacker to target a particular Section on the Safe Network. Node Ageing and churn (nodes swapping Sections) are thus vital security features."}),Object(o.jsx)("p",{children:"Only the most trusted Nodes in a Section, those Nodes with the greatest Node Age, become Elders. Other Nodes (Infants, Adults) simply receive notification of their decisions."}),Object(o.jsx)("div",{className:"Full-width-pic",align:"center",children:Object(o.jsx)("img",{className:"Img",src:f,alt:"Node's journey",align:"center"})}),Object(o.jsxs)("div",{className:"What-does-that-mean",children:[Object(o.jsx)("h3",{children:"What does that mean?"}),Object(o.jsx)("p",{children:"qp2p \u2013 a networking library that enables peers on a P2P network to communicate securely, and to re-join the network without requiring a hard-coded list of known peers."}),Object(o.jsx)("p",{children:"Resource Proof \u2013 a test of bandwidth and CPU power. If a Node trying to join the Network fails the test or takes to long to return it, it will not be allowed to join."}),Object(o.jsx)("p",{children:"Node Age \u2013 a measure of the trustworthiness of a Node. After the initial connection, a Node gets moved at random from Section to Section, building its reputation or Node Age. Once its Node Age reaches a certain value it can be an active participant in the decisions of the Section as an Elder."}),Object(o.jsx)("p",{children:"Churn \u2013 the act of Nodes leaving a group or new Nodes joining. Churn means that Sections are not static for long."}),Object(o.jsx)("p",{children:"Elder \u2013 a node with voting rights in its Group. Elders are simply those nodes with the greatest Node Age in the Group."}),Object(o.jsx)("p",{children:"Adult \u2013 a node that has no voting rights but can store data."}),Object(o.jsx)("p",{children:"Infant \u2013 a node that has recently joined the Network. It has no voting rights and cannot store data."})]}),Object(o.jsx)("h3",{children:"\xa0Tell me more..."}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"Introduction & Technical Overview of Safe Consensus",href:"https://blog.maidsafe.net/2016/06/23/introduction-technical-overview-of-safe-consensus/",children:"Introduction & Technical Overview of Safe Consensus (MaidSafe blog, 2016)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{href:"http://conferences.sigcomm.org/imc/2006/papers/p19-stutzbach2.pdf",children:"Understanding Churn in Peer-to-Peer Networks (Sigcomm, Research paper, 2006)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{href:"https://safenetforum.org/t/node-ageing-rfc/11377/1",children:"Node Ageing RFC (and forum discussion)"})})]})},j=function(){return Object(o.jsxs)("div",{className:"chapter",children:[Object(o.jsx)("h2",{id:"ch6",children:"6. Encryption"}),Object(o.jsx)("p",{children:"Data on the Safe Network is protected by several layers of encryption. Even public data (like a blog safe://website/blog) is fully encrypted, but in this case the keys needed to decrypt the data are shared with visitors to make it available to them. This makes it different from other peer-to-peer networks like BitTorrent and IPFS where data is not natively encrypted. Safe puts security first every time. "}),Object(o.jsxs)("div",{className:"Keep-it-simple",children:[Object(o.jsx)("h3",{children:"Keep it simple!"}),Object(o.jsx)("p",{children:"All data on the Safe Network is encrypted. When a file is stored on the Network it is first broken into chunks, hashed and then encrypted and these chunks are themselves encrypted using the hash of another chunk from the same file. This is Self-Encryption - a method patented by MaidSafe but now open-sourced. "})]}),Object(o.jsxs)("p",{children:["At the network level, the Safe Network uses the TCP, UTP and \xb5TP protocols and all the data moved by these protocols is encrypted from 'bit 1'. This means that the first connection to the Safe Network that a Node or Client makes is to a bootstrap server, one of a number of temporary servers run by MaidSafe to allow new machines to join. The randomly generated public keys for these bootstrap servers are retrieved from the network by the Client, so communications between the Network and the user are always encrypted, never in plain text. Note that any Node on the Network can be used as a bootstrap server so long as its IP address is added to the configuration file of the joining Node. It ",Object(o.jsx)("em",{children:"does not"})," have to be one provided by MaidSafe. "]}),Object(o.jsx)("p",{children:"Clients and Nodes in the Network get a list of IPs and public keys of other users to connect to. These connections are also encrypted from bit 1. "}),Object(o.jsx)("h3",{children:"Clients connect anonymously"}),Object(o.jsx)("p",{children:"To ensure anonymity, the identity of a Client connecting to the Network must be hidden from the Nodes that comprise it. For this reason, the initial connection between a Client and a Node is a two-step process. First it connects via IP to a Node whose IP address is in its config file or cache. This Node knows the Client's IP address and will allow it to connect to a Section via a Section Elder's XOR address. Thereafter, that initial Node has no connection with the Client and cannot track its activities. The Nodes in the Section it joins cannot see the Client's IP address but they know its public key and XOR address. All connections between the Client and the Group(s) are fully encrypted."}),Object(o.jsx)("h3",{children:"Self-encryption of data"}),Object(o.jsx)("p",{children:"As described above, all data on the Safe Network is encrypted - the exception being small files less than 1KB in size. When a Client uploads a piece of data to the Network (for example an mp4 video) it is first broken into chunks and those chunks are then 'self-encrypted', a process patented by MaidSafe by which each chunk is encrypted using its own hash and the hashes of the two previous chunks in the same file. These encrypted chunks are then hashed again to arrive at the XOR address where the chunk will be stored. At the same time a Data Map is created on the Client device, which maps the chunk number to the XOR address of the chunk and the hash to decrypt it and its two successors, allowing the file to be recreated. A number of copies of each chunk are stored by Nodes in the Section to ensure redundancy."}),Object(o.jsx)("p",{children:"The Client retains the keys to decrypt the data locally. That way no keys or passwords need ever leave a person's device. Chunks are stored on the Safe Network in a fully encrypted way. Users can choose to share these files with others by sharing their keys with them. They can also choose to make the files fully public, in which case the keys required to decrypt the files are made publicly available, as with the example of a blog."}),Object(o.jsx)("div",{className:"Pullquote",children:Object(o.jsx)("p",{children:'"The Safe Network provides a platform for applications that is both highly secure and anonymized by design"'})}),Object(o.jsx)("h3",{children:"Multilayered encryption"}),Object(o.jsx)("p",{children:"The Safe Network uses several layers of encryption to protect a user's anonymity and privacy. Several extra layers are active when people use direct messaging or create a public profile. The Network is designed to be as 'zero-knowledge' as possible, to the extent that Farmers cannot possibly figure out what chunks from which private file they are storing - even if it's their own. By utilizing multiple levels of encryption as well as obfuscating the identity of its users after the first hop, the Safe Network provides a platform for applications that is both highly secure and anonymized by design."}),Object(o.jsx)("h3",{children:"BLS-DKG"}),Object(o.jsx)("p",{children:"Safe uses BLS-DKG to secure the Elder voting process and to authenticate messages passed betwen Sections (see Chapter 7)"}),Object(o.jsxs)("div",{className:"What-does-that-mean",children:[Object(o.jsx)("h3",{children:"What does that mean?"}),Object(o.jsx)("p",{children:"Self-Encryption - Files uploaded to the Safe Network are broken up into chunks. These chunks are then hashed, encrypted locally using the AES-256 encryption algorithm and the hashes of neighbouring chunks. Because data is encrypted and decrypted locally, there is no need for keys to leave the user's machine."}),Object(o.jsx)("p",{children:"Data Map - a record of file chunks and their corresponding locations on the Network. Only those in possession of the Data Map can recreate the file. "}),Object(o.jsx)("p",{children:"BLS-DKG - a cryptographic system that authenticates the sender of a message, allows for multiple parties to quickly come to a consensus, and can enable multi-signature transactions. "})]}),Object(o.jsx)("h3",{children:"Tell me more..."}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"sodium",href:"https://github.com/maidsafe/rust_sodium",target:"_blank",rel:"noopener noreferrer",children:"Connecting to the Sodium crypto library"})}),Object(o.jsx)("p",{title:"Crypto 101 ",children:Object(o.jsx)("a",{title:"Crypto 101 ",href:"https://www.crypto101.io/ ",target:"_blank",rel:"noopener noreferrer",children:"Crypto 101\xa0"})}),Object(o.jsxs)("p",{children:[Object(o.jsx)("a",{title:"Self encrypting files",href:"https://github.com/maidsafe/self_encryption",children:"Self encrypting files (convergent encryption plus obfuscation) (GitHub)"})," "]}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"Self Encryption",href:"https://www.youtube.com/watch?v=Jnvwv4z17b4",target:"_blank",rel:"noopener noreferrer",children:"Self Encryption on the Safe Network (YouTube)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"Self-encrypting Data",href:"http://docs.maidsafe.net/Whitepapers/pdf/SelfEncryptingData.pdf",target:"_blank",rel:"noopener noreferrer",children:"Self-encrypting Data (MaidSafe Whitepaper)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"UDP Hole Punching ",href:"https://github.com/maidsafe/rfcs/blob/04f276056bf909f415b47ae341b16ce78af0c7a4/text/0008-udp-hole-punching/0008-udp-hole-punching.md",target:"_blank",rel:"noopener noreferrer",children:"UDP Hole Punching (MaidSafe RFC) "})})]})},w=function(){return Object(o.jsxs)("div",{className:"chapter",children:[Object(o.jsx)("h2",{id:"ch7",children:"7. Network-wide consensus not required"}),Object(o.jsx)("h3",{children:"A hard problem"}),Object(o.jsx)("p",{children:"Truly decentralized networks can have no master node or oracle to judge what is true or valid and what is not. Instead, the nodes that make up the Network must come to an agreement among themselves about which of many possible versions of \u201cthe truth\u201d they will accept."}),Object(o.jsx)("p",{children:"Discrepancies can arise for many reasons, but a frequent cause is the physical distance between nodes. As an example, let\u2019s say node Alice in Sydney relays a message to node Bob in Edinburgh. Before the signal can travel halfway around the world, node Carol in London transmits a different message to Bob. Because London is much closer to Edinburgh, Carol's message arrives before Alice's, even though it was sent later. Without a central time-clock, how can we decide which is the correct order of events? It's important that the Network picks wisely one version of events and sticks with it, since all future events on the Network will be affected by its decision. It does this by asking nodes to report on what they saw, deriving the most likely course of events and then finally propagating that version around the network."}),Object(o.jsx)("p",{children:"In our example, the nodes that make up the network must vote on which message - Alice's or Carol's - they will accept as being sent first, based on information about the two events that each has received. What\u2019s more, the Network must account for the fact that a certain proportion of the nodes may be unreliable or even actively malicious and yet still converge on one rules-based version of the truth. This is called Byzantine Fault Tolerance (BFT). The way the maths works out, up to one-third of the nodes could be corrupt (Byzantine) and a Network with a good BFT consensus algorithm will still function reliably. (If more than a third are corrupt, BFT becomes mathematically impossible according to current theory.)"}),Object(o.jsx)("h3",{children:"Proof of Work"}),Object(o.jsx)("p",{children:"The Bitcoin blockchain uses Proof of Work (PoW) to solve these problems of achieving decentralised consensus over the ordering of events to prevent the problem of double-spend \u2013 being able to spend the same coin twice \u2013 and Byzantine behaviour. Miners battle to verify a block of transactions. If there are two simultaneous winners the chain will split and for a time there are two versions of the truth, i.e. two chains emanating from the disputed block. Ultimately, though, after a few blocks have been added one chain will be longer than the other, and it is this chain that will be accepted as the true state. The failed blocks go back into the pot to be verified again. This is how the Bitcoin blockchain (and most other blockchains) achieves consensus. This mechanism also offers a defence against the 51 percent attack (see Chapter 12)."}),Object(o.jsx)("p",{children:"Since miners are (ideally) independent operators distributed all over the world, and because it takes a lot of energy to verify a block, it is extremely difficult and expensive to deliberately influence the growth of one sub-chain over another. Difficult but not impossible: if one miner or mining group manages to consolidate more than half of the mining power, that miner can then spend some Bitcoin, split the chain and then grow the sub-chain that does not contain the transaction. Effectively this rogue miner is rewriting history. Once that sub-chain is accepted as \u2018the truth\u2019 the original transaction officially never happened according to the ledger, and the miner is free to spend the coins again."}),Object(o.jsx)("p",{children:"This is the Sybil attack, also known as the 51 percent attack because it becomes possible when one entity owns more than half of the mining power."}),Object(o.jsx)("p",{children:"While such attacks have been successfully launched against some cryptocurrencies, Ethereum Classic being one example, Proof of Work has generally been rather effective in protecting against 51 percent attacks and at achieving BFT consensus across the network. But it is slow, massively energy-intensive and it doesn\u2019t scale. Also, the consensus is probabilistic rather than deterministic: after some time, you might be 99.9 percent sure that all nodes agree on network state, but never 100 percent."}),Object(o.jsx)("p",{children:"The Safe Network does not use a blockchain or PoW for consensus. Instead it uses a combination of lightweight mechanisms that together achieve the same goal, including Boneh-Lynn-Shacham Distributed Key Generation (BLS-DKG), Byzantine Reliable Broadcast (BRB) and Conflict-free Data Types (CRDTs)."}),Object(o.jsx)("h3",{children:"Boneh-Lynn-Shacham Distributed Key Generation"}),Object(o.jsx)("p",{children:"BLS-DKG is a cryptographic signature scheme that allows the recipient of a signed message to verify with certainty that the sender is authentic since there can only ever be one valid signature for any public-key\u2013message combination. This is obviously extremely useful in a decentralized network where there is no central source of authority and only a limited amount is known about other players. The 'distributed key generation' (DKG) part of the name refers to the fact that a certain number of parties (a threshold) must participate in generating a public\u2013private key pair, with the private key split up and distributed between them. Since they each hold a part of the private key, all parties must also participate in order to decrypt a message encoded with the public key, making BLS a great fit for Elders voting on decisions in a Section, or indeed for multisig transactions where more than one signature is required before payment."}),Object(o.jsx)("p",{children:"BLS-DKG has other desirable properties too, including small-sized keys and signatures which make for efficient and fast operations and it can operate asynchronously. In short, it is a quick, secure and reliable way to obtain consensus in certain circumstances without having to rely on a full ABFT consensus algorithm. "}),Object(o.jsxs)("div",{className:"What-does-that-mean",children:[Object(o.jsx)("h3",{children:"What does that mean?"}),Object(o.jsx)("p",{children:"Byzantine Fault Tolerance \u2013  the ability of a decentralized network to function properly even if up to a third of the nodes (plus 1) is corrupt or faulty."}),Object(o.jsx)("p",{children:"Asynchronous \u2013 Not time-dependent. An asynchronous process should come to a consenus no matter what order the various messages arrive in."}),Object(o.jsx)("p",{children:"Proof-of-Work \u2013 the consensus algorithm used by the Bitcoin blockchain to confirm that transactions are valid and to deter attacks."}),Object(o.jsx)("p",{children:"BLS-DKG \u2013 a cryptographic system that authenticates the sender of a message, allows for multiple parties to quickly come to a consensus, and can enable multi-signature transactions."}),Object(o.jsx)("p",{children:"Byzantine Reliable Broadcast \u2013  A pattern used by the Safe Network that forces the requester to do the work of obtaining authority from the network before it can make a change. "}),Object(o.jsx)("p",{children:"CRDTs \u2013 Data structures that obey certain mathematical rules which ensure that when multiple versions of data exist across a distributed network, eventually these will always converge onto one 'true' version."}),Object(o.jsx)("p",{children:"Anti Entropy \u2013 A way of preventing a Section from making changes while its membership is in a state of flux."}),Object(o.jsx)("p",{children:"Malice Detection \u2013  detecting and ejecting nodes that are acting suspiciously."})]}),Object(o.jsx)("h3",{children:"Byzantine Reliable Broadcast "}),Object(o.jsx)("p",{children:"Byzantine Reliable Broadcast guarantees that all processes in a distributed system deliver the same set of messages, even if up to a third are Byzantine (unreliable or malicious). In the Safe Network its use allows us to forces the requester to do the work of obtaining Section Authority. The requester (say, a Client wanting to store a data chunk) is responsible for aggregating the individual signature shares from the Elders in a Section to create a SectionSignature, after which the requested operation becomes valid and can be resubmitted to the Section."}),Object(o.jsx)("p",{children:"The BRB setup adopted by Safe Network derives from the AT2 distributed networking ABFT algorithm, which suppots simple cryptocurrency transactions without needing network-wide consensus. However, the Safe Network does not use AT2 for such tansactions, it uses DBCs instead (See Chapter ???)."}),Object(o.jsx)("p",{children:'The Safe Network uses BRB to quickly enforce consensus at a Section-wide rather than a Network-wide level, and to push a lot of the work involved onto the Client. So if a Client wants to store or alter data held by a Section, it asks the Elders to sign an agreement. The Elders check the logic and then each sends back a signed agreement (a BLS key share). The Client collects these key shares and once a supemajority has arrived (say 5 out of 7 Elders agree) it creates sends them back to the Elders. The Elders now see a valid message "Please deduct from my account the sum of X" and carry out the command. The Client can perform this task of aggregating votes much more efficiently than the Elders, who would otherwise have to come to agreement between themselves via a resource-intensive consensus mechanism.'}),Object(o.jsx)("p",{children:"If the Client tries to talk to only a few Elders or to the same Elder twice it will fail to gather sufficent votes."}),Object(o.jsx)("h3",{children:"Anti-Entropy"}),Object(o.jsx)("p",{children:"A major hurdle that any decentralized network which will experience churn must overcome is keeping the nodes up to date with the network\u2019s current state. Who has joined and who has left? Who are the current Elders in any given section? Elders are by definition relatively dependable and churn amongst them is minimal, but Safe Network is asynchronous and communications between section Elders and external actors may be few and far between. The Elders in a section may have churned many times between contacts."}),Object(o.jsx)("p",{children:"It\u2019s vital actors wishing to make changes on the network have an up-to-date \u2018understanding\u2019 of the section before they are allowed to do so, otherwise data could be written to Elders that no longer exist."}),Object(o.jsx)("p",{children:"Entropy, or increasing disorder, is a characteristic of a constantly changing network. We cannot reduce it but we can wait for periods of zero change among Elders before allowing a change in their section. Anti-Entropy (AE) is the mechanism for doing this. AE forces all Nodes that want to perform data operations on the network to prove the information they hold on teh Network stucture is up to date. (see Chapter ????"}),Object(o.jsx)("h3",{children:"Conflict-free Replicated Data Types (CRDTs)"}),Object(o.jsx)("p",{children:"There's another way to ensure consistency asynchronously across a decentralized network without consensus: CRDTs. With CRDTs consistency is inherent in the data structure itself. If different versions of the same data exist across a set of connected nodes (or replicas as they are known in CRDT-speak), they will all eventually converge on the same state. If some data is changed on an offline replica, as soon as connection is re-established this change will propagate to all other replicas, even if the same data was changed on another replica in its absense. At the end of the process, everyone will have the exact same version."}),Object(o.jsx)("p",{children:"At the start of this chapter we mentioned the problem of users sending messages from different places and the difficulty of agreeing their order. With CRDTs it is not necessary to try enforce an order or agree on it before changes can be applied. If Bob sees Alice's message before Carol's then that's the order that will be replicated around the network. No questions asked. If Bob receives Alice's and Carol's messages at exactly the same time he just picks an order randomly (A-C or C-A) and all replicas will accept that as the correct state."}),Object(o.jsx)("p",{children:"CRDTs can range from simple counters to more complex structures, such as documents on which many people collaborate. Because CRDTs follow a strict set of rules based on metadata contained within their structure, conflicts (i.e. the persistence of multiple states of the same data) are automatically avoided without any special code or user intervention required."}),Object(o.jsx)("p",{children:"Not every data structure can be a CRDT, but where it's possible it makes the job of ensuring consistency significantly easier. Changes can be made locally to CRDTs in complete confidence that they will be valid whatever may be happening elsewhere. This combines well with the AT2-type process described above: the Client can only request changes to CRDT data that are valid and once these have been approved by a quorum of Elders they cannot fail. Once again, this takes strain off the network."}),Object(o.jsx)("p",{children:"On the Safe Network mutable data types are being formatted as CRDTs (see Chapter 10)."}),Object(o.jsxs)("div",{className:"Keep-it-simple",children:[Object(o.jsx)("h3",{children:"Keep it simple"}),Object(o.jsx)("p",{children:"Voting nodes (Elders) need to be able to agree on the current state of the network, even if there are many different possible versions so that operations are carried out consistently. However, many typical operations - paying for data to be stored, transfering funds, editing data - can be performed locally requiring only that the operation is consistent with the data type and Network logic, that it has been approved by a certain number of Elders, and that if other Sections need to be involved, those Elders can prove they are who they claim to be. By using a combination of BLS-DKG, BRB, CRDTs and secure messaging, the Safe Network keeps operations local which is simpler, more efficient and in keeping with the core principles of decentralization."})]}),Object(o.jsx)("h3",{children:"Tell me more \u2026"}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"Signature-Free Asynchronous Byzantine",href:"https://hal.inria.fr/hal-00944019/document",target:"_blank",rel:"noopener noreferrer",children:"Signature-Free Asynchronous Byzantine Consensus with t < n/3 and O(n2) Messages (Mostefaoui et al) "})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"eth classic",href:"https://medium.com/datadriveninvestor/ethereum-classic-hacked-by-51-attack-f62c70cadd5c",target:"_blank",rel:"noopener noreferrer",children:"Ethereum Classic \u201cHACKED\u201d by 51% attack! (Medium)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"bft",href:"https://people.csail.mit.edu/silvio/Selected%20Scientific%20Papers/Distributed%20Computation/BYZANTYNE%20AGREEMENT%20MADE%20TRIVIAL.pdf",target:"_blank",rel:"noopener noreferrer",children:"Byzantine Agreement, Made Trivial (Micali) (MIT)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"BLS",href:"https://en.wikipedia.org/wiki/Boneh%E2%80%93Lynn%E2%80%93Shacham",target:"_blank",rel:"noopener noreferrer",children:"Boneh-Lynn-Shacham (Wikipedia)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"BLSa",href:"https://www.youtube.com/watch?v=vBU70EjwGfw",target:"_blank",rel:"noopener noreferrer",children:"BLS Threshold Crypto - Interface for Rust library threshold_crypto (Ian Coleman)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"CRDTa",href:"https://bartoszsypytkowski.com/the-state-of-a-state-based-crdts/",target:"_blank",rel:"noopener noreferrer",children:"An introduction to state-based CRDTs"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"CRDTa",href:"https://www.youtube.com/watch?v=B5NULPSiOGw",target:"_blank",rel:"noopener noreferrer",children:"CRDTs and the Quest for Distributed Consistency (YouTube)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"CRDTa",href:"https://www.youtube.com/watch?v=vBU70EjwGfw",target:"_blank",rel:"noopener noreferrer",children:"CRDTs for Non Academics (YouTube)"})})]})},g=a.p+"static/media/proof_of_resource.e6690dbe.jpg",y=a.p+"static/media/resources_and_currency.048229c9.jpg",k=function(){return Object(o.jsxs)("div",{className:"chapter",children:[Object(o.jsx)("h2",{id:"ch8",children:"8. Farming for Safe Network Token"}),Object(o.jsx)("p",{children:"The main incentive for Node operators to join the Network and cooperate toward the goal of secure data storage is to earn Safe Network Token (SN) - formerly Safecoin. The idea behind Safe Network Token is similar to that of Bitcoin: to ensure that cooperative participation is a more rational course of action than uncooperative or malicious participation. Safe Network Token can be spent on the Network or exchanged for other currencies."}),Object(o.jsx)("p",{children:"The amount of data that a user can store on the Safe Network depends on the Safe Network Token balance of the user's account."}),Object(o.jsxs)("div",{className:"Keep-it-simple",children:[Object(o.jsx)("h3",{children:"Keep it simple!"}),Object(o.jsx)("p",{children:"Farming is the process by which users who lend out spare storage can earn Safe Network Token, the currency of the Safe Network. Safe Network Token can be spent on the Network, for example by uploading files."})]}),Object(o.jsx)("p",{children:"When a user of the Network requests some data, for example by browsing a website, a number of things happen. First, the Client software makes a request for the required data chunks. This message (a GET request) is then propagated across the Nodes, and when a chunk is found there is a competition between the Nodes in the Section where it is located to deliver it to the Network where it will be routed back to the requester. The first Node to deliver will have a chance of being rewarded with one Safe Network Token. This process is described as a Farming Attempt."}),Object(o.jsx)("p",{children:"A successful Farming Attempt will be rewarded by payment in Safe Network Token. However, the probability of this happening will depend on the farming_rate, which is a variable based on the quantity of free resources in the Network as well as the number of Safe Network Token in circulation. The Network will always try to maintain free space of at least 30 percent of its total capacity (to cover a disconnection or outage in certain parts of the Network). When the free space drops below 30 percent of the total capacity, the farming_rate will go up and more Farming Attempts will succeed. This way Farmers make more money providing chunks to the Network. It works the other way around as well. When there are too many Farmers providing storage space the farming_rate will go down. This happens automatically, and the effect is to create an incentive for farmers to provide storage when the overall spare capacity is low, and a disincentive when the amount of free space is high.\xa0"}),Object(o.jsxs)("div",{className:"What-does-that-mean",children:[Object(o.jsx)("h3",{children:"What does that mean?"}),Object(o.jsx)("p",{children:"Farming - a Node delivers a data chunk that it is storing to the Safe Network and earns Safe Network Token in return."}),Object(o.jsx)("p",{children:"Farming Attempt - by delivering data chunks when requested, a Node may gain the opportunity to make a Farming Attempt. "}),Object(o.jsx)("p",{children:"farming_rate - a variable used to attract or discourage Farmers in order to maintain a certain level of free space (about 30 percent of the total capacity)."}),Object(o.jsx)("p",{children:"MaidSafeCoin - a cryptocurrency token currently available for purchase that will be exchangeable for Safe Network Token once the network is live."}),Object(o.jsx)("p",{children:"Proof of Resource\xa0 - 1. a test of whether a Node that wants to join the network has sufficient bandwidth and CPU power. If it fails the test it will not be allowed to join. 2. Random checks are occasionally made by Elders to ensure that the Node is indeed maintaining chunks it is supposed to be storing. If it fails the challenge (by not providing the demanded proof) its Node Age is diminished."})]}),Object(o.jsx)("div",{className:"Full-width-pic",align:"center",children:Object(o.jsx)("img",{className:"Img1",src:g,alt:"POR",align:"center"})}),Object(o.jsx)("p",{children:Object(o.jsx)("em",{children:"Proof of Resource. Note: Safecoin is now called Safe Network Token."})}),Object(o.jsx)("p",{children:"The Network will balance itself in a way that's completely independent of the price of Safe Network Token. By adjusting the farming_rate according to the amount of free available space on the Network users storing data are charged at the optimum rate. While the storing rate is high (available free space is lower) users are discouraged from storing thus helping to free up more space. This dynamic pricing should translate into very competitive prices for data storage."}),Object(o.jsx)("p",{children:"Everyone with a suitable device and sufficient bandwidth is welcome to farm and thereby contribute to the network - including data centre owners. Nodes are continuously rewarded according to the quality of the resource they provide using Node Age and other features collectively known as Proof of Resource. To minimize the risk of centralization, however, the use of huge farming rigs will be economically disadvantageous compared with running multiple smaller nodes."}),Object(o.jsx)("div",{className:"Pullquote",children:'"There\'s more incentive for Farmers to provide storage when the overall spare capacity is low, and less incentive when the amount of free space is high"'}),Object(o.jsx)("p",{children:"While it cannot be guaranteed, the signs are that bandwidth and storage capacity will continue to increase rapidly for the next decade or two. This means that data will never\xa0have to be deleted, with all public information stored for the foreseeable future.\xa0\xa0"}),Object(o.jsx)("div",{className:"Full-width-pic",align:"center",children:Object(o.jsx)("img",{src:y,alt:"resources and currency",width:"70%",align:"center"})}),Object(o.jsx)("p",{children:"The supply of Safe Network Token will be limited to 4.3 billion coins, each with its own unique identity. Safe Network Tokens will be recycled when users exchange them for Network services, which means that there is always a supply for Farmers to earn."}),Object(o.jsx)("p",{children:"Note: At the time of writing the Safe Network is still pre-release (Alpha) and Safe Network Token is not yet implemented. However, a token called MaidSafeCoin (MAID) can be purchased on cryptocurrency exchanges. When the Network goes live MAID will be exchanged for Safe Network Token (SN) on a 1:1 basis."}),Object(o.jsx)("h3",{children:"Tell me more..."}),Object(o.jsxs)("p",{children:[Object(o.jsx)("a",{title:"Safecoin ",href:"https://safenetwork.tech/safecoin/",target:"_blank",rel:"noopener noreferrer",children:"This is Safecoin (Safe Network website)"})," \xa0\xa0"]}),Object(o.jsxs)("p",{children:[Object(o.jsx)("a",{title:"Safecoin Implementation",href:" https://github.com/maidsafe/rfcs/blob/master/text/0012-safecoin-implementation/0012-safecoin-implementation.md",target:"_blank",rel:"noopener noreferrer",children:"Safecoin Implementation (MaidSafe RFC)"})," \xa0"]}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"Farm Attempt ",href:"https://github.com/maidsafe/rfcs/blob/master/text/ ",target:"_blank",rel:"noopener noreferrer",children:"Farm Attempt (MaidSafe RFC)"})})]})},x=a.p+"static/media/supermajority.5eb8aa40.png",O=a.p+"static/media/ae1.e1bf78b5.png",v=a.p+"static/media/ae2.3bdc4cc8.png",N=a.p+"static/media/ae3.37d26212.png",S=a.p+"static/media/ae4.53952674.png",T=a.p+"static/media/ae5.a40a0e39.png",A=a.p+"static/media/ae6.c1291727.png",C=a.p+"static/media/ae7.d094d5cb.png",I=a.p+"static/media/ae8.ecc2b23d.png",E=a.p+"static/media/ae9.642819f2.png",D=a.p+"static/media/ae10.f6139819.png",R=a.p+"static/media/ae11.bac0af29.png",P=function(){return Object(o.jsxs)("div",{className:"chapter",children:[Object(o.jsx)("h2",{id:"ch9",children:"9. Safe Network Anti-entropy"}),Object(o.jsx)("p",{children:Object(o.jsx)("em",{children:"How the Safe Network ensures sections are stable before trying to write to them"})}),Object(o.jsx)("p",{children:"A major hurdle any decentralised network which will experience churn, such as Safe, must overcome is keeping the nodes up to date with the network\u2019s current state. Who has joined and who has left? Who are the current Elders in any given section?"}),Object(o.jsx)("p",{children:"Elders are by definition relatively dependable and churn amongst them is minimal, but Safe is asynchronous and communications between section Elders and external actors may be few and far between. The Elders in a section may have churned many times between contacts."}),Object(o.jsx)("p",{children:"It\u2019s vital actors wishing to make changes on the network have an up-to-date \u2018understanding\u2019 of the section before they are allowed to do so, otherwise data could be written to Elders that no longer exist."}),Object(o.jsx)("p",{children:"Entropy, or increasing disorder, is a characteristic of a constantly changing network. We cannot reduce it but we can wait for periods of zero change among Elders before allowing a change in their section. Anti-entropy is the mechanism for doing this."}),Object(o.jsx)("p",{children:"Even during periods of massive change such as a large global event, AE enables the network to inform actors attempting to mutate data that they must wait until the change is over before they can try again."}),Object(o.jsx)("p",{children:"On Safe, the AE mechanism is applied to all messages that can mutate the network, such as a PUT request. It requires the requesting actor - be that a Client, an Adult or another section - to prove that the information they hold on the affected section is current. Until then they cannot make a change.\xa0"}),Object(o.jsx)("p",{children:"AE reduces the synchronisation issue to a series of questions to which the answer is yes or no. If the answer is no (your information is not current), you need to update your records and try again. There is no halfway house."}),Object(o.jsx)("p",{children:"In this way AE forces all nodes that want to perform data operations on the network to prove they are up to date.\xa0"}),Object(o.jsx)("h3",{children:"Core concepts and mechanisms"}),Object(o.jsxs)("ul",{children:[Object(o.jsxs)("li",{children:[Object(o.jsx)("strong",{children:"Supermajority"})," \u2013 Any action affecting a section must be agreed by more than 2/3 of the Elders. For a section containing seven elders, two can disagree and the agreement will still go ahead. This allows BFT-type guarantees that provided 2/3 of nodes can be trusted, agreement will be reached in the event of conflict."]}),Object(o.jsxs)("li",{children:[Object(o.jsx)("strong",{children:"Distributed Key Generation (DKG)"})," \u2013 To generate a new ",Object(o.jsx)("a",{href:"https://primer.safenetwork.org/#ch7",children:"BLS"})," SectionKey, the participation of a supermajority of Elders is required."]}),Object(o.jsxs)("li",{children:[Object(o.jsx)("strong",{children:"New key per churn event"})," \u2013 every time an Elder is promoted or demoted, a new round of DKG takes place.\xa0"]}),Object(o.jsxs)("li",{children:[Object(o.jsx)("strong",{children:"Atomic functionality"})," - it works or it doesn't - in case of any conflict or disagreement the actor is requested to try again."]})]}),Object(o.jsx)("h3",{children:"SectionChain and ProofChain"}),Object(o.jsx)("p",{children:"A SectionChain is a cryptographically secure linked list of BLS SectionKeys, each signed by the previous key in the list going back all the way to Genesis. That way, if you trust Genesis (as you must) then you can trust the validity of the latest key."}),Object(o.jsx)("p",{children:"If an actor contacting the section holds an old key, the section Elders send the actor a ProofChain (plus the SAP, see below) to bring it up to date."}),Object(o.jsx)("p",{children:"A ProofChain is simply the most recent part of the SectionChain going back only as far as the last key held by the actor, plus one.\xa0"}),Object(o.jsx)("h3",{children:"SectionAuthorityProvider and SectionActor"}),Object(o.jsx)("p",{children:"As well as updating the requesting actor with the ProofChain, the Elders also send it the SectionAuthorityProvider (SAP), which gives up-to-date information about the section and its Elders."}),Object(o.jsx)("p",{children:"Each Elder is described by a vector containing its Ed25519 key for ID, a BLS key for agreement and its socket address:"}),Object(o.jsx)("p",{children:"The SAP is a vector containing all the Elder vectors, the SectionPrefix and the current SectionKey. It is signed by the previous (penultimate) SectionKey:"}),Object(o.jsx)("p",{children:"The SAP shows us exactly which Elders are in the section at the present time as well as the current SectionKey."}),Object(o.jsx)("p",{children:"The SAP together with the requirement for a supermajority for agreement allows section Elders to be treated as a single entity - a SectionActor - rather than as autonomous individuals: they act together or not at all.\xa0"}),Object(o.jsx)("h3",{children:"The three update scenarios"}),Object(o.jsx)("p",{children:"On messaging a section an actor includes what it understands to be that section\u2019s latest SectionKey."}),Object(o.jsxs)("ol",{type:"1",children:[Object(o.jsx)("li",{children:"If the SectionKey is correct and current the message is processed."}),Object(o.jsx)("li",{children:"If the key is out of date the section returns the message with a ProofChain and the SAP to authenticate the Elders. The actor updates its records and tries again."}),Object(o.jsx)("li",{children:"If the SectionKey is not recognised the message is\xa0ignored."})]}),Object(o.jsx)("h3",{children:"Voting and conflict resolution"}),Object(o.jsx)("p",{children:"If an Elder sees a change in section membership it broadcasts this to the other Elders in the section and they vote on whether and how the section state has changed by creating a message containing the proposal and signing it with their BLS shared secret key. Every time the state changes a new round of BLS-DKG is required and a new SectionKey is created.\xa0"}),Object(o.jsx)("p",{children:"However, due to differences in connection speed and other factors, not all Elders see the same state at the same time."}),Object(o.jsx)("p",{children:"In the case of a conflict, agreement must be reached before the section\u2019s state is communicated to the outside world, because we can only ever have one version of the truth.\xa0"}),Object(o.jsx)("img",{className:"Img",src:x,alt:"supermajority",width:"70%",align:"center"}),Object(o.jsx)("p",{children:"This is where the supermajority comes into play. A supermajority (e.g. 5 out of 7 nodes) is required to generate a new section key, and it is also (non-coincidentally) how Elders arrive at an agreement.\xa0"}),Object(o.jsx)("p",{children:"If five Elders see a node leave (and generate a new key A) and five see another node join (and generate a new key B) there must be a minimum of three Elders that see both versions. Under BFT at least one of these Elders must be honest. Therefore, both keys A and B are rejected and a new round of DKG takes place."}),Object(o.jsx)("p",{children:"While this is happening any requests for data mutation from outside actors will be rejected. This prevents a client manipulating different Elders within a section by forking the decision-making process."}),Object(o.jsx)("h3",{children:"How AE works \u2013 an example"}),Object(o.jsx)("p",{children:"Let\u2019s consider the example of a Client requesting a section to PUT a chunk of data, and assume that the Client has not contacted our section before. Incidentally, AE works in the same way for communications between Adults and Elders and between sections too."}),Object(o.jsx)("p",{children:"1. The starting situation"}),Object(o.jsx)("img",{className:"Img",src:O,alt:"ae1",width:"70%",align:"center"}),Object(o.jsx)("p",{children:Object(o.jsx)("strong",{children:"\xa0"})}),Object(o.jsxs)("ul",{children:[Object(o.jsx)("li",{children:"Each Adult is in constant contact with all the section Elders, but not with other Adults.\xa0"}),Object(o.jsx)("li",{children:"Each Elder is in constant contact with all other Elders in the section (connections not shown) and with all Adults."}),Object(o.jsx)("li",{children:"Elders churn rarely, Adults churn frequently."}),Object(o.jsx)("li",{children:"Every time the Elders churn a new BLS SectionKey is generated."}),Object(o.jsx)("li",{children:"The SAP is what\xa0defines the current section."}),Object(o.jsx)("li",{children:"A section is also defined by its unique XOR address prefix, eg 0011."}),Object(o.jsx)("li",{children:"Each Elder\xa0holds a Ed25519 key, a BLS key, SectionChains from its own and other sections & a socket address."}),Object(o.jsx)("li",{children:"Each Adult holds a Ed25519 key, a SectionChain & a socket address."})]}),Object(o.jsx)("p",{children:"2. Client broadcasts a request to all Elders simultaneously"}),Object(o.jsx)("img",{className:"Img",src:v,alt:"ae2",width:"70%",align:"center"}),Object(o.jsx)("p",{children:"3. SectionActor sends SectionChain and SAP"}),Object(o.jsx)("img",{className:"Img",src:N,alt:"ae3",width:"70%",align:"center"}),Object(o.jsx)("p",{children:"4. But before the Client can resend the message a churn event has occurred with Elder G leaving"}),Object(o.jsx)("img",{className:"Img",src:S,alt:"ae4",width:"70%",align:"center"}),Object(o.jsx)("p",{children:"5. The Elders vote on the change"}),Object(o.jsx)("img",{className:"Img",src:T,alt:"ae5",width:"70%",align:"center"}),Object(o.jsx)("p",{children:"If an Elder sees a change it messages the other Elders to tell them. The Elders vote on whether a churn event has occurred. In this example, most see that G has gone, one (perhaps geographically further away) can still see G. A supermajority votes that G has gone and a new SectionKey, K6, is generated. If the vote had been split without a supermajority it would simply have been rerun.\xa0"}),Object(o.jsx)("p",{children:"While the churn is occurring the Client\u2019s message is rejected, but as part of AE it will retry continually.\xa0"}),Object(o.jsx)("p",{children:"6. Unaware of the churn, the Client tries again attaching its latest key, K5, to the message"}),Object(o.jsx)("img",{className:"Img",src:A,alt:"ae6",width:"70%",align:"center"}),Object(o.jsx)("p",{children:"7. Key out of date, try again"}),Object(o.jsx)("img",{className:"Img",src:C,alt:"ae7",width:"70%",align:"center"}),Object(o.jsx)("p",{children:"8. But before it can try again there\u2019s more churn: Elder H arrives"}),Object(o.jsx)("img",{className:"Img",src:I,alt:"ae8",width:"70%",align:"center"}),Object(o.jsx)("p",{children:"9. The client tries once more but again it is out of date"}),Object(o.jsx)("img",{className:"Img",src:E,alt:"ae9",width:"70%",align:"center"}),Object(o.jsx)("p",{children:"10. Once again it is sent the updated ProofChain and SAP and told to try again"}),Object(o.jsx)("img",{className:"Img",src:D,alt:"ae10",width:"70%",align:"center"}),Object(o.jsx)("p",{children:"11. Success \u2013 the churn is over and authority is given"}),Object(o.jsx)("img",{className:"Img",src:R,alt:"ae11",width:"70%",align:"center"}),Object(o.jsxs)("p",{children:["The Client tries again and this time the keys match so everyone is in sync and the operation to store chunk ",Object(o.jsx)("em",{children:"A"})," can proceed."]}),Object(o.jsx)("h3",{children:"Golden rules"}),Object(o.jsx)("p",{children:"A node is not an Adult or Elder unless it has the current SectionKey. The SectionKey is really important \u2013 we don\u2019t want to speak to a Section in its old state."}),Object(o.jsx)("p",{children:"A node is only an Elder when it has the current SectionKey and is included in the SAP."}),Object(o.jsx)("p",{children:"As part of AE a requesting actor will retry continually."}),Object(o.jsx)("h3",{children:"Edge cases"}),Object(o.jsx)("p",{children:"The assumption is that Elders churn rarely (that\u2019s why they are Elders) so the above scenario should be rare. Nevertheless, it will happen and AE needs to be able to handle the various combinations of Elders leaving and joining, even if this takes multiple rounds of DKG.\xa0"}),Object(o.jsx)("p",{children:"Some potentially difficult scenarios are taken care of by other mechanisms. For example, if an Elder leaves and tries to rejoin again it will find itself relocated to another section with its node age halved."}),Object(o.jsx)("p",{children:"If more than three nodes leave at once we move to another algorithm Lost Majority Recovery/Lost Consensus Recovery."}),Object(o.jsx)("h3",{children:"Conclusion"}),Object(o.jsx)("p",{children:"Anti-Entropy is a way to ensure that before data is changed on the network the section in question is not in a state of churn and the actor requesting the change knows the current identities of the Elders in the section."}),Object(o.jsx)("p",{children:"It is an efficient way to keep the network updated on a need-to-know basis with a minimum of messaging."}),Object(o.jsx)("p",{children:"Importantly, a section cannot mutate data when it is between states. Only once churn has completed with the agreement of a supermajority of the Elders in the section will requests for data mutation be accepted. Until then the actor must keep trying."}),Object(o.jsx)("h3",{children:"\xa0Tell me more..."}),Object(o.jsxs)("p",{children:["Crux of entropy check: ",Object(o.jsx)("a",{href:"https://github.com/maidsafe/sn_routing/blob/master/src/routing/core/anti_entropy.rs#L21-#L62",target:"_blank",children:"Anti-Entropy (GitHub)"})]}),Object(o.jsxs)("p",{children:[" ",Object(o.jsx)("a",{href:"https://github.com/maidsafe/sn_messaging/blob/master/src/serialisation/wire_msg_header.rs#L25-#L36",target:"_blank",children:"Header in which destination SectionKeys are carried over"})]})]})},B=a.p+"static/media/data_types.2ffbb00d.png",q=function(){return Object(o.jsxs)("div",{className:"chapter",children:[Object(o.jsx)("h2",{id:"ch10",children:"10. Data types"}),Object(o.jsx)("p",{children:"The Safe Network provides three main data types for storing and retrieving data: Map, Sequence and Blob. Map and Sequence are both mutable data types, meaning their content can be changed, whereas Blobs are immutable. Map and Sequence types are being constituted as CRDTs, meaning that operations on mutable data will be guaranteed to be replicated to all copies of that data, wherever they are held (see Chapter 7)."}),Object(o.jsx)("p",{children:"There are some sub-categories too. On the Safe Network data can be either 'Public' or 'Private'. Private data can only be accessed by its owner, or others that he or she chooses to share it with, and it can also be deleted. Public data is available to anyone, just as a normal website is today, but it cannot be deleted. This is because the Perpetual Web is a fundamental concept of the Safe Network and public data cannot be erased. "}),Object(o.jsx)("p",{}),Object(o.jsx)("h3",{children:"Map"}),Object(o.jsx)("p",{children:"A Map is composed of entries. An entry is a key-value pair (e.g. key 123: value apple) and a Map is effectively a kind of key-value store. The value attached to a particular key can be changed, for example, you might decide you prefer bananas to apples, but apple and any other values previously associated with that key will be kept as a historical record. Only in the case of a PrivateMap can that information, or indeed the whole file, be permanently deleted. "}),Object(o.jsx)("p",{children:"Entries in a Map can be inserted, updated and deleted. In a PrivateMap they can be hard-updated (replacing the current entry rather than appending a new current entry on top of it) or hard-deleted (erasing the entry completely) too, and the entire Map can also be deleted from the Network. Entries in a PublicMap cannot be hard-deleted or hard-updated as that would involve removing data."}),Object(o.jsx)("p",{children:"Every time an operation is performed on a Map, its version number increases by 1."}),Object(o.jsx)("p",{children:"A Map would be an ideal choice for storing and rapid access of data related to a unique ID, such as account information."}),Object(o.jsx)("h3",{children:"Sequence"}),Object(o.jsx)("p",{children:"A Sequence is an append-only data type in which the data is not associated with keys. Changes to the data will result in a new version - but you can\u2019t edit or delete the existing versions. (In the case of a PrivateSequence, the whole Sequence can be deleted, but not individual versions contained within it)."}),Object(o.jsx)("p",{children:"A Sequence-based document can be updated or corrected an unlimited number of times, but the original version(s) will always be accessible. This is similar to the Internet Archive's Wayback Machine which records websites at regular intervals so you can dial back to see content from the past, even though the site owners may have deleted it long ago. All public Safe sites will have this capability automatically."}),Object(o.jsx)("h3",{children:"Blob"}),Object(o.jsx)("p",{children:"A Blob is an immutable data structure. Its Network address is derived from the hash of its content. This means the file cannot be edited in any way after it has been uploaded - any change would alter the hash and therefore its address meaning it could not be found. A single Blob is limited to 1 MB, but by using a Data Map to keep track of their locations files larger than 3 Kb can be split into chunks with those chunks stored as separate Blobs (see Chapter 6)."}),Object(o.jsx)("p",{children:"Data deduplication is a unique feature of the Safe Network and a side benefit of the process of Self-Encryption (see Chapter 6). Two identical Blobs will have the same hash value, and therefore only one (plus a few copies for redundancy) need be stored on the Network."}),Object(o.jsx)("p",{children:"Blobs can be Public or Private. A PrivateBlob can only be shared with other parties if they are factored in at the time it is created. This is because the Blob's Network address is a hash of its content plus the IDs of accounts that can access it. Adding a new account would thus change its address and is therefore not possible."}),Object(o.jsx)("p",{children:"Blobs can be cached by Clients, and fetching the same chunk next time can be quicker. Safe also has a planned feature called Opportunistic Caching in which more copies of popular data are created closer to where it is being requested, so popular websites and other data feeds will actually speed up as they get more visitors, rather than slowing down as they do on today's Web."}),Object(o.jsx)("p",{children:"Use cases for Blobs include images, videos and documents that must not be altered."}),Object(o.jsx)("div",{className:"Full-width-pic",align:"center",children:Object(o.jsx)("img",{src:B,alt:"Data types",width:"90%",align:"center"})}),Object(o.jsx)("p",{children:Object(o.jsx)("em",{children:"Source: MaidSafe"})}),Object(o.jsx)("h3",{children:"Public or Private?"}),Object(o.jsx)("p",{children:"All data types can be either Public (available to everyone) or Private (available only to the owner and approved third parties), analogous to the distinction between the public feed and private messaging on social media sites. Data is encrypted by default, including in transit. "}),Object(o.jsxs)("div",{className:"What-does-that-mean",children:[Object(o.jsx)("h3",{children:"What does that mean?"}),Object(o.jsx)("p",{children:"Data type - a classification which describes how data can be created, transformed and used. "}),Object(o.jsx)("p",{children:"Data Map  - a record of file chunks and their corresponding locations on the Network. Only those in possession of the Data Map can recreate the file.  "}),Object(o.jsx)("p",{children:"Concurrency control - managing the situation where multiple users may make changes to the same data at the same time. "}),Object(o.jsx)("p",{children:"CRDTs \u2013 Data structures that obey certain mathematical rules which ensure that when multiple versions of data exist across a distributed network, eventually these will always converge onto one 'true' version."}),Object(o.jsx)("p",{children:"XOR address - a unique 256-bit number. Every entity on the Network has an XOR address. "}),Object(o.jsx)("p",{children:"XOR URL - a base-32 encoded translation of the XOR address together with other information such as data type as required by applications. "}),Object(o.jsx)("p",{children:"Network File Storage (NFS) - an API that allows a Client to access files stored on the Safe Network."}),Object(o.jsx)("p",{children:"Name Resolution System (NRS) - analogous to the Domain Name System (DNS) on the Internet, this is a system that translates an XOR address to a human-readable web address."}),Object(o.jsx)("p",{children:"Public ID - chosen name for an account (e.g. alice or maidsafe). An account may register any number of Public IDs so long as they have not been registered previously."}),Object(o.jsx)("p",{children:"Service name - the name of a service such as a website, email or chat app. So if Alice's website was called mysite the URL would be mysite.alice."}),Object(o.jsx)("p",{children:"Type tag - allows apps to identify the type of data, e.g. 15001 Public ID; 15002 Service Name; 15003 Email ID; 15004 Email Archive."}),Object(o.jsx)("p",{children:"Opportunistic Caching - automatic creation of more copies of popular data close to where it is being requested, so popular websites and other data feeds will actually speed up as they get more visitors, rather than slow down as they do on today's web."})]}),Object(o.jsx)("h3",{children:"Concurrency control"}),Object(o.jsx)("p",{children:"Map and Sequence types offer the ability to control how changes are made to a file when multiple people or processes might be writing to it at the same time (concurrency). Since each change results in a new version, concurrency can lead to unpredictable results. For these use cases an optional concurrency check may be selected to ensure that only the expected version can be updated."}),Object(o.jsx)("h3",{children:"Network File Storage"}),Object(o.jsx)("p",{children:"Data is saved using a combination of Map and Blob to create an emulated file system on top of the Network called NFS (Network File Storage). NFS saves a file's content as a Blob. It then creates an entry in a FilesContainer, a Map entity, with the file name as the entry's key and the Blob's address as the entry's value. The file can be updated by uploading a new Blob and then altering the file's address in the FilesContainer structure to point to the new instance. "}),Object(o.jsx)("p",{children:"At time of writing, investigations into the use of a CDRT-tree data type as the basis for a locally mountable filesystem were ongoing, and there are community efforts under way to create a locally mountable filesystem based on FUSE (filesystem in userspace)."}),Object(o.jsx)("p",{children:"Websites on the Safe Network can be identified using URLs thus: safe://service_name.public_id (e.g. safe://mysite.alice). Working similarly to the familiar Internet Domain Name System (DNS), these human-readable addresses are translated into Network addresses on Safe using the Name Resolution System (NRS)."}),Object(o.jsx)("p",{children:"As well as the human-readable Safe URL provided by NRS, files stored on the Network can also be accessed via their XOR-URL (e.g. safe://a078516207e36aa2371e17750c93276446bdb4867c027035531b89430aa8d3ae2fa4dbb59). This URL is a base-32 encoding of the file\u2019s XOR address and (optionally) its MIME type allowing data to be stored and retrieved by applications without reference to the storer\u2019s account (see Chapter 11)."}),Object(o.jsx)("p",{children:"\xa0"}),Object(o.jsx)("h3",{children:"Tell me more..."}),Object(o.jsx)("p",{children:"\xa0"}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"data types",href:"https://safenetforum.org/t/an-overview-of-data-types-on-the-safe-network/29845",target:"_blank",rel:"noopener noreferrer",children:"Data Types Refinement (MaidSafe RFC and forum discussion)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"data types a",href:"https://github.com/maidsafe/rfcs/blob/d42c24db6ddfe58f14b347a5664710e493262ce9/text/0052-RDF-for-public-name-resolution/0052-RDF-for-public-name-resolution.md",target:"_blank",rel:"noopener noreferrer",children:"Data Hierarchy Refinement (MaidSafe RFC and forum discussion)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"md",href:"https://github.com/maidsafe/rfcs/blob/d42c24db6ddfe58f14b347a5664710e493262ce9/text/0052-RDF-for-public-name-resolution/0052-RDF-for-public-name-resolution.md",target:"_blank",rel:"noopener noreferrer",children:"RDF for the Public Name Resolution System (MaidSafe RFC)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"aod",href:"https://github.com/maidsafe/safe-nd",target:"_blank",rel:"noopener noreferrer",children:"Safe Network Data Types (Github)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"polyfuse",href:"https://github.com/ubnt-intrepid/polyfuse",target:"_blank",rel:"noopener noreferrer",children:"Polyfuse - A FUSE (Filesystem in Userspace) library for Rust.  (Github)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"tree",href:"https://forum.safedev.org/t/filetree-crdt-for-safe-network/2833",target:"_blank",rel:"noopener noreferrer",children:"FileTree CRDT for Safe Network  (MaidSafe forum discussion)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"cache",href:"https://maidsafe.net/features.htm",target:"_blank",rel:"noopener noreferrer",children:"Distributed network with opportunistic data caching (MaidSafe)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"wayback",href:"https://web.archive.org/",target:"_blank",rel:"noopener noreferrer",children:"Internet Archive Wayback Machine"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"safe_app",href:"https://docs.maidsafe.net/safe_app_nodejs/#nfs",target:"_blank",rel:"noopener noreferrer",children:"Maidsafe NFS API documentation"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"xorurls",href:"https://github.com/maidsafe/rfcs/blob/357384147ae005e4061079b27a30f43cf379fda5/text/0000-xor-urls/0000-xor-urls.md",target:"_blank",rel:"noopener noreferrer",children:"XOR-URLs (MaidSafe RFC)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"base 32",href:"https://philzimmermann.com/docs/human-oriented-base-32-encoding.txt",target:"_blank",rel:"noopener noreferrer",children:"Human-oriented base-32 encoding (O'Whielacronx)"})})]})},F=a.p+"static/media/xor_url.61b2c483.PNG",M=a.p+"static/media/api_flow_revised.2ee68044.PNG",_=function(){return Object(o.jsxs)("div",{className:"chapter",children:[Object(o.jsx)("h2",{id:"ch11",children:"11. The Safe API"}),Object(o.jsx)("p",{children:"The Safe API is used by developers to interact directly with the Safe Network. It is available to use in JavaScript, Node.js, Java and C#. Apps connecting to the Safe Network are granted different levels of access to data through the API depending on whether they are authorized or not. Apps that are not authorized can only access public data, such as websites. Authorized Apps can access the full range of network functionality."}),Object(o.jsx)("div",{className:"Full-width-pic",align:"center",children:Object(o.jsx)("img",{className:"Img1",src:M,alt:"API-Flow",align:"center"})}),Object(o.jsx)("p",{children:"Currently the Safe Network has default containers in which certain types of files are stored. For example, _documents is used to store document-related data; _downloads is the container for downloaded content; _music is the place to store music files, and so on."}),Object(o.jsx)("p",{children:"There are plans to move away from this system to one of Data Labels, a flatter more  flexible structure which should help reduce the issue of data getting siloed in certain applications. Under this scheme a single piece of data can have multiple labels, some applied by default (e.g. Photo) others user-created (Spain, 2019...) or selected from existing ontologies used in the Semantic Web. Each label has its own index so data can easily be processed by apps, and permissions to access and process data can be managed on a per-label basis. The thinking behind this concept is to improve the user experience (UX) around granting permissions, and to make the architecture more exensible."}),Object(o.jsx)("p",{children:"Application development for the Safe Network is not that different from any other platform. There are safe_app libraries based on the platform the application is being built on. Node.js, Javascript, Java and C# are best supported at present. Web applications can be built using the DOM API of the Safe Browser and there are libraries for Android and iOS."}),Object(o.jsx)("h3",{children:"Authorization"}),Object(o.jsx)("p",{children:"Applications need to be authorized before they can access data on the Network. In a similar way to the familiar OAuth process, the application sends a request using the library for authorization. When the authorization is approved by the user, the application receives a token which is used to connect to the Safe Network. Authorization is achieved via an application call to the Authenticator."}),Object(o.jsx)("p",{children:"Authorization is fine grained. An application can create its own container and request access to default containers or other applications\u2019 containers through the authorization request. READ, WRITE, UPDATE, DELETE, MANAGE permissions can be requested for every container. The API features many methods for allowing apps to interact with and deploy Map, Sequence and Blob data types (see Chapter 10) and to write and retrieve data from the network."}),Object(o.jsx)("h3",{children:"CipherOpt and Crypto APIs"}),Object(o.jsx)("p",{children:"The safe_app library also provides crypto API functions. The safeCipherOpt API provides functions to create different encryption options to be applied while storing the data in the network. Sign key handling APIs were a work in progress at the time of writing."}),Object(o.jsx)("p",{children:"There are three types of CipherOpts:"}),Object(o.jsxs)("ul",{children:[Object(o.jsx)("li",{children:"Plain - Data will not be encrypted."}),Object(o.jsx)("li",{children:"Symmetric - Data is encrypted with a symmetric key."}),Object(o.jsx)("li",{children:"Asymmetric - Data is encrypted using a key pair."})]}),Object(o.jsx)("p",{children:"The safeCrypto API provides handy cryptographic functions, including hashing and generating key pairs."}),Object(o.jsx)("h3",{children:"DOM API"}),Object(o.jsx)("p",{children:"A web application can communicate with the Safe Network and Authenticator by interacting directly with the Safe Browser\u2019s DOM API, i.e. window.safe* functions."}),Object(o.jsx)("p",{children:"This API is very similar to the Node.js API, the main difference being that the web application receives handles for each of the objects that are instantiated when interacting with the API, e.g. SAFEApp and MutableData instances. The web app is required to release the handles provided by calling a specific \u2018free\u2019 function on each of the tokens received."}),Object(o.jsx)("h3",{children:"Support for XOR-URLs"}),Object(o.jsx)("p",{children:"The DOM API also allows applications to link or reference any MutableData/ImmutableData on the Network using its XOR-URL. This is a URL based on the file\u2019s XOR location on the Network which also contains information about the file\u2019s MIME-type so the Safe Browser can fetch a file (say an image) and render it as usual."}),Object(o.jsx)("p",{children:"As shown in the screenshot below, the Safe Browser can decode the XOR-URL to extract the location of the content, content type (if the MIME type is also encoded in the XOR-URL), fetch it, and render it accordingly as it does it with any publicName-URL (i.e. the URLs which make use of the Safe DNS system):"}),Object(o.jsx)("div",{className:"Full-width-pic",align:"center",children:Object(o.jsx)("img",{src:F,alt:"XOR-URL",width:"100%",align:"center"})}),Object(o.jsx)("p",{children:Object(o.jsx)("em",{children:"Fetching a page using its XOR-URL"})}),Object(o.jsx)("h3",{children:"WebIDs, RDF and SOLID"}),Object(o.jsx)("p",{children:"The Safe DOM API safe_app_nodejs supports WebIDs. These allow users to identify themselves to applications and pass information (for example the location of an inbox) using just a URL. A user may create multiple IDs for different purposes."}),Object(o.jsx)("p",{children:"There is also support for the semantic web\u2019s data exchange model Resource Description Framework (RDF) and WebIDs are stored as RDF documents. Supporting RDF makes Safe compatible with Tim Berners-Lee\u2019s SOLID project which allows users to store their own personal data in \u2018pods\u2019 independently of the applications that use it. Many apps developed for SOLID should be easily ported to SAFE, and vice versa, and there is potential for the Safe Network to operate as a highly secure platform for pods."}),Object(o.jsx)("h3",{children:"Tell me more..."}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"labels ",href:"https://safenetforum.org/t/rfc-labelled-data-indexing-and-token-authorisation/30597 ",target:"_blank",rel:"noopener noreferrer",children:"Labelled Data, Indexing and Token Authorisation (MaidSafe RFC)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"tokens",href:"https://safenetforum.org/t/rfc-tokens-updated-and-extracted-from-labels/31096",target:"_blank",rel:"noopener noreferrer",children:"Tokens (updated and extracted from labels) (MaidSafe RFC)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"safe_app_nodejs ",href:"http://docs.maidsafe.net/safe_app_nodejs ",target:"_blank",rel:"noopener noreferrer",children:"Safe Network Node.js API"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"cryptointerface",href:"https://docs.maidsafe.net/safe_app_nodejs/cryptointerface",target:"_blank",rel:"noopener noreferrer",children:"Crypto API"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"cipheroptinterface",href:"https://docs.maidsafe.net/safe_app_nodejs/cipheroptinterface",target:"_blank",rel:"noopener noreferrer",children:"CipherOpt API"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"Auth flow",href:"https://github.com/maidsafe/rfcs/blob/master/text/0046-new-auth-flow/0046-new-auth-flow.md",target:"_blank",rel:"noopener noreferrer",children:"New Auth Flow (MaidSafe RFC)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"async-safe-core",href:"https://github.com/maidsafe/rfcs/blob/master/text/0043-async-safe-core/0043-async-safe-core.md",target:"_blank",rel:"noopener noreferrer",children:"Async safe_core (MaidSafe RFC)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"Safe Authenticator Mobile",href:"https://github.com/maidsafe/safe-authenticator-mobile",target:"_blank",rel:"noopener noreferrer",children:"Safe Authenticator Mobile (Github)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"webids",href:"https://medium.com/safenetwork/an-overview-of-webids-and-rdf-data-use-on-safe-a1fa4a319bd5",target:"_blank",rel:"noopener noreferrer",children:"An overview of WebIds and RDF data use on Safe (Josh Wilson)."})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"rdf",href:"https://www.w3.org/RDF/",target:"_blank",rel:"noopener noreferrer",children:"Resource Description Framework (RDF) \u2013 (W3 documentation)"})}),Object(o.jsx)("p",{children:Object(o.jsx)("a",{title:"Playing it Safe with RDF",href:"https://forum.safedev.org/t/playing-it-safe-with-rdf/1889",target:"_blank",rel:"noopener noreferrer",children:"Playing it Safe with RDF"})})]})},W=function(){return Object(o.jsxs)("div",{className:"chapter",children:[Object(o.jsx)("h2",{id:"ch12",children:"12. How Safe Network defends against common types of cyberattack"}),Object(o.jsx)("p",{children:"Safe Network has an interlocking set of features, each covering the others\u2019 vulnerabilities. This means that data security on Safe is maximized. While 100 percent security is impossible, this strength-in-depth means that the sort of attacks common on the current web will be much harder to carry out on SAFE."}),Object(o.jsx)("h3",{children:Object(o.jsx)("strong",{children:"Features"})}),Object(o.jsxs)("p",{children:[Object(o.jsx)("em",{children:"Random address allocation"}),Object(o.jsx)("strong",{children:" \u2013 "}),"a new node (Node) joining the Network cannot set its own address and thus cannot decide which Section it joins or which data it will be looking after. This prevents an attacker from being able to target a particular Section to add bad nodes. On a random distribution, the attacker would need to control approximately a third of all nodes to launch such an attack (see Chapter 4)."]}),Object(o.jsxs)("p",{children:[Object(o.jsx)("em",{children:"Nodes are added only as needed -"})," Each Group only accepts a Node if needed, meaning an attacker might have to wait a very long time to get his or her Node accepted. Even after that, a new Node will be moved between Sections before it can become an Elder (see Chapter 5)."]}),Object(o.jsxs)("p",{children:[Object(o.jsx)("em",{children:"Node ageing"})," - only nodes that have proved their worth over time (Elders) are allowed to vote on the validity of events in a Section. Nodes that do not pull their weight or act as they should will be expelled and/or their Node Age reset to a lower value (see Chapter 5)."]}),Object(o.jsxs)("p",{children:[Object(o.jsx)("em",{children:"Churn"})," - Nodes are constantly joining or leaving Sections. Membership is fluid."]}),Object(o.jsxs)("p",{children:[Object(o.jsx)("em",{children:"Encryption"})," - All data on the Safe Network is protected by several layers of encryption. Even public data is encrypted (in this case the keys are shared to allow others to decrypt it \u2013 see Chapter 6)."]}),Object(o.jsxs)("p",{children:[Object(o.jsx)("em",{children:"Self-Encryption"})," - files stored on the Network are broken into chunks with each chunk encrypted using its own hash and the hashes of the two previous chunks. These chunks are stored at geographically random locations (the XOR location being the hash of the encrypted chunk) with a number of copies retained for redundancy. Without a Data Map, the chunks cannot be retrieved and decrypted. (Chapter 6)."]}),Object(o.jsxs)("p",{children:[Object(o.jsx)("em",{children:"XOR Networking"})," - Randomizes the geographical distribution of the chunks. Only someone in possession of the Data Map (i.e. the data owner) can find the chunks and piece them together again to recreate the file. An attacker trying to fake a chunk could not do so as its hash - and therefore its address on the Network - would be different. It could not be used to create a corrupted version of the file (see Chapter 5)."]}),Object(o.jsxs)("p",{children:[Object(o.jsx)("em",{children:"Self-Authentication"})," - A user can create an account and log into the decentralized Safe Network securely and anonymously without requiring any central server to mediate the login process or any trusted third party to store and manage users\u2019 credentials (see Chapter 3)."]}),Object(o.jsxs)("p",{children:[Object(o.jsx)("em",{children:"Anonymization"})," - To retain anonymity, the identity of a Client connecting to the Network must be obfuscated from the nodes that comprise it. For this reason connections between Clients and Nodes in the Safe Network always occur via a Node the IP of which is in the config file. Any Node can perform this role and rather than accepting the config file the user may prefer to connect via a known node of his or her choosing. Thereafter, the initial Node drops the connection and cannot track the Client's activity (see Chapter 4)."]}),Object(o.jsxs)("p",{children:[Object(o.jsx)("em",{children:"Disjoint Sections"})," - Addresses on the Safe Network are grouped into Sections with each Section looked after by a Group of nodes. Those nodes know everything about the Section for which they are responsible but very little about the rest of the Network. Moreover, the membership of a Section is constantly changing and they will frequently split. So even if an attacker could control a Section his potential for damage would be limited (see Chapter 5)."]}),Object(o.jsxs)("p",{children:[Object(o.jsx)("em",{children:"BLS-DKG"})," - BLS cryptography (see Chapter 7) allows secure authentication of Sections and multi-signature transactions. "]}),Object(o.jsxs)("p",{children:[Object(o.jsx)("em",{children:"Malice Detection"})," - The BLS signature scheme allows for the detection of invalid messages. If these reach a certain threshold the node will be demoted. If a node signs a message that is malicious the signature is forwarded to other Elders who can vote to kill the node (see Chapter 7)."]}),Object(o.jsx)("h3",{children:Object(o.jsx)("strong",{children:"Defence against common attacks"})}),Object(o.jsxs)("p",{children:[Object(o.jsx)("em",{children:"Sybil attack"})," - In a Sybil attack, the attacker subverts the reputation system of a peer-to-peer network by creating a large number of pseudonymous identities, using them to gain a disproportionately large influence."]}),Object(o.jsx)("p",{children:"An attacker owning a large number of nodes (Nodes) could potentially control individual Sections and block actions happening to data in those Sections (GET, PUT, transfer Safe Network Token). However, they would need to control more than a third of the Elders, and remember they cannot choose the Sections they join. Even then, the attacker would only have influence over the fraction of data controlled by the Group it is in (not the whole Network). Also, disrupting an individual\u2019s data would be impossible \u2013 the attacker cannot know where it is stored."}),Object(o.jsx)("p",{children:"Someone with enough Nodes could of course bring the Network down (for example by suddenly turning off all their Nodes). But this gets harder very quickly as the Network grows larger. A combination of Node Ageing, churn, rules on joining and the splitting of Sections would make this massively more difficult (and very expensive) on a large network."}),Object(o.jsx)("p",{children:"In addition, there are Malice Detection tests to identify misbehaving nodes."}),Object(o.jsxs)("p",{children:[Object(o.jsx)("em",{children:"Phishing, keylogging etc"})," - these attacks are feasible as the Network cannot protect endpoints. But such an attack would only compromise the user\u2019s own data (and that others have allowed the user to see). Using such a compromise as a springboard for a wider attack on a database or whatever would not be possible. This would be of dubious value to an attacker."]}),Object(o.jsxs)("p",{children:[Object(o.jsx)("em",{children:"Man in "}),Object(o.jsx)("em",{children:"the Middle attacks"})," - MitM attacks rely on data being unencrypted or the victim\u2019s browser accepting the attacker's certificate instead of the website\u2019s certificate. They will not work on SAFE."]}),Object(o.jsxs)("p",{children:[Object(o.jsx)("em",{children:"DDoS"})," - exceptionally difficult as there is no single point to attack. The Network will simply reroute around any nodes that are taken down."]}),Object(o.jsxs)("p",{children:[Object(o.jsx)("em",{children:"Quantum computing"})," - The encryption used on Safe is \u2018quantum resistant\u2019 (but not \u2018quantum proof\u2019). But the volume of encrypted packets means that there could only be targeted attempt at decryption, and decentralization makes such targeting difficult."]}),Object(o.jsxs)("p",{children:[Object(o.jsx)("em",{children:"Ransomware"})," \u2013Files are stored in immutable data and cannot be changed, so ransomware could not encrypt it, but it could potentially delete Data Maps or hide them, making data inaccessible."]})]})},z=function(){return Object(o.jsxs)("div",{children:[Object(o.jsx)("h2",{id:"ch13",children:"13. The promise of the Safe Network"}),Object(o.jsx)("p",{children:"The Safe Network is still in development. While many features and functionalities have already proven themselves under test conditions others, including Safe Network Token, are still to come.\xa0 As with any cutting-edge experimental technology, the proof of the pudding is in the eating. But let\u2019s assume for a moment that the Network is successful and is widely adopted for various use cases including Internet browsing, IoT connectivity, data security, personal information management, medical records and more."}),Object(o.jsx)("p",{children:"What would that world look like? First, most cyber attack strategies deployed today would be dead in the water. DDoS would not work as the Network would simply route around the affected nodes. Viruses and malware would be extremely limited in their depth of penetration. Ransomware would not raise a single dollar. Cyber attacks aimed at disabling national infrastructure or taking control of a driverless car would be extremely hard to pull off. Medical records and other personal data would be ours and ours alone, to share as we see fit. For users there can be a single sign-on to multiple services. XOR networking with opportunistic caching promises faster speeds, data storage should be extremely cheap and the Network will offer high levels of availability. For developers having a single storage architecture to address has the potential to simplify the systems programmer\u2019s job. And data deduplication would allow for both simplicity and resource savings."}),Object(o.jsx)("div",{className:"Pullquote",children:'"There would be a rebalancing of power from the data-haves to the data have-nots"'}),Object(o.jsx)("p",{children:"The Internet giants of today would no longer be able to harvest our data without our say so, nor could government spooks eavesdrop over their shoulders. There would be a rebalancing of power from the data-haves to the data have-nots. Censorship would be impossible and data could not be erased. Because the cost of entry will be low and access unrestricted, the ongoing net neutrality debate will end, and neutrality will have won the day."}),Object(o.jsx)("p",{children:"People in places with poor or restricted access to information will have those blockers lifted. Some may even make a decent living earning Safe Network Token. New business models based on consent would spring up in a world where data storage and networking and eventually compute is a commodity, and the world of information will be a much more level playing field."}),Object(o.jsx)("p",{children:"Isn\u2019t this all a bit idealistic? Well yes of course, but that\u2019s the nature of visions. Not everything will work as planned and we need to be hard-headed about that. Techno-utopianism is a dangerous thing. There are both predictable and unpredictable consequences of taking on the status quo, and indeed of deploying any new technology, and not all of them will be positive. Nevertheless, given where we are today, and where we are headed with the IoT, something like the Safe Network is most definitely needed to redress the power imbalance and to secure the data-driven future."}),Object(o.jsx)("h3",{children:"Roadmap"}),Object(o.jsxs)("p",{children:["As with all experimental research-driven projects the rate of progress is unpredictable, and MaidSafe avoid giving hard deadlines. However, there is a roadmap at ",Object(o.jsx)("a",{href:"https://safenetwork.tech/timeline/",children:"https://safenetwork.tech/timeline/"})," in which the next developments are laid out. The next MVP, Safe Fleming, will allow anyone with a computer and an internet connection to join the Network."]}),Object(o.jsx)("h2",{children:"About MaidSafe"}),Object(o.jsx)("p",{children:"MaidSafe is a company founded by David Irvine in 2006 with a mission to provide security and privacy for everyone by building a better digital world. This new platform is the Safe Network, which is the world\u2019s first autonomous and decentralized data network. The Network is made up of the unused hard drive space, processing power and bandwidth of its users. The Safe Network will include storage, peer-to-peer communications, transactions, Internet functionality and a wide variety of apps to name a few of its features. This paper was written and produced by members of the Safe Network Forum independently of MaidSafe.\xa0"}),Object(o.jsxs)("p",{children:["Join the debate at ",Object(o.jsx)("a",{href:"https://safenetforum.org/",children:"https://safenetforum.org"}),"\xa0"]}),Object(o.jsxs)("p",{children:["Website: ",Object(o.jsx)("a",{href:"http://www.safenetwork.tech/",children:"www.safenetwork.tech"})]}),Object(o.jsxs)("p",{children:["Developer forum: ",Object(o.jsx)("a",{href:"http://www.safedev.org/",children:"forum.safedev.org"})]}),Object(o.jsxs)("p",{children:["Developer hub: ",Object(o.jsx)("a",{href:"https://hub.safedev.org/",children:"https://hub.safedev.org/"})]}),Object(o.jsxs)("p",{children:["Github: ",Object(o.jsx)("a",{href:"https://github.com/maidsafe",children:"https://github.com/maidsafe"})]}),Object(o.jsxs)("p",{children:["Twitter: ",Object(o.jsx)("a",{href:"https://twitter.com/maidsafe",children:"https://twitter.com/maidsafe"})]}),Object(o.jsxs)("p",{children:["Twitter: ",Object(o.jsx)("a",{href:"https://twitter.com/maidsafe",children:"https://twitter.com/safenetworktech"})]}),Object(o.jsxs)("p",{children:["Reddit: ",Object(o.jsx)("a",{href:"https://reddit.com/r/safenetwork",children:"https://reddit.com/r/safenetwork"})]}),Object(o.jsxs)("p",{children:["Telegram: ",Object(o.jsx)("a",{href:"https://t.me/safenetwork",children:"https://t.me/safenetwork"})]})]})},L=(a(10),function(e){return Object(o.jsxs)("div",{children:[Object(o.jsxs)("div",{className:"header",align:"center",children:[Object(o.jsx)("h1",{children:"The SAFE Network Primer"}),Object(o.jsx)("p",{children:Object(o.jsx)("strong",{children:"An introductory guide to the world's first fully autonomous data and communications network"})}),Object(o.jsx)("p",{children:"Last update: August 2020"})]}),Object(o.jsx)("hr",{}),Object(o.jsx)("div",{align:" left ",children:Object(o.jsxs)("p",{children:["Major changes since last update:",Object(o.jsxs)("ul",{children:[Object(o.jsx)("li",{children:"Sections split when they grow large but no longer merge"}),Object(o.jsx)("li",{children:"Arrival of BLS-DKG encryption for authentication and multisig transactions"}),Object(o.jsx)("li",{children:"Data Chain replaced with SectionProofChain"}),Object(o.jsx)("li",{children:"Implementation of conflict-free data types (CRDTs)"}),Object(o.jsx)("li",{children:"Implementation of asynchronous trustworthy transfers (AT2) allowing deprecation of PARSEC consensus algorithm "}),Object(o.jsx)("li",{children:"Implementation of SectionProofChains and deprecation of Data Chains "}),Object(o.jsx)("li",{children:"New data types Map, Sequence and Blob replace MutableData, AppendOnlyData and ImmutableData"})]})]})}),Object(o.jsx)("hr",{})]})});var G=function(e){return Object(o.jsx)("div",{children:Object(o.jsx)("div",{className:"Topbar",style:{backgroundColor:e.bgcol,height:"10px"}})})};var K=function(){return Object(o.jsxs)("div",{className:"App",children:[Object(o.jsx)(L,{}),Object(o.jsx)(r,{}),Object(o.jsx)(G,{bgcol:"#1f3a80",word:""}),Object(o.jsx)(s,{}),Object(o.jsx)(G,{bgcol:"#1f3a70",word:""}),Object(o.jsx)(l,{}),Object(o.jsx)(G,{bgcol:"#1f3a60",word:""}),Object(o.jsx)(p,{}),Object(o.jsx)(G,{bgcol:"#1f3a50",word:""}),Object(o.jsx)(b,{}),Object(o.jsx)(G,{bgcol:"#1f3a40",word:""}),Object(o.jsx)(m,{}),Object(o.jsx)(G,{bgcol:"#1f3a30",word:""}),Object(o.jsx)(j,{}),Object(o.jsx)(G,{bgcol:"#1f3a20",word:""}),Object(o.jsx)(w,{}),Object(o.jsx)(G,{bgcol:"#1f3a10",word:""}),Object(o.jsx)(k,{}),Object(o.jsx)(G,{bgcol:"#1f3b90",word:""}),Object(o.jsx)(P,{}),Object(o.jsx)(G,{bgcol:"#1f3b80",word:""}),Object(o.jsx)(q,{}),Object(o.jsx)(G,{bgcol:"#1f3b70",word:""}),Object(o.jsx)(_,{}),Object(o.jsx)(G,{bgcol:"#1f3b60",word:""}),Object(o.jsx)(W,{}),Object(o.jsx)(G,{bgcol:"#1f3b50",word:""}),Object(o.jsx)(z,{})]})},U=Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));function X(e,t){navigator.serviceWorker.register(e).then((function(e){e.onupdatefound=function(){var a=e.installing;null!=a&&(a.onstatechange=function(){"installed"===a.state&&(navigator.serviceWorker.controller?(console.log("New content is available and will be used when all tabs for this page are closed. See https://bit.ly/CRA-PWA."),t&&t.onUpdate&&t.onUpdate(e)):(console.log("Content is cached for offline use."),t&&t.onSuccess&&t.onSuccess(e)))})}})).catch((function(e){console.error("Error during service worker registration:",e)}))}i.a.render(Object(o.jsx)(K,{}),document.getElementById("root")),function(e){if("serviceWorker"in navigator){if(new URL("/draft2",window.location.href).origin!==window.location.origin)return;window.addEventListener("load",(function(){var t="".concat("/draft2","/service-worker.js");U?(!function(e,t){fetch(e).then((function(a){var n=a.headers.get("content-type");404===a.status||null!=n&&-1===n.indexOf("javascript")?navigator.serviceWorker.ready.then((function(e){e.unregister().then((function(){window.location.reload()}))})):X(e,t)})).catch((function(){console.log("No internet connection found. App is running in offline mode.")}))}(t,e),navigator.serviceWorker.ready.then((function(){console.log("This web app is being served cache-first by a service worker. To learn more, visit https://bit.ly/CRA-PWA")}))):X(t,e)}))}}()},8:function(e,t,a){}},[[11,1,2]]]);
//# sourceMappingURL=main.dfd5bcbf.chunk.js.map