{"version":3,"sources":["pages/Intro.js","pages/Chap1.js","images/networking_layers.jpg","images/stack.png","pages/Chap2.js","pages/Chap3.js","images/app_auth_flow.jpg","images/xor_addresses.jpg","pages/Chap4.js","images/nodes_journey.png","pages/Chap5.js","images/password-passphrase.jpeg","pages/Chap6.js","pages/Chap7.js","images/proof_of_resource.jpg","images/resources_and_currency.jpg","images/dbc.jpg","pages/Chap8.js","images/supermajority.png","images/ae1.png","images/ae2.png","images/ae3.png","images/ae4.png","images/ae5.png","images/ae6.png","images/ae7.png","images/ae8.png","images/ae9.png","images/ae10.png","images/ae11.png","pages/Chap9.js","pages/Chap10.js","images/data_types.png","pages/Chap11.js","pages/Chap12.js","pages/Chap13.js","Header.js","Topbar.js","App.js","serviceWorker.js","index.js"],"names":["component","className","id","bgcol","height","href","align","src","networking_layers","alt","stack","Chap4","xor_addresses","width","Chap5","nodes_journey","title","Chap6","password_passphrase","target","rel","Chap7","proof_of_resource","resources_and_currency","dbc","type","supermajority","ae1","ae2","ae3","ae4","ae5","ae6","ae7","ae8","ae9","ae10","ae11","prop","Topbar","props","style","backgroundColor","App","Header","Intro","word","Chap1","Chap2","Chap3","Chap8","Chap9","Chap10","Chap11","Chap12","Chap13","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","onUpdate","onSuccess","catch","error","ReactDOM","render","document","getElementById","URL","process","origin","addEventListener","fetch","response","contentType","headers","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"oKAqCeA,EAnCG,kBACd,sBAAKC,UAAU,QAAf,UACI,oBAAIC,GAAG,MAAP,kCAEA,2dACA,qSACA,8fACA,qHAAwF,+CAAxF,oEACA,8fACA,yOACA,+GACA,+aAIA,qBAAKC,MAAM,UAAUC,OAAO,SAC5B,0CACA,8BAAG,uBAAM,mBAAGC,KAAK,OAAR,4CACL,uBAAM,mBAAGA,KAAK,OAAR,gDACN,uBAAM,mBAAGA,KAAK,OAAR,kCACN,uBAAM,mBAAGA,KAAK,OAAR,qDACN,uBAAM,mBAAGA,KAAK,OAAR,yBACN,uBAAM,mBAAGA,KAAK,OAAR,8CACN,uBAAM,mBAAGA,KAAK,OAAR,qDACN,uBAAM,mBAAGA,KAAK,OAAR,mEACN,uBAAM,mBAAGA,KAAK,OAAR,0CACN,uBAAM,mBAAGA,KAAK,QAAR,4BACN,uBAAM,mBAAGA,KAAK,QAAR,8EACN,uBAAM,mBAAGA,KAAK,QAAR,wDCuBHL,EAlDG,kBAEd,sBAAKC,UAAU,UAAf,UAKI,oBAAIC,GAAG,MAAP,oDAEA,+BAAI,uBAAJ,iBAEA,8BAAG,uBAAH,gXAAsX,uBAAtX,IAA6X,uBAA7X,6SAA6qB,uBAA7qB,IAAorB,uBAAprB,mOAA05B,uBAA15B,IAAi6B,uBAAj6B,uuBAA6oD,uBAA7oD,IAAopD,uBAAppD,6nBAAsxE,uBAAtxE,OAEA,+EAEA,sMAEI,uDACI,mCAAK,sHAAwF,uBAAxF,4FACH,iIAAmG,uBAAnG,8IACD,sIACA,+FAAiE,uBAAjE,iMACD,qIACA,kGACA,+GACA,iKACA,gIACA,sJACA,gFAAkD,uBAAlD,6EACA,8HAAgG,uBAAhG,qMACA,2LAA6J,uBAA7J,oEACA,iGAAmE,uBAAnE,4EACA,oDAAsB,uBAAtB,6KACA,mEAAqC,uBAArC,uGACA,oJACA,oEAAsC,uBAAtC,iIACA,oFACA,+EAAiD,uBAAjD,2DAnBA,OAqBJ,iUAGJ,iGAAmE,mBAAGG,KAAK,yCAAR,2DC7C5D,MAA0B,8CCA1B,MAA0B,kCCuF1BL,EAlFG,kBAEd,sBAAKC,UAAU,UAAf,UAIJ,oBAAIC,GAAG,MAAP,gDAIA,kZAIA,uZAIA,qBAAKD,UAAU,iBAAiBK,MAAM,SAAtC,SAEA,qBAAKL,UAAU,MAAMM,IAAKC,EAAmBC,IAAI,oBAAoBH,MAAM,aAMnE,uaAER,+TAEA,6IAIA,2JAEA,qBAAKL,UAAU,iBAAiBK,MAAM,SAAtC,SAEI,qBAAKL,UAAU,MAAMM,IAAKG,EAAOD,IAAI,QAASH,MAAM,aAMxD,0CAEA,2cAEA,yCAEA,0NAEA,sTAEA,4QACA,0SAEE,2gBAEM,iSAEA,+FACA,oDAGR,4BAAG,mBAAGD,KAAK,2CAAR,6GAEH,4BAAG,mBAAGA,KAAK,uCAAR,0GAGF,4BAAG,mBAAGA,KAAK,+CAAR,8CAEI,yCCWOL,GCxFA,IDKG,kBAEd,sBAAKC,UAAU,UAAf,UAGJ,oBAAIC,GAAG,MAAP,kCAIA,sVAEA,qWAEA,kFAEQ,sBAAKD,UAAU,iBAAf,UAIR,iDAEI,6VACA,8YAKJ,0CAEA,oiBAEA,4oBACA,sBAAKA,UAAU,sBAAf,UACQ,sDAEA,yPAEA,4SAEA,kIAEA,2EAEA,wFAEI,0HAEJ,oKAEA,uJAEA,gJAIA,iVAER,4WAEA,mNAEA,4CAEA,4SAEA,mpBAGA,oWACA,iDACA,4BAAG,mBAAGI,KAAK,kHAAR,oFACH,4BAAG,mBAAGA,KAAK,iEAAR,8DACH,4BAAG,mBAAGA,KAAK,+CAAR,8CACH,4BAAG,mBAAGA,KAAK,+CAAR,yCACH,4BAAG,mBAAGA,KAAK,2CAAR,qCACH,4BAAG,mBAAGA,KAAK,2CAAR,4CACH,4BAAG,mBAAGA,KAAK,sDAAR,wGEjFY,MAA0B,0CCwF1BM,EAnFD,kBAEV,sBAAKV,UAAU,UAAf,UACI,oBAAIC,GAAG,MAAP,qDACA,mpBACA,0CACA,0JACA,mZACA,mWACA,8MAAgL,sCAAhL,kOACA,gnBAEA,sBAAKD,UAAU,sBAAf,UACI,sDACA,sHACA,wKACA,6KACA,8HACA,kIACT,2HACS,uGACA,yKACA,0IACA,2MACA,2QACA,6RACA,2MACA,kLAEL,mcACC,gcACA,oTACA,ieACA,mBAAGA,UAAU,YAAb,sKACA,qBAAKA,UAAU,iBAAiBK,MAAM,SAAtC,SAEI,qBAAKL,UAAU,MAAMM,IAAKK,EAAeH,IAAI,oBAAoBI,MAAM,MAAMP,MAAM,aAEvF,4BAAG,kPACH,8IACA,kJACA,wVAMA,2CACA,6pBAEA,gMAEA,sBAAKL,UAAU,iBAAf,UACI,iDACA,yVAKJ,mBAAGA,UAAU,YAAb,kFACA,qYAEA,sJAEA,iDACA,4BAAG,mBAAGI,KAAK,mDAAR,6DACH,4BAAG,mBAAGA,KAAK,yEAAR,sGACH,4BAAG,mBAAGA,KAAK,6EAAR,kEACH,4BAAG,mBAAGA,KAAK,qEAAR,6DACH,4BAAG,mBAAGA,KAAK,6DAAR,uDACH,4BAAG,mBAAGA,KAAK,kGAAR,gDACX,4BAAG,mBAAGA,KAAK,0DAAR,oGC5EY,MAA0B,0CCmE1BS,EA9DD,kBAEV,sBAAKb,UAAU,UAAf,UACI,oBAAIC,GAAG,MAAP,yBAEN,gOAEA,mTAEM,83BAEA,sBAAKD,UAAU,iBAAf,UACA,iDACA,giBAEA,2XAEN,gSAEA,kkBAEC,isBAEG,+XAEH,+YAGA,8OAKK,6RACA,+MACA,qBAAKA,UAAU,iBAAiBK,MAAM,SAAtC,SAEI,qBAAKL,UAAU,MAAMM,IAAKQ,EAAeN,IAAI,iBAAkBH,MAAM,aAGzE,sBAAKL,UAAU,sBAAf,UACA,sDACI,6MACJ,6MACA,2UACA,uJACA,4JACA,kGACA,6IAEA,qDAEA,4BAAG,mBAAGe,MAAM,sDAA0DX,KAAK,0FAAxE,yFAEH,4BAAG,mBAAGA,KAAK,oEAAR,4FACH,4BAAG,mBAAGA,KAAK,qDAAR,0DC5DI,MAA0B,iDC2E1BY,EAtED,kBAEV,sBAAKhB,UAAU,UAAf,UACI,oBAAIC,GAAG,MAAP,8CACA,wpBACA,uHACA,sBAAKD,UAAU,iBAAf,UACA,iDACI,qdAEJ,2tBAAgsB,0CAAhsB,4CACA,mLACA,6DACA,yvBAEA,4DACA,gzBACA,kKACA,2ZACA,qBAAKA,UAAU,YAAf,SAA2B,8IAC3B,yDACA,2nBACA,yCACA,ymBAEA,kDACA,wIACA,yOACA,8eACA,uRACA,gXAAkV,wDAAlV,wBAA0Y,wDAA1Y,mKACI,qBAAKA,UAAU,iBAAiBK,MAAM,SAAtC,SAEZ,qBAAKC,IAAKW,EAAqBT,IAAI,sBAAsBI,MAAM,MAAMP,MAAM,aAI3E,0MACA,uNAAyL,uDAAzL,OACQ,iVACA,yIAGA,sBAAKL,UAAU,sBAAf,UACA,sDACA,0VACA,gHAEA,kHACI,8LACA,kPACA,gMACA,2KACA,kFACA,2KAEJ,iDACA,4BAAG,mBAAGe,MAAM,SAASX,KAAK,0CAA0Cc,OAAO,SAASC,IAAI,sBAArF,uDACH,mBAAGJ,MAAM,cAAT,SAAuB,mBAAGA,MAAM,cAAcX,KAAK,6BAA6Bc,OAAO,SAASC,IAAI,sBAA7E,8BAEzB,8BAAG,mBAAGJ,MAAM,wBAAwBX,KAAK,8CAAtC,qFAAH,OACE,4BAAG,mBAAGW,MAAM,kBAAkBX,KAAK,8CAA8Cc,OAAO,SAASC,IAAI,sBAAlG,6DACH,4BAAG,mBAAGJ,MAAM,uBAAuBX,KAAK,kEAAkEc,OAAO,SAASC,IAAI,sBAA3H,0DACH,4BAAG,mBAAGJ,MAAM,qBAAqBX,KAAK,uIAAuIc,OAAO,SAASC,IAAI,sBAA9L,iDACH,4BAAG,mBAAGJ,MAAM,SAASX,KAAK,+BAA+Bc,OAAO,SAASC,IAAI,sBAA1E,mDCsCIC,EAvGD,kBAEV,sBAAKpB,UAAU,UAAf,UACI,oBAAIC,GAAG,MAAP,oDAEA,gDAEA,uTAEA,iiBAEA,utBAEA,+CAEA,s3BAEA,8uBACA,mLACA,whBACA,0UAEA,+EAEA,s9BAEA,gWAGA,sBAAKD,UAAU,sBAAf,UACA,sDACA,gMACA,uNACA,4LACA,yKACA,yNACA,sPACA,kJACA,uHAIN,+DACD,+kBAEO,oUAEA,62BAEA,qJAQN,8CACA,4lBAEF,4PAEA,ubAIQ,6EAGA,wpBACA,skBACA,2YACA,+gBACA,sHAGA,sBAAKA,UAAU,iBAAf,UACI,gDACA,kxBAGJ,qDAEA,4BAAG,mBAAGe,MAAM,wCAAwCX,KAAK,6CAA6Cc,OAAO,SAASC,IAAI,sBAAvH,mHACH,4BAAG,mBAAGJ,MAAM,cAAcX,KAAK,0FAA0Fc,OAAO,SAASC,IAAI,sBAA1I,2EAGH,4BAAG,mBAAGJ,MAAM,MAAMX,KAAK,0IAA0Ic,OAAO,SAASC,IAAI,sBAAlL,gEAEH,4BAAG,mBAAGJ,MAAM,MAAMX,KAAK,mEAAmEc,OAAO,SAASC,IAAI,sBAA3G,8CACH,4BAAG,mBAAGJ,MAAM,OAAOX,KAAK,8CAA8Cc,OAAO,SAASC,IAAI,sBAAvF,gGACH,4BAAG,mBAAGJ,MAAM,QAAQX,KAAK,mEAAmEc,OAAO,SAASC,IAAI,sBAA7G,oDACH,4BAAG,mBAAGJ,MAAM,QAAQX,KAAK,8CAA8Cc,OAAO,SAASC,IAAI,sBAAxF,yEACH,4BAAG,mBAAGJ,MAAM,QAAQX,KAAK,8CAA8Cc,OAAO,SAASC,IAAI,sBAAxF,qDCjGI,MAA0B,8CCA1B,MAA0B,mDCA1B,MAA0B,gCCwI1BpB,EAjIG,kBAEd,sBAAKC,UAAU,UAAf,UAGI,oBAAIC,GAAG,MAAP,mEAEA,0bAEA,+IACA,sBAAKD,UAAU,iBAAf,UACA,iDAEI,mPAGJ,ydAEA,0OAEA,wwBACA,sBAAKA,UAAU,sBAAf,UACA,sDAEA,yFAEI,6LAEJ,kLAEI,mbAEJ,qBAAKA,UAAU,iBAAiBK,MAAM,SAAtC,SAEI,qBAAKL,UAAU,OAAOM,IAAKe,EAAmBb,IAAI,MAAMH,MAAM,aAMlE,weAEA,ofACA,qBAAKL,UAAU,YAAf,uKAIA,6SAEA,qBAAKA,UAAU,iBAAiBK,MAAM,SAAtC,SAEI,qBAAKC,IAAKgB,EAAwBd,IAAI,yBAAyBI,MAAM,MAAMP,MAAM,aAMrF,8QAEA,+SAED,6DAEA,4fACA,8UAEA,4DAEP,g5BAGA,qBAAKL,UAAU,iBAAiBK,MAAM,SAAtC,SACA,qBAAKL,UAAU,MAAMM,IAAKiB,EAAKf,IAAI,MAAMI,MAAM,MAAMP,MAAM,aAG3D,6BAAI,+BACJ,0DACA,iEACA,6DACA,2EACA,4EACA,wIAGA,gDACA,0kBAGA,+CAEA,6bAEA,+CAEA,wbAEA,2TAEA,uPAKQ,iDAEA,4BAAG,mBAAGU,MAAM,gBAAgBX,KAAK,0DAA0Dc,OAAO,SAASC,IAAI,sBAA5G,gEAEH,4BAAG,mBAAGJ,MAAM,cAAcX,KAAK,2EAA2Ec,OAAO,SAASC,IAAI,sBAA3H,gEAEH,4BAAG,mBAAGJ,MAAM,mBAAmBX,KAAK,0DAA0Dc,OAAO,SAASC,IAAI,sBAA/G,0FAEH,4BAAG,mBAAGJ,MAAM,yBAAyBX,KAAK,4CAA4Cc,OAAO,SAASC,IAAI,sBAAvG,wEAEH,4BAAG,mBAAGJ,MAAM,QAAQX,KAAK,iFAAiFc,OAAO,SAASC,IAAI,sBAA3H,0GAEH,4BAAG,mBAAGJ,MAAM,WAAWX,KAAK,iGAAiGc,OAAO,SAASC,IAAI,sBAA9I,0EAGH,8BAAG,mBAAGJ,MAAM,YAAYX,KAAK,qCAAqCc,OAAO,SAASC,IAAI,sBAAnF,qDAAH,eAEA,8BAAG,mBAAGJ,MAAM,0BAA0BX,KAAK,kHAAkHc,OAAO,SAASC,IAAI,sBAA9K,oDAAH,WAEA,4BAAG,mBAAGJ,MAAM,gBAAgBX,KAAK,sDAAsDc,OAAO,SAASC,IAAI,sBAAxG,+CCjII,MAA0B,0CCA1B,MAA0B,gCCA1B,MAA0B,gCCA1B,MAA0B,gCCA1B,MAA0B,gCCA1B,MAA0B,gCCA1B,MAA0B,gCCA1B,MAA0B,gCCA1B,MAA0B,gCCA1B,MAA0B,gCCA1B,MAA0B,iCCA1B,MAA0B,iCCyJ1BpB,EAzIG,kBAEd,sBAAKC,UAAU,UAAf,UAGI,oBAAIC,GAAG,MAAP,0CAKR,sSACA,2SACA,uRACA,gRACA,8OACA,sWACA,iQACA,sJAEA,8DACA,+BACA,+BAAI,mDAAJ,yTACA,+BAAI,sEAAJ,2GACA,+BAAI,6DAAJ,6FACA,+BAAI,0DAAJ,iHAIA,6DACA,4RACA,sLACA,wKAGA,2EAEA,+NAEA,gJAEA,8PAGA,4DACA,0IACA,qBAAIuB,KAAK,IAAT,UACI,oGACA,oMACA,mGAIJ,gEACA,yYACA,uKACA,wNAGU,qBAAKxB,UAAU,MAAMM,IAAKmB,EAAejB,IAAI,gBAAgBI,MAAM,MAAMP,MAAM,WAEzF,+OACA,0VACA,oPAKA,gEACA,wSAEA,0DACU,qBAAKL,UAAU,MAAMM,IAAKoB,EAAKlB,IAAI,MAAMI,MAAM,MAAMP,MAAM,WACrE,4BAAG,4CACH,+BACI,qJACA,+EACA,gGACA,iFACA,sGACA,oIACA,yFAEJ,iHAGU,qBAAKL,UAAU,MAAMM,IAAKqB,EAAKnB,IAAI,MAAMI,MAAM,MAAMP,MAAM,WAEnE,2EACQ,qBAAKL,UAAU,MAAMM,IAAKsB,EAAKpB,IAAI,MAAMI,MAAM,MAAMP,MAAM,WAErE,gIACU,qBAAKL,UAAU,MAAMM,IAAKuB,EAAKrB,IAAI,MAAMI,MAAM,MAAMP,MAAM,WAErE,iEAEU,qBAAKL,UAAU,MAAMM,IAAKwB,EAAKtB,IAAI,MAAMI,MAAM,MAAMP,MAAM,WAErE,waACA,qJAEA,6HACU,qBAAKL,UAAU,MAAMM,IAAKyB,EAAKvB,IAAI,MAAMI,MAAM,MAAMP,MAAM,WAEjE,8DACM,qBAAKL,UAAU,MAAMM,IAAK0B,EAAKxB,IAAI,MAAMI,MAAM,MAAMP,MAAM,WAErE,wGACU,qBAAKL,UAAU,MAAMM,IAAK2B,EAAKzB,IAAI,MAAMI,MAAM,MAAMP,MAAM,WACrE,0FACU,qBAAKL,UAAU,MAAMM,IAAK4B,EAAK1B,IAAI,MAAMI,MAAM,MAAMP,MAAM,WACrE,+GACU,qBAAKL,UAAU,MAAMM,IAAK6B,EAAM3B,IAAI,OAAOI,MAAM,MAAMP,MAAM,WACvE,4FACU,qBAAKL,UAAU,MAAMM,IAAK8B,EAAM5B,IAAI,OAAOI,MAAM,MAAMP,MAAM,WAGvE,6IAA+G,mCAA/G,4EAGA,yTACA,6PAGA,sBAAKL,UAAU,iBAAf,UACQ,iDACR,6PACA,wIACA,6RAEG,qDACA,4BAAG,mBAAGe,MAAM,eAAeX,KAAK,+CAA+Cc,OAAO,SAASC,IAAI,sBAAhG,yCCxCSpB,GC1GA,IDMG,kBAEd,sBAAKC,UAAU,UAAf,UACI,oBAAIC,GAAG,OAAP,4BAEP,4NAEC,iRAEA,spBAEA,idAEA,qTAGA,sCACM,4WACA,6RAGA,0ZAEA,0CAEN,4hBAIC,0CAEA,6FAEA,kFAAoD,qCAApD,SAAsE,uCAAtE,WAA4F,qCAA5F,SAA8G,uCAA9G,eAEA,wKAA0I,qCAA1I,SAA4J,uCAA5J,mJAGE,yjBAEG,6VAEA,iHAIA,sBAAKD,UAAU,sBAAf,UACI,sDACA,6HACA,gEACA,sEACA,iGACT,gJACS,wLACT,6EACS,uJACA,sPACA,wHACA,2KACT,uFACS,2PACA,qIACA,2MACC,oKACD,+RAIJ,sDAEA,ugBAEA,wDAEA,omCAGA,2cAED,iDACC,qCACA,4BAAG,mBAAGe,MAAM,aAAaX,KAAK,4DAA4Dc,OAAO,SAASC,IAAI,sBAA3G,qDAEH,4BAAG,mBAAGJ,MAAM,aAAaX,KAAK,2EAA2Ec,OAAO,SAASC,IAAI,sBAA1H,4DAGH,4BAAG,mBAAGJ,MAAM,eAAeX,KAAK,iKAAiKc,OAAO,SAASC,IAAI,sBAAlN,6EACH,4BAAG,mBAAGJ,MAAM,KAAKX,KAAK,iKAAiKc,OAAO,SAASC,IAAI,sBAAxM,wEACH,4BAAG,mBAAGJ,MAAM,MAAMX,KAAK,sCAAsCc,OAAO,SAASC,IAAI,sBAA9E,gDACH,4BAAG,mBAAGJ,MAAM,WAAWX,KAAK,4CAA4Cc,OAAO,SAASC,IAAI,sBAAzF,uFACH,4BAAG,mBAAGJ,MAAM,OAAOX,KAAK,kEAAkEc,OAAO,SAASC,IAAI,sBAA3G,2EACH,4BAAG,mBAAGJ,MAAM,QAAQX,KAAK,oCAAoCc,OAAO,SAASC,IAAI,sBAA9E,8EACH,4BAAG,mBAAGJ,MAAM,UAAUX,KAAK,2BAA2Bc,OAAO,SAASC,IAAI,sBAAvE,gDACH,4BAAG,mBAAGJ,MAAM,WAAWX,KAAK,iDAAiDc,OAAO,SAASC,IAAI,sBAA9F,8CACH,4BAAG,mBAAGJ,MAAM,UAAUX,KAAK,qHAAqHc,OAAO,SAASC,IAAI,sBAAjK,uCACH,4BAAG,mBAAGJ,MAAM,UAAUX,KAAK,sEAAsEc,OAAO,SAASC,IAAI,sBAAlH,oEEhEIpB,EAhCG,kBAEd,sBAAKC,UAAU,UAAf,UACI,oBAAIC,GAAG,OAAP,8EACA,0VACA,6BAAI,gDACJ,8BAAG,2DAAkC,8CAArC,0XACA,8BAAG,kEAAH,+OACA,8BAAG,6CAAH,iQACA,8BAAG,uCAAH,+EACA,8BAAG,4CAAH,wMACA,8BAAG,iDAAH,wYACA,8BAAG,gDAAH,4ZACA,8BAAG,qDAAH,oNACA,8BAAG,+CAAH,wgBACA,8BAAG,mDAAH,ubACA,8BAAG,yCAAH,wHACA,8BAAG,kDAAH,kRACA,6BAAI,sEACJ,8BAAG,8CAAH,iNACA,8kBACA,6XACA,6GACA,8BAAG,0DAAH,0VACA,8BAAG,yCAAgB,oDAAnB,6LACA,8BAAG,sCAAH,6IACA,8BAAG,mDAAH,mQACA,8BAAG,4CAAH,gMC0BOF,EApDG,kBACd,gCACI,oBAAIE,GAAG,OAAP,iDAIA,wiBAEA,y+BAIA,qBAAKD,UAAU,YAAf,+FAIA,wdAEA,sZAEA,6mBAEA,yCAEA,mMAAqK,mBAAGI,KAAK,qCAAR,gDAArK,iKAEA,gDAIA,upBAEA,oDAAsB,mBAAGA,KAAK,4BAAR,sCAAtB,UAEA,0CAAY,mBAAGA,KAAK,+BAAR,qCAEZ,kDAAoB,mBAAGA,KAAK,0BAAR,kCAEpB,gDAAkB,mBAAGA,KAAK,2BAAR,yCAElB,yCAAW,mBAAGA,KAAK,8BAAR,4CAEX,0CAAY,mBAAGA,KAAK,+BAAR,6CAEZ,0CAAY,mBAAGA,KAAK,+BAAR,oDAEZ,yCAAW,mBAAGA,KAAK,mCAAR,iDAEX,2CAAa,mBAAGA,KAAK,2BAAR,6CC1CNL,EANG,kBACd,yBCoBWA,G,MAzBG,SAACsC,GAAD,OACd,gCACA,sBAAKrC,UAAU,SAASK,MAAQ,SAAhC,UACI,yDACR,4BAAG,mIACK,8DAEA,uBACA,qBAAKA,MAAO,SAAZ,SACI,iEACA,+BAEQ,gFACA,iEACA,oFACA,wEACA,8EAKZ,4BCbOiC,MATf,SAAgBC,GACZ,OACI,8BACI,qBAAKvC,UAAU,SAASwC,MAAO,CAAEC,gBAAiBF,EAAMrC,MAAOC,OAAQ,aCqDpEuC,MAvCf,WAEI,OAEI,sBAAK1C,UAAU,MAAf,UAGE,cAAC2C,EAAD,IACA,cAACC,EAAD,IACA,cAAC,EAAD,CAAQ1C,MAAM,UAAU2C,KAAK,KAC7B,cAACC,EAAD,IACA,cAAC,EAAD,CAAQ5C,MAAM,UAAU2C,KAAK,KAC7B,cAACE,EAAD,IACA,cAAC,EAAD,CAAQ7C,MAAM,UAAU2C,KAAK,KAC7B,cAACG,EAAD,IACA,cAAC,EAAD,CAAQ9C,MAAM,UAAU2C,KAAK,KAC9B,cAAC,EAAD,IACA,cAAC,EAAD,CAAQ3C,MAAM,UAAU2C,KAAK,KAC7B,cAAC,EAAD,IACA,cAAC,EAAD,CAAQ3C,MAAM,UAAU2C,KAAK,KAC7B,cAAC,EAAD,IACA,cAAC,EAAD,CAAQ3C,MAAM,UAAU2C,KAAK,KAC7B,cAAC,EAAD,IACA,cAAC,EAAD,CAAQ3C,MAAM,UAAU2C,KAAK,KAC7B,cAACI,EAAD,IACA,cAAC,EAAD,CAAQ/C,MAAM,UAAU2C,KAAK,KAC7B,cAACK,EAAD,IACA,cAAC,EAAD,CAAQhD,MAAM,UAAU2C,KAAK,KAC7B,cAACM,EAAD,IACA,cAAC,EAAD,CAAQjD,MAAM,UAAU2C,KAAK,KAC7B,cAACO,EAAD,IACA,cAAC,EAAD,CAAQlD,MAAM,UAAU2C,KAAK,KAC7B,cAACQ,EAAD,IACA,cAAC,EAAD,CAAQnD,MAAM,UAAU2C,KAAK,KAC7B,cAACS,EAAD,QCxCHC,EAAcC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DAsCN,SAASC,EAAgBC,EAAOC,GAC9BC,UAAUC,cACPC,SAASJ,GACTK,MAAK,SAAAC,GACJA,EAAaC,cAAgB,WAC3B,IAAMC,EAAmBF,EAAaG,WACd,MAApBD,IAGJA,EAAiBE,cAAgB,WACA,cAA3BF,EAAiBG,QACfT,UAAUC,cAAcS,YAI1BC,QAAQC,IACN,iHAKEb,GAAUA,EAAOc,UACnBd,EAAOc,SAAST,KAMlBO,QAAQC,IAAI,sCAGRb,GAAUA,EAAOe,WACnBf,EAAOe,UAAUV,WAO5BW,OAAM,SAAAC,GACLL,QAAQK,MAAM,4CAA6CA,MC1FjEC,IAASC,OAAO,cAAC,EAAD,IAASC,SAASC,eAAe,SDgB1C,SAAkBrB,GACvB,GAA6C,kBAAmBC,UAAW,CAGzE,GADkB,IAAIqB,IAAIC,UAAwB7B,OAAOC,SAAStD,MACpDmF,SAAW9B,OAAOC,SAAS6B,OAIvC,OAGF9B,OAAO+B,iBAAiB,QAAQ,WAC9B,IAAM1B,EAAK,UAAMwB,UAAN,sBAEP/B,IAgEV,SAAiCO,EAAOC,GAEtC0B,MAAM3B,GACHK,MAAK,SAAAuB,GAEJ,IAAMC,EAAcD,EAASE,QAAQC,IAAI,gBAEnB,MAApBH,EAASI,QACO,MAAfH,IAA8D,IAAvCA,EAAYI,QAAQ,cAG5C/B,UAAUC,cAAc+B,MAAM7B,MAAK,SAAAC,GACjCA,EAAa6B,aAAa9B,MAAK,WAC7BV,OAAOC,SAASwC,eAKpBrC,EAAgBC,EAAOC,MAG1BgB,OAAM,WACLJ,QAAQC,IACN,oEArFAuB,CAAwBrC,EAAOC,GAI/BC,UAAUC,cAAc+B,MAAM7B,MAAK,WACjCQ,QAAQC,IACN,iHAMJf,EAAgBC,EAAOC,OCvC/BE,I","file":"static/js/main.21dcd332.chunk.js","sourcesContent":["import React from 'react';\r\n\r\nconst component = () => (\r\n    <div className='intro'>\r\n        <h2 id='ch0'>A brief introduction</h2>\r\n  \r\n        <p>Technological progress is a perpetual process of automation and abstraction. Difficult and complex tasks are made simple by software and machines until they are completely taken for granted. Technology moves on, taking down new blockers in the path to progress as it goes. A good example of this is cloud computing, where once complex server administration tasks have been replaced, from the point of view of the consumer, by point-and-click.</p>\r\n        <p>The Safe (Secure Access For Everyone) Network takes this further, automating the entire network of interconnected machines, making it autonomous, secure, anonymous and capable of&nbsp; storing, protecting and delivering data without any human involvement at all.</p>\r\n        <p>The Safe Network is the vision of MaidSafe, a Scottish software company working in the field of decentralized computer networking. It is an autonomous peer-to-peer network created by linking together users' computers and smartphones that's designed to solve many of the current technical, managerial and societal problems exacerbated by centralized networks: a lack of privacy and data security, censorship and the massive consolidation of control by a few powerful actors.&nbsp;</p>\r\n        <p>(In case this sounds familiar, members of MaidSafe acted as advisers for HBO&rsquo;s <i>Silicon Valley</i> TV series in which a startup tries to reinvent the Internet!)</p>\r\n        <p>The Network is &lsquo;trustless&rsquo;, with no central point of control and no single point of failure. With connectivity and security taken care of, the Network is simple from the point of view of developers, with the burden of having to worry about low-level storage, networking, backups and computing resources removed. For people using the Network to store and share data and messages the burden of ensuring the security of precious information would be drastically reduced.</p>\r\n        <p>Anyone with a connected device can use the Network anonymously to store data or peruse public information on it, and anyone (subject to a resource test) can join the Network anonymously as a provider.</p> \r\n        <p>The Safe Network is a platform on which new digital worlds can be constructed.</p>\r\n        <p>This guide outlines how the Safe Network is constructed to achieve these aims. While it is somewhat technical in places, it's intended very much as an overview, and even those with very little technical knowledge should be able to gain a good working understanding of the Safe Network. For those requiring more depth, there are plenty of pointers as to where they can find the relevant information.</p>\r\n       \r\n      \r\n        \r\n        <div bgcol=\"#1f3a60\" height=\"10px\"></div>\r\n        <h2>Contents</h2>\r\n        <p><br /><a href='#ch1'>1. Background and fundamentals</a>\r\n            <br /><a href='#ch2'>2. A fully autonomous data network</a>\r\n            <br /><a href='#ch3'>3. Nodes and Clients</a>\r\n            <br /><a href='#ch4'>4. The architecture of the Safe Network</a>\r\n            <br /><a href='#ch5'>5. Node Age</a>\r\n            <br /><a href='#ch6'>6. Encryption and authentication</a>\r\n            <br /><a href='#ch7'>7. Network-wide consensus not required </a>\r\n            <br /><a href='#ch8'>8. Safe Network Token and Digital Bearer Certificates</a>\r\n            <br /><a href='#ch9'>9. Safe Network Anti-Entropy</a>\r\n            <br /><a href='#ch10'>10. Data types</a>\r\n            <br /><a href='#ch11'>11. How Safe Network defends against common types of cyberattack</a>\r\n            <br /><a href='#ch12'>12. The promise of the Safe Network</a>\r\n        </p>\r\n                            \r\n\r\n    </div>\r\n);\r\n\r\nexport default component;\r\n","import React from 'react';\r\n\r\n\r\nconst component = () => (\r\n\r\n    <div className='chapter'> \r\n\r\n\r\n\r\n    \r\n        <h2 id='ch1'>1.&nbsp;&nbsp; Background and fundamentals</h2>\r\n\r\n        <h3><br /> Background</h3>\r\n      \r\n        <p><br /> Decentralized or peer-to-peer (P2P) networks are not new. Since the release of Napster on June 1, 1999, they have taken the world by storm, particularly for file sharing. These networks allow users from all over the world to connect to each other and share data such as movies, books and music. In 2010 more than half of all Internet traffic was attributed to P2P.<br /> <br /> But the use of these technologies is not limited to simple file sharing. Freenet was launched in March, 2000 allowing people to publish decentralized websites (Freesites). Freesites are not stored on central servers but instead are distributed across the machines of the encrypted network's users.<br /> <br /> A little after that, the BitTorrent protocol was created by Bram Cohen. BitTorrent was and still is particularly well suited to transferring large files in a P2P fashion, allowing simultaneous downloads from multiple peers.<br /> <br /> The next notable development arrived after the financial crash which very nearly brought the global economy to its knees. In 2009 Satoshi Nakamoto released Bitcoin and gave the world a 'trustless' decentralized digital currency that is not controlled by bank, government or institution. The blockchain - the immutable ledger that records all Bitcoin transactions - was something very new, solving at a stroke the difficult and long-standing problem of creating a trustless source of the truth for transactions.&nbsp; The ownership of 'addresses' in the network can be proven by the usage of private keys in a Public Key Infrastructure (PKI) - hence the term cryptocurrency; however, connections between Bitcoin nodes are not fully encrypted.<br /> <br /> The Safe Network is the next big step in the evolution of P2P networks, combining the vision of decentralized file sharing and decentralized web sites together with an internal cryptocurrency - Safe Network Token (SNT) (formerly known as Safecoin) - and several additional innovations to enhance security, privacy, performance and stability. MaidSafe, a Scottish company with developers around the world, has been researching and developing this project since 2006.&nbsp; Since that time, many more people have come to recognize the vital importance of a global, secure and private decentralized platform for storage and communication.<br /> </p>\r\n\r\n        <h3>20 Fundamental Principles of the Safe Network</h3>\r\n\r\n        <p> There are a number of core ideas that have driven each stage of the design of the Safe Network. These can be distilled into the following 20 fundamental principles.</p>\r\n\r\n            <p>The Safe Network will:</p>\r\n                <ol> <li>Allow a person to create an account and login anonymously and without intervention. <br /> Creating a new account and logging into the Network will never require a third party.</li>\r\n                  <li>Enable users to securely and with no controlling intermediaries share information and messages.<br />The Safe Network will never allow third parties to either read or store the information sent by a user without that user&rsquo;s consent.</li>\r\n                 <li>Allow the transfer of the Network currency Safe Network Token to any user free of transaction costs.</li>\r\n                 <li>Enable Users to anonymously create and share data worldwide. <br />The Network will always ensure that the user has the ability to send transaction messages and posts with a temporary single-use ID that is not linked to any known identity on the Network.</li> \r\n                <li>Let anyone browse content anonymously and free of charge and without the need to create an account.</li>\r\n                <li>Allow users to associate multiple identities with their account.</li>\r\n                <li>Let users utilize any of their identities to send/receive Safe Network Token.</li>\r\n                <li>Store data in perpetuity. All public/published data on the Network will be immutable and available on the Network indefinitely.</li>\r\n                <li>Never require passwords to be stored on the Network or on machines used to access the Network.</li>\r\n                <li>Allow any user, on any machine, to access the Network leaving no trace of their presence or activity on the machine.</li>\r\n                <li>Scrub Client IP addresses from the first hop. <br />As soon as you have connected to the network, your IP address is wiped.</li>\r\n                <li>Only accept more Vaults (networked storage provided by users' machines) when it needs them. <br /> This is to prevent a bad actor from flooding the network with poorly performing or malicious Vaults and also to enable the Network to balance its resources automatically according to demand.</li>\r\n                <li>Increase farming rewards when it needs more resources (e.g. more Vaults to increase storage capacity) and decrease rewards when resources are plentiful. <br />This is the primary mechanism for balancing supply and demand.</li>\r\n                <li>Rank nodes over time and increase trust in higher ranked nodes.<br />The aim is to maximize performance and defend against certain attacks.</li>\r\n                <li>Not have servers! <br />The Safe Network will never rely on servers (as the term is traditionally understood) as to do so introduces a third-party weakness that undermines the entire Network.</li>\r\n                <li>Digitally sign all transactions. <br />To ensure that the transactions have been authorized in accordance with the rules of the Network.</li>\r\n                <li>Ensure that Client-to-Client direct messages (i.e. those not transmitted via other nodes in the Network) are free.</li>\r\n                <li>Never use time as a network tool. <br /> There can be no concept of time in a truly decentralized network without reaching out to centralized servers and services.</li>\r\n                <li>Only use encrypted services and encrypted traffic.</li>\r\n                <li>Allow real-time upgrades in a secure manner. <br />The Network will refuse upgrades that could break it.</li> </ol>\r\n\r\n            <p>We expand on these fundamental principles in the chapters that follow. Combined they aim to give all users the freedom to safely store data on the Network, to share information with others securely, to publish websites cheaply and easily and to communicate using secure channels and apps.</p>\r\n\r\n\r\n        <p>For a fuller version of this list see the Safe Network website. <a href=\"https://safenetwork.tech/fundamentals/\">https://safenetwork.tech/fundamentals/</a></p>\r\n\r\n\r\n        \r\n    </div>\r\n\r\n);\r\n\r\nexport default component;\r\n","export default __webpack_public_path__ + \"static/media/networking_layers.f0097177.jpg\";","export default __webpack_public_path__ + \"static/media/stack.4ed8d5de.png\";","import React from 'react';\r\nimport networking_layers from '../images/networking_layers.jpg';\r\nimport stack from '../images/stack.png';\r\n\r\n\r\nconst component = () => (\r\n\r\n    <div className='chapter'>\r\n\r\n\r\n    \r\n<h2 id='ch2'>2. A fully autonomous data network</h2>\r\n\r\n     \r\n\r\n<p>To enable Secure Access For Everyone, Safe is an &lsquo;autonomous data network&rsquo;. This means it is capable of performing networking and storage tasks such as managing and optimizing workloads, routing, failover, authentication and access control without any human intervention. Opportunities for powerful groups to aggregate control or prevent access are minimized.</p>\r\n\r\n       \r\n\r\n<p>Unlike the current Internet, Safe infrastructure is not defined by a set of federated servers, VMs, owned storage locations or identifiable nodes. Unlike blockchains, it is designed to store and manage live data rather than pointers to data and to transact in real-time. And unlike BitTorrent, it does not rely on centralized components of the Web to locate and track files.</p>\r\n\r\n\r\n\r\n<div className=\"Full-width-pic\" align=\"center\">\r\n    \r\n<img className=\"Img\" src={networking_layers} alt=\"Networking layers\" align=\"center\" />\r\n        </div>\r\n\r\n        \r\n\r\n   \r\n        <p>Many features in the Safe Network are innovations, but there is no intention to reinvent the wheel. It builds on existing decentralized technologies such as BitTorrent and Kademlia and is based on the physical and data infrastructure of the Internet. Early development of Safe happened in parallel with blockchain, and it has taken an alternative route to solve the decentralization puzzle.</p>\r\n\r\n<p>The Safe Network can be seen as a secure, encrypted, intelligent layer that sits on top of the current Internet, complementing the top three layers in the OSI model and adding resources in the application layer. This enables secure, anonymous, decentralized data storage and networking.</p>\r\n\r\n<p>Going a little deeper, Safe introduces some changes to the networking and application layers as shown below.</p>\r\n\r\n\r\n    \r\n<p>The Safe Network core libraries are written in the Rust programming language. The diagram below shows the basic hierarchy.</p>\r\n\r\n<div className=\"Full-width-pic\" align=\"center\">\r\n\r\n    <img className=\"Img\" src={stack} alt=\"Stack\"  align=\"center\" />\r\n</div>\r\n\r\n \r\n\r\n\r\n<h3>quic-p2p</h3>\r\n\r\n<p>QUIC peer-to-peer (quic-p2p or qp2p) is based on the QUIC protocol created at Google. It is a networking library that enables peers on a P2P network to communicate securely, and to re-join the network without requiring a hard-coded list of known peers; such a list would be an obvious security hole. It supports multiple protocols allowing ordinary PCs and smartphones to connect to each other and is cryptographically secure.</p>\r\n\r\n<h3>Network</h3>\r\n\r\n<p>On top of qp2p sits the network overlay which forms the &lsquo;brain&rsquo; of the Safe Network. Its purpose is to create a decentralized Internet and route information between the Nodes.</p>\r\n\r\n<p>Network routing is based on an algorithm that extends Kademlia DHT routing (see Chapter 4). It uses 32-byte (256 bit) XOR addresses to locate data on the network. It is mathematically guaranteed that messages can be routed from any part of the network to any other destination.</p>\r\n\r\n<p>On the Safe Network, routing works on the principle of group consensus. For actions that mutate data or change the network a supermajority of the group of Nodes responsible for undertaking that action must first agree that it is valid.</p>\r\n<p> In order to guarantee strong consistency, the Network uses conflict-free replicated data types (CRDTs) for storing data, Byzantine Reliable Broadcast (BRB) for messaging, and Boneh-Lynn-Shacham (BLS) threshold cryptography to reach local consensus (See Chapter 7).</p>\r\n\t\t\r\n\t\t<p>Client connections managed by qp2p are mediated via the Client API. Sitting above that, the Safe Network API allows clients such as end user devices and apps to make use of the network, including storing, sharing and reading data. There is a command line interface (CLI) for this purpose, and apps written in Rust can access network functions directly via the API. Apps written in other languages, including the Safe Browser - a JavaScript app, do the same via the language bindings layer. </p> \r\n\r\n        <p>Nodes and Clients provide the main means for users to interact with the Network, either by providing resources in return for payment by running a Node or by storing data and browsing the Safe web as a Client. They are discussed further in the next chapter.</p>\r\n\r\n        <p>All Safe Network code is open source and licensed under GPLv3.</p>\r\n        <h3>Tell me more&hellip;</h3>\r\n\r\n   \r\n<p><a href=\"https://github.com/maidsafe/safe_network\"> The Safe Network Core. API message definitions, routing and nodes, client core API. (Github)</a></p>\r\n\r\n<p><a href=\"https://github.com/maidsafe/quic-p2p\"> quic-p2p - a peer-to-peer communications library for Rust based on QUIC protocol (Github)</a></p>\r\n\r\n\r\n <p><a href=\"https://docs.rs/quinn/0.7.2/quinn/index.html\"> Quinn - QUIC protocol in Rust</a></p> \r\n\r\n        <p>&nbsp;</p>\r\n\r\n     \r\n      \r\n        \r\n                \r\n    </div>\r\n\r\n);\r\n\r\nexport default component;\r\n","import React from 'react';\r\nimport app_auth_flow from '../images/app_auth_flow.jpg';\r\n\r\n\r\n\r\nconst component = () => (\r\n\r\n    <div className='chapter'>\r\n\r\n    \r\n<h2 id='ch3'>3. Nodes and Clients</h2>\r\n\r\n\r\n\r\n<p>The existing Internet is formed of servers and clients. Clients request data and servers provide it. When you browse the Web, you enter the address of the page into the browser (client software) and the browser requests data from the website in question which is stored on a specific server (server software).</p>\r\n\r\n<p>The Safe Network does not use a client-server model. Instead stored data is spread across a network made up of the spare computing resources of its users. When a request for some content is made, a message goes out across the Network and machines that hold the constituent parts of that content return them to the requester.</p>\r\n\r\n<p>Safe has two basic components: Nodes and Clients.</p>\r\n\r\n        <div className=\"Keep-it-simple\">\r\n\r\n \r\n\r\n<h3>Keep it simple!</h3>\r\n\r\n    <p>The Safe Network is comprised of its users' machines (Nodes) linked together by Node software which routes data and messages securely between them. These machines provide the Network's storage by allocating a portion of their hard drives for this purpose &ndash; and earning the Safe Network Token currency in return.</p>\r\n    <p>You don't have to run a Node to use the Network any more than you have to run a web server to use the Web. Client software allows users to create a Safe (a secure, private data store), store data and browse the Safe web securely and anonymously without being part of the Network. A single computer can run both Node and Client software at the same time.&nbsp;&nbsp; </p>\r\n</div>\r\n\r\n\r\n\r\n<h3>The Node</h3>\r\n\r\n<p>The Safe Network is formed of interconnected machines running Node software. Node software connects the devices to each other using existing protocols like TCP and UDP, manages data and routes it around the Network. It allows users to store data on their devices, potentially earning SNT currency in return. This process of providing a service in return for a reward is analogous to Bitcoin mining. On the Safe Network it's called Farming and the people who provide the resources are called Farmers (see Chapter 8).</p>\r\n\r\n<p>Node software is a small executable file that connects the user&rsquo;s machine to the Safe Network, turning it into a routing node and also allocating some disk space for storage. It manages the storage of data chunks on the user&rsquo;s computer and in that way provides storage capacity to the Network. It also routes and caches data chunks (these are encrypted) over the Network via fully encrypted connections to other Nodes. Nodes are clustered logically into small groups, each of which is responsible for looking after the data stored within a certain range of Network addresses, called a Section (see Chapter 4).</p>\r\n<div className=\"What-does-that-mean\">\r\n        <h3>What does that mean?</h3>\r\n\r\n        <p>quic-p2p/qp2p &ndash; a software library that allows machines to connect to each other in a secure and reliable peer-to-peer fashion and to reconnect after leaving without requiring a hard-coded list of other devices.</p>\r\n\r\n        <p>Node &ndash; the machines that make up the Safe Network run Node software. Nodes provide routing and communications capabilities to the Network and also store data in the form of chunks, for which they can earn Safe Network Token (Farming) when that data is retrieved.</p>\r\n\r\n        <p>Client &ndash; a program that allows users to connect to the network and make use of its services.</p>\r\n\r\n        <p>Safe &ndash; a secure store on the Network.</p>\r\n\r\n        <p>Safe Browser &ndash; a browser for surfing the Safe web.</p>\r\n\r\n            <p>CLI - command line interface for typing commands into a terminal rather than using a GUI.</p>\r\n        \r\n        <p>Self-Authentication - enables secure and anonymous connection to the Network without a central server to mediate the login process.</p>\r\n\r\n        <p>Farming &ndash; earning Safe Network Token by providing resources (Storage, Bandwidth, CPU, online time) to the Network</p>\r\n\r\n        <p>Safe Network Token &ndash; the currency of the Safe Network, earned by storing data, spent by uploading data.</p>\r\n\r\n        </div>\r\n\r\n        <p>The forming and splitting of Sections happens in a fully autonomous way as Nodes join and leave the Network. The same goes for the routing of chunks across the Network. There are no central servers, authorities or agents needed to maintain this Network (unlike, say, like BitTorrent which uses trackers).</p>\r\n\r\n<p>Nodes fulfil several different functions. They route and store chunks of data; they cryptographically check messages; they cluster into  Sections each of which manage a certain portion of the Network; and they take decisions about what should and should not happen, such as whether a new Node should be allowed to join the Network.</p>\r\n\r\n<p>Running a Node in the Safe Network is called Farming because users look after the data until it is needed, at which point they may earn payment for their efforts (see Chapter 8).</p>\r\n\r\n<h3>The Client</h3>\r\n\r\n<p>Just as you don&rsquo;t need to run a web server to use the Web, so you don&rsquo;t have to run a Node to access the Safe Network. Ordinary users interact with the network via the Client. Currently the Client software provided is the command line interface (CLI) tool. </p>\r\n\r\n<p>Self-Authentication is a key innovation of the Network. At no point does the Network ever store a user&rsquo;s credentials. Therefore, there is no chance of passwords being attacked on the Network. Instead, the user can create a Safe, a private data store, and login securely and anonymously with no central server required to mediate the login process or trusted third parties to store and manage the users’ credentials. With Self-Authentication, the user generates his or her own credentials which are stored on the Safe Network in such a way that they are cryptographically obscured from all other parts of the Network.</p>\r\n\r\n\r\n<p>Any user (even if they have not created a Safe) can request (GET) data from the network for free. For example, they can browse a safe:// site or download a publicly-posted song or movie for zero cost. It&rsquo;s only when the user wants to store (PUT) data onto the network that an account with Safe Network Token is needed.</p>\r\n<h3>Tell me more...</h3>\r\n<p><a href=\"http://www.enterprisenetworkingplanet.com/datacenter/datacenter-blog/on-the-verge-of-autonomous-networking.html\">On the Verge of Autonomous Networking (Enterprise Networking Planet)</a></p>\r\n<p><a href=\"http://docs.maidsafe.net/Whitepapers/pdf/AutonomousNetwork.pdf\">Autonomous Network (MaidSafe whitepaper, 2010)</a></p>\r\n<p><a href=\"https://github.com/maidsafe/safe_client_libs\">Safe Client libraries (Github)</a></p>\r\n<p><a href=\"https://github.com/maidsafe/safe-network-app\">Safe Network App (Github)</a></p>\r\n<p><a href=\"https://github.com/maidsafe/safe_browser\">Safe Browser (Github)</a></p>\r\n<p><a href=\"https://github.com/maidsafe/safe_browser\">Safe Mobile Browser (Github)</a></p>\r\n<p><a href=\"https://github.com/maidsafe/sn_cli#safe-network-cli\">Safe CLI User Guide -  a CLI (Command Line Interface) for the Safe Network (Github)</a></p>\r\n\r\n       \r\n    </div>\r\n\r\n);\r\n\r\nexport default component;\r\n","export default __webpack_public_path__ + \"static/media/app_auth_flow.35eb1829.jpg\";","export default __webpack_public_path__ + \"static/media/xor_addresses.f75d3162.jpg\";","import React from 'react';\r\nimport xor_addresses from '../images/xor_addresses.jpg';\r\n\r\n\r\n\r\nconst Chap4 = () => (\r\n\r\n    <div className='chapter'>\r\n        <h2 id='ch4'>4. The architecture of the Safe Network</h2>\r\n        <p>Browsing sites and storing data on the Safe Network is as simple as on the current Web but with greatly enhanced privacy, security and control. The Safe Network is designed with ease of use in mind for app developers, too. Developing simple apps for Safe is just a short step from what developers are familiar with in terms of APIs and methodologies. However, those wishing to perform more complex system-level tasks will need to go deeper into its architecture - there are some big differences between traditional client-server systems and decentralized architectures. This chapter provides a brief introduction to the topic.</p>\r\n        <h3>Sections</h3>\r\n        <p>The first step in understanding the architecture of the Safe Network is to take a look at distributed hash tables (DHTs).</p>\r\n        <p>Petar Maymounkov and David Mazi&egrave;res released the Kademlia distributed hash table in 2002. The idea is that nodes form a network overlay, and are identified with a different node identification system. So a node with an IP address of 96.251.182.97 might have a 256 bit XOR address that looks like this: 17846cb8a4b53c9e44c616d2415a15984283eee975a1dac8f488dd91d0aed1cd.</p>\r\n        <p>Bitwise Exclusive OR (XOR) has the feature that each address is a unique distance from any other address in the entire address range. XOR distance bears no relation to physical distance. Indeed, two pieces of data on the network may be very close XOR-wise but be sitting on machines located on opposite sides of the world.</p>\r\n        <p>MaidSafe developed an enhancement to Kademlia by splitting the 256-bit address range into so-called 'Disjoint Sections', or Sections for short. A 256-bit address space has 2<sup>256</sup> -1 possible addresses which is an extremely large number to manage, but it can be split up into smaller Sections based on address, with each Section being managed by a group of Nodes (also generally known as a Section).</p>\r\n        <p>The Nodes managing a Section must reach agreement (consensus) before authorising any mutation (Network-changing event) happening within that Section. As a collective, they can also provide ‘section authority’ to messages that travel over the wider Network so that other Nodes and/or Sections can cryptographically verify the validity of the message and the action it contains. These Section signatures are stored in ‘SectionChains’ which are secured and held by members of that Section, and by neighbouring Sections. This is known as group agreement (or local consensus).\r\n</p>\r\n        <div className=\"What-does-that-mean\">\r\n            <h3>What does that mean?</h3>\r\n            <p>Distributed hash table &ndash; a map of where data is stored on a distributed network.</p>\r\n            <p>XOR networking &ndash; a way of randomizing the physical location of data on a distributed network and ensuring each location is unique.</p>\r\n            <p>Section &ndash; a subset of addresses on the network. The word Section is also applied to a group of Nodes that manage a subset of addresses.</p>\r\n            <p>Supermajority &ndash; larger than a simple majority, so e.g 5 out of 7 rather than 4 out of 7.</p>\r\n            <p>Elders &ndash; Nodes with decision-making powers, the oldest 7 Nodes in a Section (see Chapter 5).</p>\r\n\t\t\t<p>Adults &ndash; Nodes that perform storage duties but do not take decisions (see Chapter 5).</p>    \r\n            <p>Infants &ndash; Nodes waiting to join the Network but not yet accepted.</p>       \r\n            <p>Agreement &ndash;  when the required proportion of decision-making Nodes (Elders - see Chapter 5) in a Section vote an event to be valid.</p>\r\n            <p>group_size &ndash; a parameter stipulating the minimum number of Elders in a Section (currently set at 7).</p>\r\n            <p>Bootstrapping &ndash; starting up the Safe Network by connecting together a minimum number of Nodes. Bootstrapping is also used to describe a new Node joining the Network.</p>\r\n            <p>Bootstrap node &ndash; a node to which a new Node initially connects. Any Node can potentially be a bootstrap node, so long as its IP address is written in the Node&rsquo;s configuration file, or, for subsequent connections, its cache. </p>\r\n            <p>Hash function &ndash; a function used to map data of arbitrary size to data of fixed size (e.g. a 256-bit string of characters) called a hash. Any change to the original data will result in a completely different hash. Safe uses the SHA-3 hash function.</p>\r\n            <p>SectionChain &ndash; a sequence of public keys, each signed by the previous one, that's updated every time an Elder is changed and acts as proof that the Section is valid.</p>\r\n            <p>Sharding &ndash; on Safe Network this refers to the splitting of the Network into individual sections, each managed by a unique Group of Nodes.</p>\t\t\r\n        </div>\r\n       <p>Importantly, on joining or rejoining the Safe Network a Node cannot simply pick its own XOR address - in other words, it can&rsquo;t choose the Section it will be part of. Instead, it has to wait to be allocated to a Section that is chosen by the Network. When this occurs, the Node receives the Section's Routing Table and learns the exact unique address range (and therefore the data) that it will be responsible for.</p>\r\n        <p>Content stored on the Safe Network is first broken into chunks, hashed and then encrypted (see Chapter 6). Those chunks are run through a hashing algorithm to create a unique 256-bit hash for each chunk. Only chunks that are exactly identical will have the same hash value. This hash serves as the XOR address on the Network where that chunk will be stored, which in turn determines the Section that will manage it.</p>\r\n        <p>Chunks with hashes that lie within a certain address range (say 000010... to 000011...) will be secured, stored and managed by the Section that is closest (in XOR terms) to that address. The membership of this Section will change over time as new Nodes join and others leave.</p>\r\n        <p>When the Network starts up, the initial Nodes are responsible for the whole 256-bit address range. But as more Nodes join the Network will split into two Sections. As still more Nodes join, the Sections will continue to split, each managed autonomously by its Elders (Nodes with decision-making powers, see Chapter 5). This is known as &lsquo;Sharding&rsquo; and is a crucial part of the way in which the Network solves the challenges of scalability.</p>\r\n        <p className=\"Pullquote\">\"The hash of a chunk of data serves as the XOR address on the Network where it will be stored, which in turn determines the Section that will manage it\"</p>\r\n        <div className=\"Full-width-pic\" align=\"center\">\r\n\r\n            <img className=\"Img\" src={xor_addresses} alt=\"Networking layers\" width=\"70%\" align=\"center\" />\r\n        </div>\r\n        <p><em>Each Section (range of XOR addresses) is managed by a group of Nodes. The most trusted Nodes in a Section are called Elders. Elders have voting rights and can also communicate with Elders in other Sections.</em></p>\r\n        <p> Experiments are ongoing to find the optimum number of Nodes per Section, but it will probably be around 100.</p>\r\n        <p>If a particular Section grows significantly in the eyes of the Network, it will split into two smaller Sections. </p>\r\n        <p>\r\n            If a Section finds its membership dropping below a certain limit (group_size) then it requests that Nodes be relocated to it earlier or that it has priority for Infant nodes joining the network. Given these balancing mechanisms is extremely unlikely that a Section will become too small (~7 nodes) to be viable.</p>\r\n\r\n\r\n   \r\n\r\n        <h3>Agreement</h3>\r\n        <p>The Elder Nodes managing a Section must reach consensus among themselves on Network events under their control before they can happen. They also ‘Section-sign’ messages that travel over the wider Network. Elders in Sections receiving these messages need to be sure they are from valid Sections. Because Section membership is fluid, every time it changes (Elder churn) a new public key is created and signed by the current Elders using the previous key. This series of public keys, each signed by the previous one is called a SectionChain and serves to prove the validity of the Section (See BLS-DKG, Anti-Entropy, Chapter 7). </p>\r\n\r\n        <p>SectionChains allow Section authority to be baked into the data management process, providing a simple decentralized record of which Section signed which data.</p>\r\n\r\n        <div className=\"Keep-it-simple\">\r\n            <h3>Keep it simple!</h3>\r\n            <p>In order for something to occur in their Section that might alter it, the Elder Nodes must first agree that the action is valid. A supermajority (at least 5 out of 7 votes) is required. If agreement is not reached, the actor requesting the change - say, trying to write data to the Network - must try again.  </p>\r\n        </div>\r\n       \r\n\r\n\r\n        <p className=\"Pullquote\">\"No node in the Safe Network has a complete overview of the network\"</p>\r\n        <p>The closer a Node is to a certain address space on the Safe Network, the more information it has about data that is stored at that address. And logically, the further away a Node is, the less information it has. The bigger the Network becomes, the more secure it will get because an individual Node will have influence over a decreasing range of addresses.\r\n                </p>\r\n        <p>An action or event happening in a Section is only valid once a supermajority of Elders (5 out of 7) has approved it. </p>\r\n       \r\n        <h3>Tell me more...</h3>\r\n        <p><a href=\"http://www.globule.org/publi/SDST_acmcs2009.html\">A Survey of DHT Security Techniques (Globule)</a></p>\r\n        <p><a href=\"https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf \">Kademlia: A Peer-to-peer information system based on the XOR Metric (Whitepaper, 2010)</a></p>\r\n        <p><a href=\"http://docs.maidsafe.net/Whitepapers/pdf/MaidSafeDistributedHashTable.pdf \">Distributed Hash Table (MaidSafe Whitepaper, 2010)</a></p>\r\n        <p><a href=\"http://docs.maidsafe.net/Whitepapers/pdf/DHTbasedNATTraversal.pdf \">DHT-based NAT Traversal (MaidSafe Whitepaper)</a></p>\r\n        <p><a href=\"https://en.wikipedia.org/wiki/Disjoint-set_data_structure \">Disjoint-set data structure (Wikipedia)</a></p>\r\n        <p><a href=\"https://github.com/maidsafe/rfcs/blob/master/text/0037-disjoint-groups/0037-disjoint-groups.md \">Disjoint Sections (MaidSafe RFC)</a></p>\r\n<p><a href=\"https://safenetforum.org/t/fast-ephemeral-routing/32173\">Fast Ephemeral Routing (RFC and discussion, introduces concept of SectionChains)</a></p> \r\n\r\n       \r\n\r\n\r\n\r\n\r\n        </div>\r\n\r\n\r\n);\r\n\r\nexport default Chap4;\r\n","export default __webpack_public_path__ + \"static/media/nodes_journey.7bf35734.png\";","import React from 'react';\r\nimport nodes_journey from '../images/nodes_journey.png';\r\n\r\n\r\n\r\nconst Chap5 = () => (\r\n\r\n    <div className='chapter'>\r\n        <h2 id='ch5'>5. Node Age</h2>\r\n\t\t\r\n\t\t<p>Node Age is a measure of how long a Node has been a reliable participant in the Network. It dictates the activities the Node can carry out and ultimately how much it will be paid (Chapter 9) </p>\r\n\t\t\r\n\t\t<p>There are three categories of Node. Infants are Nodes waiting to join a Section, Adults are responsible for storing data and giving it up speedily on request, and Elders are the decision makers. In the current design there are seven Elders per Section and around 100 Adults.</p>\r\n        \r\n        <p>When a Node first joins the Network as an Infant, it first needs to discover the IP addresses of some existing Network participants. At launch, MaidSafe will temporarily provide a small number of bootstrap nodes (Internet-connected machines running the Node software). The IP addresses of these bootstrap nodes are included in the new Node's configuration file. Alternatively, if the Node owner already knows the IP addresses of some Nodes on the Network, for example machines run by a friend, these may be used instead. Through those bootstrap nodes it can connect to other known Nodes in the Network. The connection itself is fully encrypted (with the randomly-generated public keys of all valid Nodes being stored on the Network) and that initial connection is dropped immediately after the first hop once the new Node has connected to others in the Network.</p>\r\n\t\t\r\n        <div className=\"Keep-it-simple\">\r\n        <h3>Keep it simple!</h3>\r\n        <p>Just as children are not allowed to vote in elections, so a Node may not vote on Network events - such as whether a new member is allowed to join or whether a Section should split - until it has proven itself to be reliable. A Node gains trust each time it moves to a new Section whereupon its Node Age increases by 1. Once it is among the oldest in its Section (in terms of Node Age), it may be given voting rights as an Elder. Forcing Nodes to prove themselves in this way is an important security measure.</p>\r\n        </div>\r\n        <p>A new Node connects to other Nodes over the qp2p layer, sending out a message to a network Elder whose IP address it knows or is in its config file saying it wants to join. At this stage the Infant Node has a Node Age of zero. It is not permitted to join the network until it is needed by the section of which the Elder is a part (say Section X).</p>\r\n\r\n\t\t<p>A supermajority of Elders in Section X must agree that a new Node is needed before it is allowed to join. When they do, the Elders send out a Resource Proof request which forces the Infant Node to prove that it can perform a simple task (a proof of work).</p>\r\n\t\t\r\n\t\t<p>After being accepted by Section X, the Node becomes an Adult with a Node Age of 5, and resides there for a number of churn events, roughly proportional to 2^age (i.e. 2^5). The starting value of 5 is thought to offer a reasonable balance between limiting strain on the network caused by rapid relocations and safety - the Node will have very little opportunity to act maliciously in the Section before it is relocated. This value may change with more testing. Section X will not accept any new joining Nodes until the relocation has taken place.</p>\r\n\t\t\r\n   <p>After a certain amount of time our Adult Node is relocated to another section, Section Y, selected as being closest to the hash of the Node's ID (public key). Section Y must accept the new Node because relocation requests have Network Authority, meaning it is to be trusted (see Chapter 9) Before being relocated to Section Y the Node’s age is increased from 5 to 6, meaning it will remain in Section Y for a longer time  - proportional to  2^6. So long as it proves itself reliable in Section Y, the Node's age will be upped to 7, it will be given a new ID and it will be relocated to Section Z, where it will remain for a time proportional to 2^7 … and so on. </p>\r\n   \r\n      <p>The process of increasing Node Age is exponential. The older the Node is the longer it must prove itself before it can increase its age. Newer Nodes are more likely to be moved to a new Section -  and thus increment their Node Age - than older, more trusted ones are. When it is the seventh oldest Node in the Section, it may be promoted to an Elder.</p>\r\n   \r\n   <p>Nodes can be demoted too. If trust is lost it must be re-earned. If the Adult Node restarts or misbehaves, it will be relocated to a new Section with its age halved. If it is found to be less than half as responsive as its neighbour(s) in dealing with requests to store or release data, it will be ejected from the Network and will need to start again as an Infant. </p>\r\n   \r\n   \r\n   <p>If an Elder proves unreliable, it will also be demoted to an Adult or ejected by the other Elders, following a similar mechanism, with the oldest Adult in the Section promoted to Elder status in its place.</p>\r\n   \r\n\r\n      \r\n   \r\n        <p>Because only Nodes that have proved their value to the Network can vote, it is close to impossible for&nbsp; an attacker to target a particular Section on the Safe Network. Node Ageing and churn (nodes swapping Sections) are thus vital security features.</p>\r\n        <p>Only the most trusted Nodes in a Section, those Nodes with the greatest Node Age, become Elders. Other Nodes (Infants, Adults) simply receive notification of their decisions.</p>\r\n        <div className=\"Full-width-pic\" align=\"center\">\r\n\r\n            <img className=\"Img\" src={nodes_journey} alt=\"Node's journey\"  align=\"center\" />\r\n        </div>\r\n        \r\n        <div className=\"What-does-that-mean\">\r\n        <h3>What does that mean?</h3>\r\n            <p>qp2p &ndash; a networking library that enables peers on a P2P network to communicate securely, and to re-join the network without requiring a hard-coded list of known peers.</p>\r\n        <p>Resource Proof &ndash; a test of bandwidth and CPU power. If a Node trying to join the Network fails the test or takes too long to return it, it will not be allowed to join.</p>\r\n        <p>Node Age &ndash; a measure of the trustworthiness of a Node. After the initial connection, a Node gets moved at random from Section to Section, building its reputation or Node Age. Once its Node Age reaches a certain value it can be an active participant in the decisions of the Section as an Elder.</p>\r\n        <p>Churn &ndash; the act of Nodes leaving a group or new Nodes joining. Churn means that Sections are not static for long.</p>\r\n        <p>Elder &ndash; a node with voting rights in its Group. Elders are simply those nodes with the greatest Node Age in the Group.</p>\r\n        <p>Adult &ndash; a node that has no voting rights but can store data.</p>\r\n        <p>Infant &ndash; a node that has recently joined the Network. It has no voting rights and cannot store data.</p>\r\n        </div>\r\n        <h3>&nbsp;Tell me more...</h3>\r\n       \r\n        <p><a title=\"Introduction &amp; Technical Overview of Safe Consensus\" href=\"https://blog.maidsafe.net/2016/06/23/introduction-technical-overview-of-safe-consensus/\">Introduction &amp; Technical Overview of Safe Consensus (MaidSafe blog, 2016)</a></p>\r\n     \r\n        <p><a href=\"http://conferences.sigcomm.org/imc/2006/papers/p19-stutzbach2.pdf\">Understanding Churn in Peer-to-Peer Networks (Sigcomm, Research paper, 2006)</a></p>\r\n        <p><a href=\"https://safenetforum.org/t/node-ageing-rfc/11377/1\">Node Ageing RFC (and forum discussion)</a></p>\r\n\r\n       \r\n    </div>\r\n\r\n);\r\n\r\nexport default Chap5;\r\n","export default __webpack_public_path__ + \"static/media/password-passphrase.8557f476.jpeg\";","import React from 'react';\r\nimport password_passphrase from '../images/password-passphrase.jpeg';\r\n\r\n\r\n\r\nconst Chap6 = () => (\r\n\r\n    <div className='chapter'>\r\n        <h2 id='ch6'>6. Encryption and authentication</h2>\r\n        <p>Content on the Safe Network is stored as encrypted chunks. The original content can be recreated from these chunks provided we have a map of where the chunks are plus the keys to decrypt them. A 'file' on the Safe network is really a structure containing some metadata, such as the file name plus a Data Map which points to the location of the chunks. Files are kept in folders which are created as part of the Self-Encryption process (see below) and are encrypted, meaning their contents are only accessible to their owner by default. However, in the case of public content they are not encrypted meaning the files are accessible.</p>\r\n        <p>The API makes it impossible to upload unencrypted (plain text) content to the network.</p>\r\n        <div className=\"Keep-it-simple\">\r\n        <h3>Keep it simple!</h3>\r\n            <p>All content on the Safe Network is encrypted by default. When a content is stored on the Network it is first broken into chunks, hashed and then encrypted and these chunks are themselves encrypted using the hash of another chunk from the same file. This is Self-Encryption - a method patented by MaidSafe but now open-sourced. When content is made public it's containing folder is decrypted, meaning anyone can reassemble the chunks.</p>\r\n            </div>\r\n        <p>At the network level, the Safe Network uses the TCP, UTP and &micro;TP protocols and all the data moved by these protocols is encrypted from 'bit 1'. This means that the first connection to the Safe Network that a Node or Client makes is to a bootstrap server, one of a number of temporary servers run by MaidSafe to allow new machines to join. The randomly generated public keys for these bootstrap servers are retrieved from the network by the Client, so communications between the Network and the user are always encrypted, never in plain text. Note that any Node on the Network can be used as a bootstrap server so long as its IP address is added to the configuration file of the joining Node. It <em>does not</em> have to be one provided by MaidSafe. </p>\r\n        <p>Clients and Nodes in the Network get a list of IPs and public keys of other users to connect to. These connections are also encrypted from bit 1. </p>\r\n        <h3>Clients connect anonymously</h3>\r\n        <p>To ensure anonymity, the identity of a Client connecting to the Network must be hidden from the Nodes that comprise it. For this reason, the initial connection between a Client and a Node is a two-step process. First it connects via IP to a Node whose IP address is in its config file or cache. This Node knows the Client's IP address and will allow it to connect to a Section via a Section Elder's XOR address. After relocation to a new Section (Chapter 5), that initial Node has no connection with the Client and cannot track its activities. The Nodes in the new Section cannot see the Client's IP address but they know its public key and XOR address. All connections between the Client and the Section(s) are fully encrypted.</p>\r\n       \r\n        <h3>Self-encryption of content</h3>\r\n        <p>All content (documents, images, videos, etc) on the Safe Network is encrypted. When a Client uploads a piece of content to the Network (for example an mp4 video) it is first broken into chunks and those chunks are then Self-Encrypted, a process patented by MaidSafe by which each chunk is encrypted using its own hash and the hashes of the two previous chunks in the same file. These encrypted chunks are then hashed again to arrive at the XOR address where the chunk will be stored. At the same time a Data Map is created on the Client device, which maps the chunk number to the XOR address of the chunk and the hash to decrypt it and its two successors, allowing the content to be recreated. A number of copies of each chunk are stored by Nodes in the Section to ensure redundancy.</p>\r\n        <p>Data Maps and other metadata are not encrypted, but on the network they are kept inside encrypted folders if the data is private.</p>\r\n        <p>The Client retains the Data Map for the content it has uploaded and keys to decrypt it locally. That way no keys or passwords need ever leave a person's device. Users can choose to share content with others by sharing their keys / Data Map with them. They can also choose to make the content fully public, in which case the folders containing the relevant files are unencrypted.</p>\r\n        <div className=\"Pullquote\"><p>\"The Safe Network provides a platform for applications that is both highly secure and anonymized by design\"</p></div>\r\n        <h3>Multilayered encryption</h3>\r\n        <p>The Safe Network uses several layers of encryption to protect a user's anonymity and privacy. Several extra layers are active when people use direct messaging or create a public profile. The Network is designed to be as 'zero-knowledge' as possible, to the extent that Farmers cannot possibly figure out what chunks from which private file they are storing - even if it's their own. By utilizing multiple levels of encryption as well as obfuscating the identity of its users after the first hop, the Safe Network provides a platform for applications that is both highly secure and anonymized by design.</p>\r\n        <h3>BLS-DKG</h3>\r\n        <p>Safe uses Boneh-Lynn-Shacham Distributed Key Generation (BLS-DKG) to secure the Elder voting process and to authenticate messages passed between Sections. BLS-DKG is a threshold cryptographic system, meaning that authorization is only given once a predefined number of key shares have been received and combined to create a valid key. If 5 out of 7 Elders (a supermajority) each return a key share indicating that they have voted for an event then it is valid without requiring the other 2 to do so, i.e. it is Byzantine Fault Tolerant. BLS-DKG is covered in more detail in Chapter 7.</p> \r\n      \r\n        <h4>Safe credentials</h4>\r\n        <p>BLS-DKG is useful in other areas too, including helping users handle their authentication credentials. </p> \r\n        <p>A Safe is the term used to describe a place on the Network for the user's private data, and the act of creating a Safe is really the act of creating some credentials, with which to 'unlock' the Safe. </p>\r\n        <p>Credentials are thus extremely important, but credential loss can be a serious problem on decentralized networks where there is no central authority to help recover or reset forgotten passwords. The temptation may be to choose simple credentials that are easy to remember, but these will likely be insecure (easily guessed or cracked) and prone to collisions - other people may choose the same ones and inadvertently stumble upon the user's private information.</p>\r\n        <p>The Safe Network requires at least two separate credentials, generally referred to as 'access keys', with the option to add more. In combination, these access keys must have sufficient entropy (randomness) to make collisions vanishingly unlikely.</p>\r\n        <p>Creating a Safe for the first time requires the user to choose a password (the first access key) from which a second access key is generated in the form of a passphrase (12 random words with a checksum in the style of BIP39), which the user writes down, perhaps keeping copies in a few safe places. With these two access keys, we have <strong>something you know</strong> (the password), and <strong>something you have</strong> (the passphrase), and in combination, we can generate a suitable amount of entropy to avoid collisions. This is the minimum requirement for creating a Safe.</p>\r\n            <div className=\"Full-width-pic\" align=\"center\">\r\n\r\n<img src={password_passphrase} alt=\"password-passphrase\" width=\"70%\" align=\"center\" />\r\n</div>\r\n\r\n        \r\n<p>The user may also choose to create a third access key, a device key, on a trusted smartphone or computer, which is where BLS-DKG comes in, enabling a 2-of-3 key scheme. </p>\r\n<p>Now instead of requiring the passphrase, on this trusted device the user can just use the password and the device key, maybe utilising some inbuilt biometrics too, for an element of <strong>something you are</strong>.</p>\r\n        <p>Additional access keys can be created to provide more flexibility and resilience. A backup passphrase is one example, and additional devices can be set up too. Then if the user forgets the password or loses a device, a combination of another device and or passphrase will allow the password to be reset. </p>\r\n        <p>In this way Safe Network caters for people with security needs ranging from the everyday to the extreme.</p>\r\n       \r\n\r\n        <div className=\"What-does-that-mean\">\r\n        <h3>What does that mean?</h3>\r\n        <p>Self-Encryption - Content uploaded to the Safe Network is broken up into chunks. These chunks are then hashed, encrypted locally using the AES-256 encryption algorithm and the hashes of neighbouring chunks. Because content is encrypted and decrypted locally, there is no need for keys to leave the user's machine.</p>\r\n        <p>File &ndash; contains instructions for recreating content from encrypted chunks.</p>\r\n\r\n        <p>Folder &ndash; container for files and other folders. Unencrypted for public data.</p>\r\n            <p>Data Map &ndash; a record of content chunks and their corresponding locations on the Network. Only those in possession of the Data Map can recreate the file. </p>\r\n            <p>BLS-DKG &ndash; a cryptographic system that authenticates the sender of a message, allows for multiple parties to quickly come to a consensus, and can enable multi-signature transactions and n-of-k credentials </p>\r\n            <p>Byzantine Fault Tolerance &ndash; the ability of a decentralized network to function properly even if up to a third of the nodes (plus 1) is corrupt or faulty. </p>               \r\n            <p>n-of-k &ndash; if you have k different credentials you need at least n of them to proceed, e.g. 2 out of 3 keys required to unlock a Safe. </p>            \r\n            <p>Safe &ndash; a private data store on the Network. </p>\r\n            <p>BIP39 &ndash; Bitcoin Improvement Proposal 39, creates a random-looking set of words which are processed to generate cryptographic keys.</p>\r\n            </div>\r\n        <h3>Tell me more...</h3>\r\n        <p><a title=\"sodium\" href=\"https://github.com/maidsafe/rust_sodium\" target=\"_blank\" rel=\"noopener noreferrer\" >Connecting to the Sodium crypto library</a></p>\r\n        <p title=\"Crypto 101 \"><a title=\"Crypto 101 \" href=\"https://www.crypto101.io/ \" target=\"_blank\" rel=\"noopener noreferrer\" >Crypto 101&nbsp;</a></p>\r\n       \r\n      <p><a title=\"Self encrypting files\" href=\"https://github.com/maidsafe/self_encryption\">Self encrypting files (convergent encryption plus obfuscation) (GitHub)</a> </p>\r\n        <p><a title=\"Self Encryption\" href=\"https://www.youtube.com/watch?v=Jnvwv4z17b4\" target=\"_blank\" rel=\"noopener noreferrer\" >Self Encryption on the Safe Network (YouTube)</a></p>\r\n        <p><a title=\"Self-encrypting Data\" href=\"http://docs.maidsafe.net/Whitepapers/pdf/SelfEncryptingData.pdf\" target=\"_blank\" rel=\"noopener noreferrer\" >Self-encrypting Data (MaidSafe Whitepaper)</a></p>\r\n        <p><a title=\"UDP Hole Punching \" href=\"https://github.com/maidsafe/rfcs/blob/04f276056bf909f415b47ae341b16ce78af0c7a4/text/0008-udp-hole-punching/0008-udp-hole-punching.md\" target=\"_blank\" rel=\"noopener noreferrer\" >UDP Hole Punching (MaidSafe RFC) </a></p>\r\n        <p><a title=\"bip39 \" href=\"https://iancoleman.io/bip39/\" target=\"_blank\" rel=\"noopener noreferrer\" >BIP39 Mnemonic Code Converter  </a></p>\r\n       \r\n    </div>\r\n\r\n);\r\n\r\nexport default Chap6;\r\n","import React from 'react';\r\n\r\n\r\n\r\nconst Chap7 = () => (\r\n\r\n    <div className='chapter'>\r\n        <h2 id='ch7'>7. Network-wide consensus not required</h2>\r\n  \r\n        <h3>A hard problem</h3>\r\n  \r\n        <p>Truly decentralized networks can have no master node or oracle to judge what is true or valid and what is not. Instead, the nodes that make up the Network must come to an agreement among themselves about which of many possible versions of &ldquo;the truth&rdquo; they will accept.</p>\r\n  \r\n        <p>Discrepancies can arise for many reasons, but a frequent cause is the physical distance between nodes. As an example, let&rsquo;s say node Alice in Sydney relays a message to node Bob in Edinburgh. Before the signal can travel halfway around the world, node Carol in London transmits a different message to Bob. Because London is much closer to Edinburgh, Carol's message arrives before Alice's, even though it was sent later. Without a central time-clock, how can we decide which is the correct order of events? </p>\r\n  \r\n        <p>In our example, the nodes that make up the network must vote on which message - Alice's or Carol's - they will accept as being sent first, based on information about the two events that each has received. What&rsquo;s more, the Network must account for the fact that a certain proportion of the nodes may be unreliable or even actively malicious and yet still converge on one rules-based version of the truth. This is called Byzantine Fault Tolerance (BFT). The way the maths works out, up to one-third of the nodes could be corrupt (Byzantine) and a BFT network will still function reliably. (If more than a third are corrupt, BFT becomes mathematically impossible according to current theory.)</p>\r\n  \r\n        <h3>Proof of Work</h3>\r\n  \r\n        <p>The Bitcoin blockchain uses Proof of Work (PoW) to solve these problems of achieving decentralized consensus over the ordering of events to prevent the problem of double-spend &ndash; being able to spend the same coin twice &ndash; and Byzantine behaviour. Miners battle to verify a block of transactions. If there are two simultaneous winners the chain will split and for a time there are two versions of the truth, i.e. two chains emanating from the disputed block. Ultimately, though, after a few blocks have been added one chain will be longer than the other, and it is this chain that will be accepted as the true state. The failed blocks go back into the pot to be verified again. This is how the Bitcoin blockchain (and most other blockchains) achieves consensus. This mechanism also offers a defence against the 51 percent attack (see Chapter 12).</p>\r\n  \r\n        <p>Since miners are (ideally) independent operators distributed all over the world, and because it takes a lot of energy to verify a block, it is extremely difficult and expensive to deliberately influence the growth of one sub-chain over another. Difficult but not impossible: if one miner or mining group manages to consolidate more than half of the mining power, that miner can then spend some Bitcoin, split the chain and then grow the sub-chain that does not contain the transaction. Effectively this rogue miner is rewriting history. Once that sub-chain is accepted as &lsquo;the truth&rsquo; the original transaction officially never happened according to the ledger, and the miner is free to spend the coins again.</p>\r\n        <p>This is the Sybil attack, also known as the 51 percent attack because it becomes possible when one entity owns more than half of the mining power.</p>\r\n        <p>While such attacks have been successfully launched against some cryptocurrencies, Ethereum Classic being one example, Proof of Work has generally been rather effective in protecting against 51 percent attacks and at achieving BFT consensus across the network. But it is slow, massively energy-intensive and it doesn&rsquo;t scale. Also, the consensus is probabilistic rather than deterministic: after some time, you might be 99.9 percent sure that all nodes agree on network state, but never 100 percent.</p>\r\n        <p>The Safe Network does not use a blockchain or PoW for consensus. Instead it uses a combination of lightweight mechanisms that together achieve the same goal, including Boneh-Lynn-Shacham Distributed Key Generation (BLS-DKG), Byzantine Reliable Broadcast (BRB) and Conflict-free Data Types (CRDTs).</p>\r\n\t\t\r\n        <h3>Boneh-Lynn-Shacham Distributed Key Generation</h3>\r\n\r\n        <p>BLS-DKG is a cryptographic signature scheme that allows the recipient of a signed message to verify with certainty that the sender is authentic since there can only ever be one valid signature for any public-key&ndash;message combination. This is obviously extremely useful in a decentralized network where there is no central source of authority and only a limited amount is known about other players. The 'distributed key generation' (DKG) part of the name refers to the fact that a certain number of parties (a threshold) must participate in generating a public&#8211;private key pair, with the private key split up and distributed between them. Since they each hold a part of the private key, all parties must also participate in order to decrypt a message encoded with the public key, making BLS a great fit for Elders voting on decisions in a Section, or indeed for multisig transactions where more than one signature is required before payment.</p>\r\n\r\n        <p>BLS-DKG has other desirable properties too, including small-sized keys and signatures which make for efficient and fast operations and it can operate asynchronously. In short, it is a quick, secure and reliable way to obtain agreement in certain circumstances without having to rely on a full ABFT consensus algorithm. </p> \r\n\r\n        \r\n        <div className=\"What-does-that-mean\">\r\n        <h3>What does that mean?</h3>\r\n        <p>Byzantine Fault Tolerance &ndash;  the ability of a decentralized network to function properly even if up to a third of the nodes (plus 1) is corrupt or faulty.</p>\r\n        <p>Byzantine Reliable Broadcast &ndash;  A pattern used by the Safe Network that forces the requester to do the work of obtaining authority from the network before it can make a change. </p>\r\n        <p>Asynchronous &ndash; Not time-dependent. A system that supports asynchronicity should come to consensus no matter what order the various messages arrive in.</p>\r\n        <p>Proof-of-Work &ndash; the consensus algorithm used by the Bitcoin blockchain to confirm that transactions are valid and to deter attacks.</p>\r\n        <p>BLS-DKG &ndash; a cryptographic system that authenticates the sender of a message, allows for multiple parties to quickly come to agreement, and can enable multi-signature transactions.</p> \r\n        <p>CRDTs &ndash; Data structures that obey certain mathematical rules which ensure that when multiple versions of data exist across a distributed network, eventually these will always converge onto one 'true' version.</p>\r\n        <p>Anti-Entropy &ndash; A way of preventing a Section from making changes while its membership is in a state of flux.</p>\r\n        <p>Malice Detection &ndash;  detecting and ejecting nodes that are acting suspiciously.</p>\r\n     </div>\r\n\r\n\r\n\t\t<h3>Byzantine Reliable Broadcast </h3>\r\n\t<p>Byzantine Reliable Broadcast guarantees that all processes in a distributed system deliver the same set of messages, even if up to a third are Byzantine (unreliable or malicious). In the Safe Network its use allows us to force the requester to do the work of obtaining Section Authority. The requester (say, a Client wanting to store a data chunk) is responsible for aggregating the individual signature shares from the Elders in a Section to create a SectionSignature, after which the requested operation becomes valid and can be resubmitted to the Section.</p>\r\n       \r\n        <p>The BRB setup adopted by Safe Network derives from the AT2 distributed networking ABFT algorithm, which supports simple cryptocurrency transactions without needing network-wide consensus. However, the Safe Network does not use AT2 for such transactions, it uses DBCs instead (see Chapter 8).</p> \r\n\r\n        <p>The Safe Network uses BRB to quickly enforce consensus at a Section-wide rather than a Network-wide level, and to push a lot of the work involved onto the Client. So if a Client wants to store or alter data held by a Section, it asks the Elders to sign an agreement. The Elders check the logic and then each sends back a signed agreement (a BLS key share). The Client collects these key shares and once a supermajority has arrived (say 5 out of 7 Elders agree) it is a valid key and sends its request plus the key back to the Elders. The Elders now see a valid message \"Please deduct from my account the sum of X\" and carry out the command. The Client can perform this task of aggregating votes much more efficiently than the Elders, who would otherwise have to come to agreement between themselves via a resource-intensive consensus mechanism.</p>\r\n        \r\n        <p>If the Client tries to talk to only a few Elders or to the same Elder twice it will fail to gather sufficient votes.</p>\r\n\r\n     \r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t<h3>Anti-Entropy</h3>\r\n\t\t<p>A major hurdle that any decentralized network which will experience churn must overcome is keeping the nodes up to date with the network’s current state. Who has joined and who has left? Who are the current Elders in any given section? Elders are by definition relatively dependable and churn amongst them is minimal, but Safe Network is asynchronous and communications between section Elders and external actors may be few and far between. The Elders in a section may have churned many times between contacts and the external actor's information may be out of date.</p>\r\n\r\n<p>It’s vital actors wishing to make changes on the network have an up-to-date ‘understanding’ of the section before they are allowed to do so, otherwise data could be written to Elders that no longer exist.</p>\r\n\r\n<p>Entropy, or disorder, is a characteristic of a constantly changing network. We cannot reduce it but we can wait for periods of stability among Elders before allowing a change in their Section. Anti-Entropy (AE) is the mechanism for doing this. AE forces all Nodes that want to perform data operations on the network to prove the information they hold on the Network structure is up to date (see Chapter 9).</p>\r\n\r\n\r\n    \r\n        <h3>Conflict-free Replicated Data Types (CRDTs)</h3>\r\n        \r\n           \r\n        <p>There's another way to ensure consistency asynchronously across a decentralized network without consensus: CRDTs. With CRDTs consistency is inherent in the data structure itself. If different versions of the same data exist across a set of connected nodes (or replicas as they are known in CRDT-speak), they will all eventually converge on the same state. If some data is changed on an offline replica, as soon as connection is re-established this change will propagate to all other replicas, even if the same data was changed on another replica in its absence. At the end of the process, everyone will have the exact same version.</p>\r\n        <p>At the start of this chapter we mentioned the problem of users sending messages from different places and the difficulty of agreeing their order. With CRDTs it is not necessary to try to enforce an order or agree on it before changes can be applied. If Bob sees Alice's message before Carol's then that's the order that will be replicated around the network. No questions asked. If Bob receives Alice's and Carol's messages at exactly the same time he just picks an order randomly (A-C or C-A) and all replicas will accept that as the correct state.</p>\r\n        <p>CRDTs can range from simple counters to more complex structures, such as documents on which many people collaborate. Because CRDTs follow a strict set of rules based on metadata contained within their structure, conflicts (i.e. the persistence of multiple states of the same data) are automatically avoided without any special code or user intervention required.</p>\r\n        <p>Not every data structure can be a CRDT, but where it's possible it makes the job of ensuring consistency significantly easier. Changes can be made locally to CRDTs in complete confidence that they will be valid whatever may be happening elsewhere. This combines well with the AT2-type process described above: the Client can only request changes to CRDT data that are valid and once these have been approved by a quorum of Elders they cannot fail. Once again, this takes strain off the network.</p> \r\n        <p>On the Safe Network mutable data types are being formatted as CRDTs (see Chapter 10).</p>    \r\n\r\n        \r\n        <div className=\"Keep-it-simple\">\r\n            <h3>Keep it simple</h3>\r\n            <p>Voting nodes (Elders) need to be able to agree on the current state of the network, even if there are many different possible versions so that operations are carried out consistently. However, many typical operations - paying for data to be stored, transfering funds, editing data - can be performed locally requiring only that the operation is consistent with the data type and Network logic, that it has been approved by a certain number of Elders, and that if other Sections need to be involved, those Elders can prove they are who they claim to be. By using a combination of BLS-DKG, BRB, Anti-Entropy and CRDTs, the Safe Network keeps operations local which is simpler, more efficient and in keeping with the core principles of decentralization.</p>\r\n        </div>\r\n   \r\n        <h3>Tell me more &hellip;</h3>\r\n        \r\n        <p><a title=\"Signature-Free Asynchronous Byzantine\" href=\"https://hal.inria.fr/hal-00944019/document\" target=\"_blank\" rel=\"noopener noreferrer\" >Signature-Free Asynchronous Byzantine Consensus with t &lt; n/3 and O(n2) Messages (Mostefaoui et al) </a></p>\r\n        <p><a title=\"eth classic\" href=\"https://medium.com/datadriveninvestor/ethereum-classic-hacked-by-51-attack-f62c70cadd5c\" target=\"_blank\" rel=\"noopener noreferrer\" >Ethereum Classic &ldquo;HACKED&rdquo; by 51% attack! (Medium)</a></p>\r\n      \r\n\r\n        <p><a title=\"bft\" href=\"https://people.csail.mit.edu/silvio/Selected%20Scientific%20Papers/Distributed%20Computation/BYZANTYNE%20AGREEMENT%20MADE%20TRIVIAL.pdf\" target=\"_blank\" rel=\"noopener noreferrer\" >Byzantine Agreement, Made Trivial (Micali) (MIT)</a></p>\r\n        \r\n        <p><a title=\"BLS\" href=\"https://en.wikipedia.org/wiki/Boneh%E2%80%93Lynn%E2%80%93Shacham\" target=\"_blank\" rel=\"noopener noreferrer\" >Boneh-Lynn-Shacham (Wikipedia)</a></p>\r\n        <p><a title=\"BLSa\" href=\"https://www.youtube.com/watch?v=vBU70EjwGfw\" target=\"_blank\" rel=\"noopener noreferrer\" >BLS Threshold Crypto - Interface for Rust library threshold_crypto (Ian Coleman)</a></p>\r\n        <p><a title=\"CRDTa\" href=\"https://bartoszsypytkowski.com/the-state-of-a-state-based-crdts/\" target=\"_blank\" rel=\"noopener noreferrer\" >An introduction to state-based CRDTs</a></p>\r\n        <p><a title=\"CRDTb\" href=\"https://www.youtube.com/watch?v=B5NULPSiOGw\" target=\"_blank\" rel=\"noopener noreferrer\" >CRDTs and the Quest for Distributed Consistency (YouTube)</a></p>\r\n        <p><a title=\"CRDTc\" href=\"https://www.youtube.com/watch?v=vBU70EjwGfw\" target=\"_blank\" rel=\"noopener noreferrer\" >CRDTs for Non Academics (YouTube)</a></p>\r\n\r\n\r\n        \r\n        \r\n        \r\n    </div>\r\n\r\n);\r\n\r\nexport default Chap7;\r\n","export default __webpack_public_path__ + \"static/media/proof_of_resource.9d566729.jpg\";","export default __webpack_public_path__ + \"static/media/resources_and_currency.057abfd3.jpg\";","export default __webpack_public_path__ + \"static/media/dbc.a8e045d3.jpg\";","import React from 'react';\r\nimport proof_of_resource from '../images/proof_of_resource.jpg';\r\nimport resources_and_currency from '../images/resources_and_currency.jpg';\r\nimport dbc from '../images/dbc.jpg'\r\n\r\n\r\n\r\nconst component = () => (\r\n\r\n    <div className='chapter'>\r\n\r\n    \r\n        <h2 id='ch8'>8. Safe Network Token and Digital Bearer Certificates</h2>\r\n\r\n        <p>The financial incentive for Node operators to join the Network and cooperate toward the goal of secure data storage is to earn Safe Network Token (SNT). The idea behind Safe Network Token is similar to that of Bitcoin: to ensure that cooperative participation is a more rational course of action than uncooperative or malicious participation. SNT can be spent on the Network or exchanged for other currencies.</p>\r\n\r\n        <p>The amount of data that a user can store on the Safe Network depends on the SNT balance of the user's account.</p>\r\n        <div className=\"Keep-it-simple\">\r\n        <h3>Keep it simple!</h3>\r\n\r\n            <p>Farming is the process by which users who lend out spare storage can earn Safe Network Token, the currency of the Safe Network. Safe Network Token can be spent on the Network, for example by uploading files.</p>\r\n        </div>\r\n\r\n        <p>When a user of the Network requests some content, for example by browsing a website, a number of things happen. First, the Client software makes a request for the required data chunks. This message is sent to the Sections where the chunks are stored. The Client knows which Sections to contact because they are closest to the addresses of the chunks. The Section Elders then tell the Adults storing the chunks to deliver them to the Client.</p>\r\n\r\n        <p>Likewise when a Client wants to store data it contacts the relevant Sections. In return it receives a quote which it pays. That payment is split between the elders and the adults that store the chunks.</p>\r\n\r\n        <p>The rate of payment will depend on the farming_rate, which is a variable based on the quantity of free resources in the Network as well as the number of Safe Network Token in circulation. The Network will always try to maintain free space of at least 30 percent of its total capacity (to cover a disconnection or outage in certain parts of the Network). When the free space drops below 30 percent of the total capacity, the farming_rate will go up. Also, when there are too many Farmers providing storage space the farming_rate will go down. This happens automatically, and the effect is to create an incentive for farmers to provide storage when the overall spare capacity is low, and a disincentive when the amount of free space is high.&nbsp;</p>\r\n        <div className=\"What-does-that-mean\">\r\n        <h3>What does that mean?</h3>\r\n\r\n        <p>Farming - a Node is paid for looking after a data chunk.</p>\r\n\r\n            <p>farming_rate - a variable used to attract or discourage Farmers in order to maintain a certain level of free space (about 30 percent of the total capacity).</p>\r\n\r\n        <p>MaidSafeCoin - a cryptocurrency token currently available for purchase that will be exchangeable for Safe Network Token once the network is live.</p>\r\n\r\n            <p>Proof of Resource&nbsp; - 1. a test of whether a Node that wants to join the network has sufficient bandwidth and CPU power. If it fails the test it will not be allowed to join. 2. Random checks are occasionally made by Elders to ensure that the Node is indeed maintaining chunks it is supposed to be storing. If it fails the challenge (by not providing the demanded proof) its Node Age is diminished.</p>\r\n            </div>\r\n        <div className=\"Full-width-pic\" align=\"center\">\r\n\r\n            <img className=\"Img1\" src={proof_of_resource} alt=\"POR\" align=\"center\" />\r\n        </div>\r\n  \r\n\r\n   \r\n      \r\n        <p>The Network will balance itself in a way that's completely independent of the price of SNT. By adjusting the farming_rate according to the amount of free available space on the Network users storing data are charged at the optimum rate. While the storing rate is high (available free space is lower) users are discouraged from storing thus helping to free up more space. This dynamic pricing should translate into very competitive prices for data storage.</p>\r\n   \r\n        <p>Everyone with a suitable device and sufficient bandwidth is welcome to farm and thereby contribute to the network - including data centre owners. Nodes are continuously rewarded according to the quality of the resource they provide using Node Age and other features collectively known as Proof of Resource. To minimize the risk of centralization, however, the use of huge farming rigs will be economically disadvantageous compared with running multiple smaller nodes.</p>\r\n        <div className=\"Pullquote\">\r\n            \"There's more incentive for Farmers to provide storage when the overall spare capacity is low, and less incentive when the amount of free space is high\"\r\n                </div>\r\n\r\n        <p>While it cannot be guaranteed, the signs are that bandwidth and storage capacity will continue to increase rapidly for the next decade or two. This means that data will never&nbsp;have to be deleted, with all public information stored for the foreseeable future.&nbsp;&nbsp;</p>\r\n\r\n        <div className=\"Full-width-pic\" align=\"center\">\r\n\r\n            <img src={resources_and_currency} alt=\"resources and currency\" width=\"70%\" align=\"center\" />\r\n        </div>\r\n\r\n    \r\n\r\n       \r\n        <p>The supply of SNT will be limited to 4.3 billion coins, each with its own unique identity. Safe Network Tokens will be recycled when users exchange them for Network services, which means that there is always a supply for Farmers to earn.</p>\r\n\r\n        <p>Note: At the time of writing the Safe Network is still pre-release (Alpha) and SNT is not yet implemented. However, a token called MaidSafeCoin (MAID) can be purchased on cryptocurrency exchanges. When the Network goes live MAID will be exchanged for SNT on a 1:1 basis.</p>\r\n\r\n       <h3>Digital Bearer Certificates</h3>\r\n\r\n       <p>A Digital Bearer Certificate (DBC) is a unique ‘digital voucher’ which has value by virtue of the fact it has been provably issued by a trusted mint as part of an economic system, like a banknote. Unlike a banknote, however, to spend a DBC you need to get it reissued by a mint. The mint can take your DBC and reissue it as two or more new DBCs if you wish (e.g. payment to a shop, the remainder as change to you), and multiple DBCs can be reissued as a single DBC.</p>\r\n       <p>DBCs provide a quick, safe, flexible way to make payments that is compatible with multisig/threshold signature cryptography and can be used online and offline. They simplify many aspects of the Safe Network economy and remove the need for section wallets or similar mechanisms to manage SNT transfers.</p>\r\n\r\n       <h4>Advantages of DBCs on Safe</h4>\r\n\r\n<p>A mint is responsible for issuing and reissuing DBCs, and checking they are valid and have not already been spent. Mints can be trusted because they are hosted by section Elders, nodes that have already gained the trust of the Network. Any mint action must be authorized by a supermajority (5 out of 7) of Elders. This is vital in protecting against Sybil attacks.\r\nThe DBC system takes advantage of the sharded nature of the Network to remove the single point of failure of a typical centralised mint. Each Section has a mint, and is responsible for reissuing only those DBCs with an ID within its address range. In addition, the natural random distribution imposed by XOR means that DBCs will be scattered across Sections. Furthermore, a DBC issued by one Section will likely need to be spent in another Section, which limits the control any Section may exert over money supply.\r\n</p>\r\n<div className=\"Full-width-pic\" align=\"center\">\r\n<img className=\"Img\" src={dbc} alt=\"dbc\" width=\"70%\" align=\"center\" />\r\n</div>\r\n\r\n<ul><em>\r\n<li>id = hash of current DBC</li>\r\n<li>output_number  = index of split</li>\r\n<li>owner = owner of public key</li>\r\n<li>inputs = hash of input DBC (0 if genesis)</li>\r\n<li>outputs = hash of current DBC (same as id)</li>\r\n<li>data = encapsulation of the above, plus the keys used to create it and those required to spend it</li>\r\n</em></ul>\r\n\r\n<h4>Reissuing DBCs</h4>\r\n<p>Unlike cash, DBCs have owners. Also they need to be ‘reissued’ to a payee by a mint before they can be spent. This is to prevent double-spend. Reissuing is the process of checking that the DBC is valid and has not already been spent, and using a hash of the DBC (its output) to create a new DBC, or DBCs: in the reissuing process multiple DBCs can be combined into a new DBC – or several new DBCs – or a single DBC can be reissued as several new DBCs with their values adding up to the total of the original, as in the example below.\r\n</p>\r\n\r\n<h4>The Spentbook</h4>\r\n\r\n<p>Before spending a DBC the Client must create a Spentbook entry. This is an immutable data item stored on Adult Nodes on the Network. It contains details of the desired transaction. When reissuing a DBC, the Mint checks to see if a Spentbook entry exists for that DBC and if so it will not perform the reissue. This ensures that once the transaction (DBC reissue) has occurred, the same DBC cannot be spent again.</p>\r\n\r\n<h4>Unlinkability</h4>\r\n\r\n<p>It is important for privacy and fungibility (the ability to convert a currency into any other) that transactions are not easily traceable back to individuals. To achieve this DBC transactions will be limited to fixed denominations. The following transactions: 2 x 1000 + 1 x 100 + 1 x 50 + 2 x 10 + 1 x 5 + 3 x 1 are far less linkable to individual parties than a single transaction of 2,178 SNT would be.  </p>\r\n\r\n<p>Other techniques under investigation for delinking transactions include hiding the amounts transacted from a mint, and using blind signatures. At the time of writing the exact combination of these methods that will be used to make transactions unlinkable was still under discussion.</p>\r\n\r\n<p>As well as enabling private, simple and rapid transactions between individuals, DBCs are also the medium by which people can pay for uploads and for that payment to be shared between the Elders and Adults involved.</p>\r\n\r\n\r\n\r\n\r\n        <h3>Tell me more...</h3>\r\n\r\n        <p><a title=\"denominations\" href=\"https://safenetforum.org/t/update-21-october-2021/35708\" target=\"_blank\" rel=\"noopener noreferrer\" >Discussion of denominations (Safe Network Forum)</a></p>\r\n\r\n        <p><a title=\"linkability\" href=\"https://safenetforum.org/t/update-09-september-2021/35514#more-on-dbcs-2\" target=\"_blank\" rel=\"noopener noreferrer\" >Discussion of unlinkability (Safe Network Forum)</a></p>\r\n\r\n        <p><a title=\"blind signatures\" href=\"https://safenetforum.org/t/update-21-october-2021/35708\" target=\"_blank\" rel=\"noopener noreferrer\" >Blind Signatures for Untraceable Payments (White paper, David Chaum, 1998)</a></p>\r\n\r\n        <p><a title=\"Digital Money and DBCs\" href=\"https://opaque.link/post/digitalmoneydbc/\" target=\"_blank\" rel=\"noopener noreferrer\" >Digital Money and DBCs (Jonathan 'Smuggler' Logan, 2018)</a></p>\r\n\r\n        <p><a title=\"scrit\" href=\"https://github.com/scritcash/scrit-whitepaper/blob/master/scrit-whitepaper.pdf\" target=\"_blank\" rel=\"noopener noreferrer\" >Scrit: An Untraceable Distributed Electronic Cash System (Jonathan 'Smuggler' Logan, 2019)</a></p>\r\n\r\n        <p><a title=\"pedersen\" href=\"https://safenetforum.org/t/update-july-29th-2021/35288#pedersen-commitments-and-range-proofs-2\" target=\"_blank\" rel=\"noopener noreferrer\" >Pedersen Commitments and Range Proofs (Safe Network Forum)</a></p>\r\n\r\n        \r\n        <p><a title=\"Safecoin \" href=\"https://safenetwork.tech/safecoin/\" target=\"_blank\" rel=\"noopener noreferrer\" >This is Safecoin (Safe Network website)</a> &nbsp;&nbsp;</p>\r\n\r\n        <p><a title=\"Safecoin Implementation\" href=\" https://github.com/maidsafe/rfcs/blob/master/text/0012-safecoin-implementation/0012-safecoin-implementation.md\" target=\"_blank\" rel=\"noopener noreferrer\" >Safecoin Implementation (MaidSafe RFC)</a> &nbsp;</p>\r\n\r\n        <p><a title=\"Farm Attempt \" href=\"https://github.com/maidsafe/rfcs/blob/master/text/ \" target=\"_blank\" rel=\"noopener noreferrer\" >Farm Attempt (MaidSafe RFC)</a></p>\r\n\r\n        \r\n    </div>\r\n\r\n);\r\n\r\nexport default component;\r\n","export default __webpack_public_path__ + \"static/media/supermajority.5eb8aa40.png\";","export default __webpack_public_path__ + \"static/media/ae1.e1bf78b5.png\";","export default __webpack_public_path__ + \"static/media/ae2.3bdc4cc8.png\";","export default __webpack_public_path__ + \"static/media/ae3.37d26212.png\";","export default __webpack_public_path__ + \"static/media/ae4.53952674.png\";","export default __webpack_public_path__ + \"static/media/ae5.a40a0e39.png\";","export default __webpack_public_path__ + \"static/media/ae6.c1291727.png\";","export default __webpack_public_path__ + \"static/media/ae7.d094d5cb.png\";","export default __webpack_public_path__ + \"static/media/ae8.ecc2b23d.png\";","export default __webpack_public_path__ + \"static/media/ae9.642819f2.png\";","export default __webpack_public_path__ + \"static/media/ae10.f6139819.png\";","export default __webpack_public_path__ + \"static/media/ae11.bac0af29.png\";","import React from 'react';\r\nimport supermajority from '../images/supermajority.png';\r\nimport ae1 from '../images/ae1.png';\r\nimport ae2 from '../images/ae2.png';\r\nimport ae3 from '../images/ae3.png';\r\nimport ae4 from '../images/ae4.png';\r\nimport ae5 from '../images/ae5.png';\r\nimport ae6 from '../images/ae6.png';\r\nimport ae7 from '../images/ae7.png';\r\nimport ae8 from '../images/ae8.png';\r\nimport ae9 from '../images/ae9.png';\r\nimport ae10 from '../images/ae10.png';\r\nimport ae11 from '../images/ae11.png';\r\n\r\n\r\n\r\nconst component = () => (\r\n\r\n    <div className='chapter'>\r\n\r\n    \r\n        <h2 id='ch9'>9. Safe Network Anti-Entropy</h2>\r\n\t\t\r\n\t\t\r\n\t\t\r\n\r\n<p>A major hurdle that any decentralized network that will experience churn, such as Safe, must overcome is keeping the participants up to date with the network&rsquo;s current state. Who has joined and who has left? Who are the current Elders in any given Section?</p>\r\n<p>Elders are by definition relatively dependable and churn amongst them is minimal, but Safe is asynchronous and communications between Section Elders and external actors may be few and far between. The Elders in a Section may have churned many times between contacts.</p>\r\n<p>It&rsquo;s vital that actors wishing to make a change on the Network have an up-to-date &lsquo;understanding&rsquo; of the affected Section before they are allowed to do so, otherwise data could be written to Elders that no longer exist and be lost.</p>\r\n<p>Entropy, or  disorder, is a characteristic of a constantly changing network. We cannot reduce it but we can wait for periods of stability among Elders before allowing a change in their Section. Anti-Entropy is the mechanism for doing this.</p>\r\n<p>Even during periods of massive change such as a large global event, AE enables the network to inform actors attempting to mutate data that they must wait until the change is over before they can try again.</p>\r\n<p>On Safe, the AE mechanism is applied to all messages that can mutate the Network, such as a PUT request. It requires the requesting actor - be that a Client, an Adult or another Section - to prove that the information they hold on the affected Section is current before they proceed. Until then they cannot make a change.&nbsp;</p>\r\n<p>AE reduces the synchronisation issue to a series of questions to which the answer is yes or no. If the answer is no (your information is not current), you need to update your records and try again. There is no halfway house.</p>\r\n<p>In this way AE forces all Nodes that want to perform data operations on the Network to prove they are up to date.&nbsp;</p>\r\n\r\n<h3 >Core concepts and mechanisms</h3>\r\n<ul>\r\n<li><strong>Supermajority</strong> &ndash; Any action affecting a Section must be agreed by more than 2/3 of the Elders. For a Section containing seven Elders, two can disagree and the agreement will still go ahead. This allows BFT-type guarantees that provided 2/3 of Nodes can be trusted, agreement will be reached in the event of conflict.</li>\r\n<li><strong>Distributed Key Generation (DKG)</strong> &ndash; To generate a new BLS SectionKey, the participation of a supermajority of Elders is required.</li>\r\n<li><strong>New key per churn event</strong> &ndash; every time an Elder is promoted or demoted, a new round of DKG takes place.&nbsp;</li>\r\n<li><strong>Atomic functionality</strong> - it works or it doesn&apos;t - in case of any conflict or disagreement the actor is requested to try again.</li>\r\n</ul>\r\n\r\n\r\n<h3>SectionChain and ProofChain</h3>\r\n<p>A SectionChain is a cryptographically secure linked list of BLS SectionKeys, each signed by the previous key in the list going back all the way to Genesis. That way, if you trust Genesis (as you must) then you can trust the validity of the latest key.</p>\r\n<p>If an actor contacting the Section holds an old key, the Section Elders send the actor a ProofChain (plus the SAP, see below) to bring it up to date.</p>\r\n<p>A ProofChain is simply the most recent part of the SectionChain going back only as far as the last key held by the actor, plus one.&nbsp;</p>\r\n\r\n\r\n<h3>SectionAuthorityProvider and SectionActor</h3>\r\n\r\n<p>As well as updating the requesting actor with the ProofChain, the Elders also send it the SectionAuthorityProvider (SAP), which gives up-to-date information about the Section and its Elders.</p>\r\n\r\n<p>The SAP shows us exactly which Elders are in the Section at the present time as well as the current SectionKey.</p>\r\n\r\n<p>The SAP together with the requirement for a supermajority for agreement allows Section Elders to be treated as a single entity - a SectionActor - rather than as autonomous individuals: they act together or not at all.&nbsp;</p>\r\n\r\n\r\n<h3>The three update scenarios</h3>\r\n<p>On messaging a Section an actor includes what it understands to be that Section&rsquo;s latest SectionKey.</p>\r\n<ol type=\"1\">\r\n    <li>If the SectionKey is correct and current the message is processed.</li>\r\n    <li>If the key is out of date the Section returns the message with a ProofChain and the SAP to authenticate the Elders. The actor updates its records and tries again.</li>\r\n    <li>If the SectionKey is not recognised the message is&nbsp;ignored.</li>\r\n</ol>\r\n\r\n\r\n<h3 >Voting and conflict resolution</h3>\r\n<p>If an Elder sees a change in Section membership it broadcasts this to the other Elders in the Section and they vote on whether and how the Section state has changed by creating a message containing the proposal and signing it with their BLS shared secret key. Every time the state changes a new round of BLS-DKG is required and a new SectionKey is created.&nbsp;</p>\r\n<p>However, due to differences in connection speed and other factors, not all Elders see the same state at the same time (see Chapter 7).</p>\r\n<p>In the event of a conflict, agreement must be reached before the Section&rsquo;s state is communicated to the outside world, because we can only ever have one version of the truth.&nbsp;</p>\r\n\r\n\r\n          <img className=\"Img\" src={supermajority} alt=\"supermajority\" width=\"70%\" align=\"center\" />\r\n\r\n<p>This is where the supermajority comes into play. A supermajority (e.g. 5 out of 7 Nodes) is required to generate a new Section key, and it is also (non-coincidentally) how Elders arrive at an agreement.&nbsp;</p>\r\n<p>If five Elders see a Node leave (and generate a new key A) and five see another Node join (and generate a new key B) there must be a minimum of three Elders that see both versions. Under BFT at least one of these Elders must be honest. Therefore, both keys A and B are rejected and a new round of DKG takes place.</p>\r\n<p>While this process is happening, any requests for data mutation from outside actors will be rejected. This prevents a client manipulating different Elders within a Section by forking the decision-making process.</p>\r\n\r\n\r\n\r\n\r\n<h3 >How AE works &ndash; an example</h3>\r\n<p>Let&rsquo;s consider the example of a Client requesting a Section to PUT a chunk of data, and assume that the Client has not contacted our Section before. Incidentally, AE works in the same way for communications between Adults and Elders and between Sections too.</p>\r\n\r\n<p>1. The starting situation</p>\r\n          <img className=\"Img\" src={ae1} alt=\"ae1\" width=\"70%\" align=\"center\" />\r\n<p><strong>&nbsp;</strong></p>\r\n<ul>\r\n    <li>Each Elder is in constant contact with all other Elders in the Section (connections not shown) and with all Adults.</li>\r\n    <li>Elders churn rarely, Adults churn frequently.</li>\r\n    <li>Every time the Elders churn a new BLS SectionKey is generated.</li>\r\n    <li>The SAP is what&nbsp;defines the current Section.</li>\r\n    <li>A Section is also defined by its unique XOR address prefix, eg 0011.</li>\r\n    <li>Each Elder&nbsp; has an ID, a BLS key, SectionChains from its own and other Sections and an address.</li>\r\n    <li>Each Adult has an ID, a SectionChain and an address.</li>\r\n</ul>\r\n<p>2. Client broadcasts a request to all Elders in relevant sections simultaneously</p>\r\n\r\n\r\n          <img className=\"Img\" src={ae2} alt=\"ae2\" width=\"70%\" align=\"center\" />\r\n\t\t  \r\n\t\t<p>3. SectionActor sends SectionChain and SAP</p>\r\n          <img className=\"Img\" src={ae3} alt=\"ae3\" width=\"70%\" align=\"center\" />\r\n\r\n<p>4. But before the Client can resend the message a churn event has occurred with Elder G leaving</p>\r\n          <img className=\"Img\" src={ae4} alt=\"ae4\" width=\"70%\" align=\"center\" />\r\n\r\n<p>5. The Elders vote on the change</p>\r\n\r\n          <img className=\"Img\" src={ae5} alt=\"ae5\" width=\"70%\" align=\"center\" />\r\n\t\t  \r\n<p>If an Elder sees a change it messages the other Elders to tell them. The Elders vote on whether a churn event has occurred. In this example, most see that G has gone, one (perhaps geographically further away) can still see G. A supermajority votes that G has gone and a new SectionKey, K6, is generated. If the vote had been split without a supermajority it would simply have been rerun.&nbsp;</p>\r\n<p>While the churn is occurring the Client&rsquo;s message is rejected, but as part of AE it will retry continually.&nbsp;</p>\r\n\r\n<p>6. Unaware of the churn, the Client tries again attaching its latest key, K5, to the message</p>\r\n          <img className=\"Img\" src={ae6} alt=\"ae6\" width=\"70%\" align=\"center\" />\r\n\t\t  \r\n\t\t  <p>7. Key out of date, try again</p>\r\n          <img className=\"Img\" src={ae7} alt=\"ae7\" width=\"70%\" align=\"center\" />\t\r\n\r\n<p>8. But before it can try again there’s more churn: Elder H arrives</p>\r\n          <img className=\"Img\" src={ae8} alt=\"ae8\" width=\"70%\" align=\"center\" />\t\r\n<p>9. The client tries once more but again it is out of date</p>\r\n          <img className=\"Img\" src={ae9} alt=\"ae9\" width=\"70%\" align=\"center\" />\t\r\n<p>10. Once again it is sent the updated ProofChain and SAP and told to try again</p>\r\n          <img className=\"Img\" src={ae10} alt=\"ae10\" width=\"70%\" align=\"center\" />\t\r\n<p>11. Success – the churn is over and authority is given</p>\r\n          <img className=\"Img\" src={ae11} alt=\"ae11\" width=\"70%\" align=\"center\" />\t\r\n\r\n\t\t  \r\n<p>The Client tries again and this time the keys match so everyone is in sync and the operation to store chunk <em>A</em> can proceed. As part of AE a requesting actor will retry continually.</p>\r\n\r\n\r\n<p>The assumption is that Elders churn rarely (that&rsquo;s why they are Elders) so the above scenario should be rare. Nevertheless, it will happen and AE needs to be able to handle the various combinations of Elders leaving and joining, even if this takes multiple rounds of DKG.&nbsp;</p>\r\n<p>Some potentially difficult scenarios are taken care of by other mechanisms. For example, if an Elder leaves and tries to rejoin again it will find itself relocated to another Section with its Node Age halved (Chapter 5).</p>\r\n\r\n\r\n<div className=\"Keep-it-simple\">\r\n        <h3>Keep it simple!</h3>\r\n<p>Anti-Entropy is a way to ensure that before data is changed on the network the Section in question is not in a state of churn and the actor requesting the change knows the current identities of the Elders in the Section.</p>\r\n<p>It is an efficient way to keep the network updated on a need-to-know basis with a minimum of messaging.</p>\r\n<p>Importantly, a Section cannot mutate data when it is between states. Only once churn has completed with the agreement of a supermajority of the Elders in the Section will requests for data mutation be accepted. Until then the actor must keep trying.</p></div>\r\n\r\n   <h3>&nbsp;Tell me more...</h3>\r\n   <p><a title=\"anti-entropy\" href=\"https://github.com/maidsafe/sn_entropy_check\" target=\"_blank\" rel=\"noopener noreferrer\" >Anti-Entropy (GitHub)</a></p>\r\n\r\n\r\n    </div>\r\n\r\n);\r\n\r\nexport default component;\r\n","import React from 'react';\r\nimport data_types from '../images/data_types.png';\r\n\r\n\r\n\r\n\r\nconst component = () => (\r\n\r\n    <div className='chapter'>\r\n        <h2 id='ch10'>10. Data types</h2>\r\n\t\t\r\n\t<p>A data type is a classification which describes how data can be created, transformed and used. All programming languages use them, and common examples include integer, string and boolean.</p> \r\n\t\t\r\n\t\t<p>The Safe Network provides two native data types for storing and retrieving data: Blob and Register, plus a third type, Multimap, which is a refinement of Register. Registers and Multimaps are mutable data types, whereas Blobs are immutable.</p> \r\n\t\t\r\n\t\t<p>Data itself comes in different forms too. Content or binary data is always encrypted and is spread out over the Safe Network as immutable chunks (Blobs). It can be read by anyone with a data map, which shows how to decrypt and reconstruct the content from its constituent chunks. That data map part of a file which also contains other metadata such as filename and type (video, image, etc). So a 'file' on the Safe Network is really a set of instructions for finding the content's immutable constituent parts and assembling them to recreate the original content, together with information about what will be returned when you do.</p>\r\n\t\t\r\n\t\t<p>The FilesContainer is the equivalent of the familiar folder. We'll use the term folder from here on in as it's less confusing and the FilesContainer nomenclature may change. A folder contains files. Files and folders are mutable - they are metadata rather than data, and you can change the contents of a file and add or remove files from a folder. You can also nest folders within folders just as you can in most operating systems. </p>\r\n\r\n\t\t<p>Content can be public or private. Data stored in a folder can be seen by anyone with the folder's FileMap. For private data, as with a file, the Client holds the FileMap. Sub folders have their own FileMaps and may be public or private too, independent of their parent folder.</p>\t\t \r\n\r\n\t\t\r\n\t\t<h3>Blob</h3>\r\n        <p>A Blob is an immutable data type. Its Network address is derived from the hash of its content. This means the file cannot be edited in any way after it has been uploaded - any change would alter the hash and therefore its address meaning it could not be found. The data chunks created by Self-Encryption (see Chapter 6) are Blobs. </p>\r\n        <p>Data deduplication is a unique feature of the Safe Network and a side benefit of the process of Self-Encryption. Two identical Blobs will have the same hash value, and therefore only one (plus a few copies for redundancy) need be stored on the Network.</p>\r\n    \r\n\t\r\n        <p>Blobs can be cached by Clients, and fetching the same chunk next time can be quicker. Safe also has a planned feature called Opportunistic Caching in which more copies of popular data are created closer to where it is being requested, so popular websites and other data feeds will actually speed up as they get more visitors, rather than slowing down as they do on today's Web.</p>\r\n        \r\n        <h3>Register</h3>\r\n\t\t\t \r\n\t\t<p>A Register is a general CRDT mutable data type that holds a value. Registers are used to store appendable data - data can be added to a Register with previous values still being accessible. The Safe Network deploys a special type of Register called a Merkle Register which supports concurrent writes. If two actors write to a register at the same time a fork will be created with both versions kept available. It's then up to client software to decide which fork to choose, according to the app's own rules.</p> \r\n\t\t\r\n\t\r\n\r\n\t\t <h3>Multimap</h3>\r\n\t\t  \r\n\t\t <p>A Multimap is a CRDT (Chapter 7) version of a Map data type.</p>\r\n\t\t \r\n\t\t <p>A basic Map is composed of key-value pairs (e.g. <em>key</em> 123: <em>value</em> apple, <em>key</em> 124: <em>value</em> banana).</p>\r\n\t\t \r\n\t\t <p>A Multimap is a more flexible type of Map built on the Register type which allows multiple values to be associated with each key (e.g. <em>key</em> 123: <em>value</em> apple, banana, cherry...). This means that multiple clients (e.g. apps) can edit a Multimap entry at the same time, the result being forks. </p>\r\n\t\t \r\n\t\t\t\t \r\n\t    <p>Every time an operation is performed on a Multimap, a new hash is created as an identifier for the latest version. In the case of a fork with two branches, two hashes are created. Both branches will remain available to an application querying the Multimap, but it's highly likely that one chain will grow longer and most apps will choose to show this one by default. This is different from the previous Map used by Safe Network, in which versions changed in a linear fashion (v1, v2, v3...), and is akin to the way git branching works. </p>\r\n\r\n        <p>Files and folders are based on Registers and Multimaps, and Multimaps are used extensively in the NRS, which maps human-readable names to Network addresses, to maintain name mappings and to track versions of files. They store the current version of the data plus previous ones going back in time, including branches.</p>  \t \r\n\r\n        <p>Entries in a Multimap can be inserted, updated and deleted (or at least hidden).</p>  \r\n       \r\n       \r\n\r\n        <div className=\"What-does-that-mean\">\r\n            <h3>What does that mean?</h3>\r\n            <p>Data type - a classification which describes how data can be created, transformed and used. </p>\r\n            <p>Blob - an immutable data type. </p>\r\n            <p>Register - a mutable CRDT data type. </p>\r\n            <p>Multimap - a mutable CRDT data type for mapping keys to values. </p>            \r\n\t\t\t<p>File - contains a Data Map showing how to fetch chunks to recreate content, and meta data such as name, etc.   </p>\r\n            <p>Data Map  - a record of file chunks and their corresponding locations on the Network. Only those in possession of the Data Map can recreate the file.  </p>\r\n\t\t\t<p>File Map - maps filenames/paths to metadata,</p>\r\n            <p>Concurrency control - managing the situation where multiple users may make changes to the same data at the same time. </p>\r\n            <p>CRDTs – Data structures that obey certain mathematical rules which ensure that when multiple versions of data exist across a distributed network, eventually these will always converge onto one 'true' version.</p>\r\n            <p>XOR address - a unique 256-bit number. Every entity on the Network has an XOR address. </p>\r\n            <p>XOR URL - a base-32 encoded translation of the XOR address together with other information such as data type as required by applications. </p>\r\n\t\t\t<p>PublicName -  the equivalent of a domain/site address.</p>\r\n            <p>SafeID - the equivalent of a 'username' or identity. The PublicName can also do double duty here as it’s a public name with a @ in front. So a public name can be used as a SafeID, but a SafeID need not have a site</p>\r\n            <p>Network File Storage (NFS) - an API that allows a Client to access files stored on the Safe Network.</p>\r\n            <p>Name Resolution System (NRS) - analogous to the Domain Name System (DNS) on the Internet, this is a system that translates an XOR address to a human-readable web address.</p>\r\n             <p>Type tag - allows apps to identify the type of data, e.g. 15001 Public ID; 15002 Service Name; 15003 Email ID; 15004 Email Archive.</p>\r\n            <p>Opportunistic Caching - automatic creation of more copies of popular data close to where it is being requested, so popular websites and other data feeds will actually speed up as they get more visitors, rather than slow down as they do on today's web.</p>\r\n        </div>\r\n    \r\n\r\n        <h3>Network File Storage</h3>\r\n\r\n        <p>Data is saved using a combination of Multimap, Register and Blob to create an emulated file system on top of the Network called NFS (Network File Storage). NFS saves the content as a Blob. It then creates an entry in a folder (a FilesContainer) a Multimap entity, with the file name as the entry's key and the Blob's address as the entry's value. The file can be updated by uploading a new Blob and then altering the file's address in the folder structure to point to the new instance. </p>\r\n        \r\n        <h3>Name Resolution System</h3>\r\n      \r\n        <p>Unlike the web, domains on Safe are permanent. On the web you need to keep paying for your domain or it will expire and can be given to someone else, or you can sell it to someone else of course. But on Safe, which has no centralised system like ICANN to administer them. Thus NRS is an entirely different system, which comes with tradeoffs. Pay-once-use-forever is appealing of course, but it could lead to domain name squatting, where domains like 'google' are immediately registered with lucrative resale in mind. On the web this became less of a problem once more top level domains (TLDs, e.g. .tech, .lawyer, .biz) became available, copyright law caught up with the technology, and search engines made having a memorable .com domain less essential. But NRS effectively has one domain (like .com) which would likely lead to squatting, and there is currently no search engine for Safe. There are ways around this issue, such as reserving names, creating new TLDs, using petnames, or encouraging a market for alternatives to NRS, but at the time of writing this was still under discussion.</p>\t  \r\n\t  \r\n      \r\n        <p>As well as the human-readable Safe URL provided by NRS, files stored on the Network can also be accessed via their XOR-URL (e.g. safe://a078516207e36aa2371e17750c93276446bdb4867c027035531b89430aa8d3ae2fa4dbb59). This URL is a base-32 encoding of the file&rsquo;s XOR address and (optionally) its MIME type allowing data to be stored and retrieved by applications without reference to the storer&rsquo;s account (see Chapter 11).</p>\r\n       \r\n       <h3>Tell me more...</h3>\r\n        <p>&nbsp;</p>\r\n        <p><a title=\"data types\" href=\"https://safenetforum.org/t/update-30-september-2021/35595\" target=\"_blank\" rel=\"noopener noreferrer\" >A deep dive into the Merkle Register </a></p>\r\n\r\n        <p><a title=\"data types\" href=\"https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging\" target=\"_blank\" rel=\"noopener noreferrer\" >Git Branching - Basic Branching and Merging </a></p>\r\n\t\t\r\n    \r\n        <p><a title=\"data types a\" href=\"https://github.com/maidsafe/rfcs/blob/d42c24db6ddfe58f14b347a5664710e493262ce9/text/0052-RDF-for-public-name-resolution/0052-RDF-for-public-name-resolution.md\" target=\"_blank\" rel=\"noopener noreferrer\" >Data Hierarchy Refinement (MaidSafe RFC and forum discussion)</a></p>       \r\n        <p><a title=\"md\" href=\"https://github.com/maidsafe/rfcs/blob/d42c24db6ddfe58f14b347a5664710e493262ce9/text/0052-RDF-for-public-name-resolution/0052-RDF-for-public-name-resolution.md\" target=\"_blank\" rel=\"noopener noreferrer\" >RDF for the Public Name Resolution System (MaidSafe RFC)</a></p>        \r\n        <p><a title=\"aod\" href=\"https://github.com/maidsafe/safe-nd\" target=\"_blank\" rel=\"noopener noreferrer\" >Safe Network Data Types (Github)</a></p>\r\n        <p><a title=\"polyfuse\" href=\"https://github.com/ubnt-intrepid/polyfuse\" target=\"_blank\" rel=\"noopener noreferrer\" >Polyfuse - A FUSE (Filesystem in Userspace) library for Rust.  (Github)</a></p>\r\n        <p><a title=\"tree\" href=\"https://forum.safedev.org/t/filetree-crdt-for-safe-network/2833\" target=\"_blank\" rel=\"noopener noreferrer\" >FileTree CRDT for Safe Network  (MaidSafe forum discussion)</a></p>\r\n        <p><a title=\"cache\" href=\"https://maidsafe.net/features.htm\" target=\"_blank\" rel=\"noopener noreferrer\" >Distributed network with opportunistic data caching (MaidSafe)</a></p>\r\n        <p><a title=\"wayback\" href=\"https://web.archive.org/\" target=\"_blank\" rel=\"noopener noreferrer\" >Internet Archive Wayback Machine</a></p>\r\n        <p><a title=\"safe_app\" href=\"https://docs.maidsafe.net/safe_app_nodejs/#nfs\" target=\"_blank\" rel=\"noopener noreferrer\" >Maidsafe NFS API documentation</a></p>\r\n        <p><a title=\"xorurls\" href=\"https://github.com/maidsafe/rfcs/blob/357384147ae005e4061079b27a30f43cf379fda5/text/0000-xor-urls/0000-xor-urls.md\" target=\"_blank\" rel=\"noopener noreferrer\" >XOR-URLs (MaidSafe RFC)</a></p>\r\n        <p><a title=\"base 32\" href=\"https://philzimmermann.com/docs/human-oriented-base-32-encoding.txt\" target=\"_blank\" rel=\"noopener noreferrer\" >Human-oriented base-32 encoding (O'Whielacronx)</a></p>\r\n\r\n     </div>   \r\n);\r\n\r\nexport default component;\r\n","export default __webpack_public_path__ + \"static/media/data_types.2ffbb00d.png\";","import React from 'react';\r\n\r\n\r\n\r\n\r\nconst component = () => (\r\n\r\n    <div className='chapter'>\r\n        <h2 id='ch11'>11. How Safe Network defends against common types of cyberattack</h2>\r\n        <p>Safe Network has an interlocking set of features, each covering the others&rsquo; vulnerabilities. This means that data security on Safe is maximized. While 100 percent security is impossible, this strength-in-depth means that the sort of attacks common on the current web will be much harder to carry out on SAFE.</p>\r\n        <h3><strong>Features</strong></h3>\r\n        <p><em>Random address allocation</em><strong> &ndash; </strong>a new Node joining the Network cannot set its own address and thus cannot decide which Section it joins or which data it will be looking after. This prevents an attacker from being able to target a particular Section to add bad nodes. On a random distribution, the attacker would need to control approximately a third of all nodes to launch such an attack (see Chapter 4).</p>\r\n        <p><em>Nodes are added only as needed -</em> Each Section only accepts a Node if needed, meaning an attacker might have to wait a very long time to have its Node accepted. Even after that, a new Node will be moved between Sections before it can become an Elder (see Chapter 5).</p>\r\n        <p><em>Node ageing</em> - only Nodes that have proved their worth over time (Elders) are allowed to vote on the validity of events in a Section. Nodes that do not pull their weight or act as they will be expelled and/or their Node Age reset to a lower value (see Chapter 5).</p>\r\n        <p><em>Churn</em> - Nodes are constantly joining or leaving Sections. Membership is fluid.</p>\r\n        <p><em>Encryption</em> - All data on the Safe Network is protected by several layers of encryption. Even public data is encrypted (in this case the keys are shared to allow others to decrypt it &ndash; see Chapter 6).</p>\r\n        <p><em>Self-Encryption</em> - content stored on the Network is broken into chunks with each chunk encrypted using its own hash and the hashes of the two previous chunks. These chunks are stored at geographically random locations (the XOR location being the hash of the encrypted chunk) with a number of copies retained for redundancy. Without a Data Map, the chunks cannot be retrieved and decrypted. (Chapter 6).</p>\r\n        <p><em>XOR Networking</em> - Randomizes the geographical distribution of the chunks. Only someone in possession of the Data Map (i.e. the data owner) can find the chunks and piece them together again to recreate the content. An attacker trying to fake a chunk could not do so as its hash - and therefore its address on the Network - would be different. It could not be used to create a corrupted version of the file (see Chapter 5).</p>\r\n        <p><em>Self-Authentication</em> - A user can create a Safe securely and anonymously without requiring any central server to mediate the login process or any trusted third party to store and manage users&rsquo; credentials (see Chapter 3).</p>\r\n        <p><em>Anonymization</em> - To retain anonymity, the identity of a Client connecting to the Network must be obfuscated from the nodes that comprise it. For this reason connections between Clients and Nodes in the Safe Network always occur via a Node the IP of which is in the config file. Any Node can perform this role and rather than accepting the config file the user may prefer to connect via a known node of his or her choosing. Thereafter, the initial Node drops the connection and cannot track the Client's activity (see Chapter 4).</p>\r\n        <p><em>Disjoint Sections</em> - Addresses on the Safe Network are grouped into Sections with each Section looked after by a group of Nodes. Those Nodes know everything about the Section for which they are responsible but very little about the rest of the Network. Moreover, the membership of a Section is constantly changing and they will frequently split. So even if an attacker could control a Section his potential for damage would be limited (see Chapter 5).</p>\r\n        <p><em>BLS-DKG</em> - BLS cryptography (see Chapter 7, 8) allows secure authentication of Sections and multi-signature transactions. </p>\r\n        <p><em>Malice Detection</em> - The BLS signature scheme allows for the detection of invalid messages. If these reach a certain threshold the node will be demoted. If a node signs a message that is malicious the signature is forwarded to other Elders who can vote to kill the Node (see Chapter 7).</p>\r\n        <h3><strong>Defence against common attacks</strong></h3>\r\n        <p><em>Sybil attack</em> - In a Sybil attack, the attacker subverts the reputation system of a peer-to-peer network by creating a large number of pseudonymous identities, using them to gain a disproportionately large influence.</p>\r\n        <p>An attacker owning a large number of Nodes could potentially control individual Sections and block actions happening to data in those Sections (GET, PUT, transfer Safe Network Token). However, they would need to control more than a third of the Elders, and remember they cannot choose the Sections they join. Even then, the attacker would only have influence over the fraction of data controlled by the Group it is in (not the whole Network). Also, disrupting an individual&rsquo;s data would be impossible &ndash; the attacker cannot know where it is stored.</p>\r\n        <p>Someone with enough Nodes could of course bring the Network down (for example by suddenly turning off all their Nodes). But this gets harder very quickly as the Network grows larger. A combination of Node Ageing, churn, rules on joining and the splitting of Sections would make this massively more difficult (and very expensive) on a large network.</p>\r\n        <p>In addition, there are Malice Detection tests to identify misbehaving nodes.</p>\r\n        <p><em>Phishing, keylogging etc</em> - these attacks are feasible as the Network cannot protect endpoints. But such an attack would only compromise the user&rsquo;s own data (and that others have allowed the user to see). Using such a compromise as a springboard for a wider attack on a database or whatever would not be possible. This would be of dubious value to an attacker.</p>\r\n        <p><em>Man in </em><em>the Middle attacks</em> - MitM attacks rely on data being unencrypted or the victim&rsquo;s browser accepting the attacker's certificate instead of the website&rsquo;s certificate. They will not work on SAFE.</p>\r\n        <p><em>DDoS</em> - exceptionally difficult as there is no single point to attack. The Network will simply reroute around any nodes that are taken down.</p>\r\n        <p><em>Quantum computing</em> - The encryption used on Safe is &lsquo;quantum resistant&rsquo; (but not &lsquo;quantum proof&rsquo;). But the volume of encrypted packets means that there could only be targeted attempts at decryption, and decentralization makes such targeting difficult.</p>\r\n        <p><em>Ransomware</em> &ndash;Files are stored in immutable data and cannot be changed, so ransomware could not encrypt it, but it could potentially delete Data Maps or hide them, making data inaccessible.</p>\r\n     \r\n        </div>\r\n);\r\n\r\nexport default component;\r\n","\r\nimport React from 'react';\r\n\r\n\r\n\r\n\r\nconst component = () => (\r\n    <div>\r\n        <h2 id='ch12'>12. The promise of the Safe Network</h2>\r\n\r\n\r\n\r\n        <p>The Safe Network is still in development. While many features and functionalities have already proven themselves under test conditions others, including Safe Network Token, are still to come.&nbsp; As with any cutting-edge experimental technology, the proof of the pudding is in the eating. But let&rsquo;s assume for a moment that the Network is successful and is widely adopted for various use cases including Internet browsing, IoT connectivity, data security, personal information management, medical records and more.</p>\r\n\r\n        <p>What would that world look like? First, most cyber attack strategies deployed today would be dead in the water. DDoS would not work as the Network would simply route around the affected nodes. Viruses and malware would be extremely limited in their depth of penetration. Ransomware would not raise a single dollar. Cyber attacks aimed at disabling national infrastructure or taking control of a driverless car would be extremely hard to pull off. Medical records and other personal data would be ours and ours alone, to share as we see fit. For users there can be a single sign-on to multiple services. XOR networking with opportunistic caching promises faster speeds, data storage should be extremely cheap and the Network will offer high levels of availability. For developers having a single storage architecture to address has the potential to simplify the systems programmer&rsquo;s job. And data deduplication would allow for both simplicity and resource savings.</p>\r\n\r\n\r\n\r\n        <div className=\"Pullquote\">\"There would be a rebalancing of power from the data-haves to the data have-nots\"</div>\r\n\r\n\r\n\r\n        <p>The Internet giants of today would no longer be able to harvest our data without our say so, nor could government spooks eavesdrop over their shoulders. There would be a rebalancing of power from the data-haves to the data have-nots. Censorship would be impossible and data could not be erased. Because the cost of entry will be low and access unrestricted, the ongoing net neutrality debate will end, and neutrality will have won the day.</p>\r\n\r\n        <p>People in places with poor or restricted access to information will have those blockers lifted. Some may even make a decent living earning Safe Network Token. New business models based on consent would spring up in a world where data storage and networking and eventually computing power is a commodity, and the world of information will be a much more level playing field.</p>\r\n\r\n        <p>Isn&rsquo;t this all a bit idealistic? Well yes of course, but that&rsquo;s the nature of visions. Not everything will work as planned and we need to be hard-headed about that. Techno-utopianism is a dangerous thing. There are both predictable and unpredictable consequences of taking on the status quo, and indeed of deploying any new technology, and not all of them will be positive. Nevertheless, given where we are today, and where we are headed with the IoT, something like the Safe Network is most definitely needed to redress the power imbalance and to secure the data-driven future.</p>\r\n\r\n        <h3>Roadmap</h3>\r\n\r\n        <p>As with all experimental research-driven projects the rate of progress is unpredictable, and MaidSafe avoid giving hard deadlines. However, there is a roadmap at <a href=\"https://safenetwork.tech/timeline/\">https://safenetwork.tech/timeline/</a> in which the next developments are laid out. The next MVP, Safe Fleming, will allow anyone with a computer and an internet connection to join the Network.</p>\r\n\r\n        <h2>About MaidSafe</h2>\r\n\r\n\r\n\r\n        <p>MaidSafe is a company founded by David Irvine in 2006 with a mission to provide security and privacy for everyone by building a better digital world. This new platform is the Safe Network, which is the world&rsquo;s first autonomous and decentralized data network. The Network is made up of the unused hard drive space, processing power and bandwidth of its users. The Safe Network will include storage, peer-to-peer communications, transactions, Internet functionality and a wide variety of apps to name a few of its features. This paper was written and produced by members of the Safe Network Forum independently of MaidSafe.&nbsp;</p>\r\n\r\n        <p>Join the debate at <a href=\"https://safenetforum.org/\">https://safenetforum.org</a>&nbsp;</p>\r\n\r\n        <p>Website: <a href=\"http://www.safenetwork.tech/\">www.safenetwork.tech</a></p>\r\n\r\n        <p>Developer forum: <a href=\"http://www.safedev.org/\">forum.safedev.org</a></p>\r\n\r\n        <p>Developer hub: <a href=\"https://hub.safedev.org/\">https://hub.safedev.org/</a></p>\r\n\r\n        <p>Github: <a href=\"https://github.com/maidsafe\">https://github.com/maidsafe</a></p>\r\n\r\n        <p>Twitter: <a href=\"https://twitter.com/maidsafe\">https://twitter.com/maidsafe</a></p>\r\n\r\n        <p>Twitter: <a href=\"https://twitter.com/maidsafe\">https://twitter.com/safenetworktech</a></p>\r\n\r\n        <p>Reddit: <a href=\"https://reddit.com/r/safenetwork\">https://reddit.com/r/safenetwork</a></p>\r\n\r\n        <p>Telegram: <a href=\"https://t.me/safenetwork\">https://t.me/safenetwork</a></p> \r\n</div>\r\n);\r\n\r\nexport default component;\r\n","\r\nimport React from 'react';\r\n\r\n\r\n\r\n\r\nconst component = () => (\r\n    <div>\r\n       \r\n</div>\r\n);\r\n\r\nexport default component;\r\n","import React from 'react';\r\n\r\nconst component = (prop) => (\r\n    <div>\r\n    <div className='header' align={ 'center' }>\r\n        <h1>The Safe Network Primer</h1>\r\n<p><strong>An introductory guide to the world's first fully autonomous data and communications network</strong></p>\r\n        <p>Last update: November 2021</p>\r\n    </div>\r\n        <hr />\r\n        <div align={' left '}>\r\n            <p>Major changes since last update:\r\n            <ul>\r\n  \r\n                    <li>Implementation of Digital Bearer Certificates </li>\r\n                    <li>Implementation of Anti-Entropy </li>\r\n                    <li>Implementation of conflict-free data types (CRDTs)</li>\r\n                    <li>New data CRDT types Register, Multimap</li>\r\n                    <li>Design for n-of-k user authorization</li>\r\n\r\n            </ul>\r\n            </p>\r\n            </div>\r\n        <hr />\r\n     </div>\r\n);\r\n\r\nexport default component;\r\n","import React from 'react';\r\nfunction Topbar(props) {\r\n    return (\r\n        <div>\r\n            <div className=\"Topbar\" style={{ backgroundColor: props.bgcol, height: \"10px\" }} />\r\n         \r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Topbar;\r\n","import React from 'react';\r\nimport { Intro, Chap1, Chap2, Chap3 } from './pages';\r\nimport Chap4 from './pages/Chap4';\r\nimport Chap5 from './pages/Chap5';\r\nimport Chap6 from './pages/Chap6';\r\nimport Chap7 from './pages/Chap7';\r\nimport Chap8 from './pages/Chap8';\r\nimport Chap9 from './pages/Chap9';\r\nimport Chap10 from './pages/Chap10';\r\nimport Chap11 from './pages/Chap11';\r\nimport Chap12 from './pages/Chap12';\r\nimport Chap13 from './pages/Chap13';\r\nimport './App.css';\r\nimport Header from './Header';\r\nimport Topbar from './Topbar';\r\n\r\n\r\n\r\nfunction App() {\r\n\r\n    return (\r\n     \r\n        <div className=\"App\">\r\n\r\n        \r\n          <Header />\r\n          <Intro />\r\n          <Topbar bgcol=\"#1f3a80\" word=\"\" />  \r\n          <Chap1 />\r\n          <Topbar bgcol=\"#1f3a70\" word=\"\" />  \r\n          <Chap2 />\r\n          <Topbar bgcol=\"#1f3a60\" word=\"\" />  \r\n          <Chap3 />\r\n          <Topbar bgcol=\"#1f3a50\" word=\"\" />          \r\n         <Chap4 />\r\n         <Topbar bgcol=\"#1f3a40\" word=\"\" />         \r\n         <Chap5 />\r\n         <Topbar bgcol=\"#1f3a30\" word=\"\" />\r\n         <Chap6 />\r\n         <Topbar bgcol=\"#1f3a20\" word=\"\" />\r\n         <Chap7 />\r\n         <Topbar bgcol=\"#1f3a10\" word=\"\" />\r\n         <Chap8 />\r\n         <Topbar bgcol=\"#1f3b90\" word=\"\" />\r\n         <Chap9 />\r\n         <Topbar bgcol=\"#1f3b80\" word=\"\" />\r\n         <Chap10 />\r\n         <Topbar bgcol=\"#1f3b70\" word=\"\" />\r\n         <Chap11 />\r\n         <Topbar bgcol=\"#1f3b60\" word=\"\" />\r\n         <Chap12 />\r\n         <Topbar bgcol=\"#1f3b50\" word=\"\" />\r\n         <Chap13 />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.1/8 is considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl)\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready.then(registration => {\r\n      registration.unregister();\r\n    });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(<App />, document.getElementById('root'));\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.register();\r\n"],"sourceRoot":""}