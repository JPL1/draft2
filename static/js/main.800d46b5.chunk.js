(this.webpackJsonpprimer=this.webpackJsonpprimer||[]).push([[0],{10:function(e,t,a){},11:function(e,t,a){"use strict";a.r(t);a(1);var n=a(3),i=a.n(n),s=(a(8),a(0)),o=function(){return Object(s.jsxs)("div",{className:"intro",children:[Object(s.jsx)("h2",{id:"ch0",children:"A brief introduction"}),Object(s.jsx)("p",{children:"Technological progress is a perpetual process of automation and abstraction. Difficult and complex tasks are made simple by software and machines until they are completely taken for granted. Technology moves on, taking down new blockers in the path to progress as it goes. A good example of this is cloud computing, where once complex server administration tasks have been replaced, from the point of view of the consumer, by point-and-click."}),Object(s.jsx)("p",{children:"The Safe (Secure Access For Everyone) Network takes this further, automating the entire network of interconnected machines, making it autonomous, secure, anonymous and capable of\xa0 storing, protecting and delivering data without any human involvement at all."}),Object(s.jsx)("p",{children:"The Safe Network is the vision of MaidSafe, a Scottish software company working in the field of decentralized computer networking. It is an autonomous peer-to-peer network created by linking together users' computers and smartphones that's designed to solve many of the current technical, managerial and societal problems exacerbated by centralized networks: a lack of privacy and data security, censorship and the massive consolidation of control by a few powerful actors.\xa0"}),Object(s.jsxs)("p",{children:["(In case this sounds familiar, members of MaidSafe acted as advisers for HBO\u2019s ",Object(s.jsx)("i",{children:"Silicon Valley"})," TV series in which a startup tries to reinvent the Internet!)"]}),Object(s.jsx)("p",{children:"The Network is \u2018trustless\u2019, with no central point of control and no single point of failure. With connectivity and security taken care of, the Network is simple from the point of view of developers, with the burden of having to worry about low-level storage, networking, backups and computing resources removed. For people using the Network to store and share data and messages the burden of ensuring the security of precious information would be drastically reduced."}),Object(s.jsx)("p",{children:"Anyone with a connected device can can use the Network anonymously to store data or peruse public information on it, and anyone (subject to a resource test) can join the Network anonymously as a provider."}),Object(s.jsx)("p",{children:"The Safe Network is a platform on which new digital worlds can be constructed."}),Object(s.jsx)("p",{children:"This guide outlines how the Safe Network is constructed to achieve these aims. While it is somewhat technical in places, it's intended very much as an overview, and even those with very little technical knowledge should be able to gain a good working understanding of the Safe Network. For those requiring more depth, there are plenty of pointers as to where they can find the relevant information."}),Object(s.jsx)("div",{bgcol:"#1f3a60",height:"10px"}),Object(s.jsx)("h2",{children:"Contents"}),Object(s.jsxs)("p",{children:[Object(s.jsx)("br",{}),Object(s.jsx)("a",{href:"#ch1",children:"1. Background and fundamentals"}),Object(s.jsx)("br",{}),Object(s.jsx)("a",{href:"#ch2",children:"2. A fully autonomous data network"}),Object(s.jsx)("br",{}),Object(s.jsx)("a",{href:"#ch3",children:"3. Nodes and Clients"}),Object(s.jsx)("br",{}),Object(s.jsx)("a",{href:"#ch4",children:"4. The architecture of the Safe Network"}),Object(s.jsx)("br",{}),Object(s.jsx)("a",{href:"#ch5",children:"5. Node Age"}),Object(s.jsx)("br",{}),Object(s.jsx)("a",{href:"#ch6",children:"6. Encryption and authentication"}),Object(s.jsx)("br",{}),Object(s.jsx)("a",{href:"#ch7",children:"7. Network-wide consensus not required "}),Object(s.jsx)("br",{}),Object(s.jsx)("a",{href:"#ch8",children:"8. Safe Network Token and Digital Bearer Certificates"}),Object(s.jsx)("br",{}),Object(s.jsx)("a",{href:"#ch9",children:"9. Safe Network Anti-Entropy"}),Object(s.jsx)("br",{}),Object(s.jsx)("a",{href:"#ch10",children:"10. Data types"}),Object(s.jsx)("br",{}),Object(s.jsx)("a",{href:"#ch11",children:"11. How Safe Network defends against common types of cyberattack"}),Object(s.jsx)("br",{}),Object(s.jsx)("a",{href:"#ch12",children:"12. The promise of the Safe Network"})]})]})},r=function(){return Object(s.jsxs)("div",{className:"chapter",children:[Object(s.jsx)("h2",{id:"ch1",children:"1.\xa0\xa0 Background and fundamentals"}),Object(s.jsxs)("h3",{children:[Object(s.jsx)("br",{})," Background"]}),Object(s.jsxs)("p",{children:[Object(s.jsx)("br",{})," Decentralized or peer-to-peer (P2P) networks are not new. Since the release of Napster on June 1, 1999, they have taken the world by storm, particularly for file sharing. These networks allow users from all over the world to connect to each other and share data such as movies, books and music. In 2010 more than half of all Internet traffic was attributed to P2P.",Object(s.jsx)("br",{})," ",Object(s.jsx)("br",{})," But the use of these technologies is not limited to simple file sharing. Freenet was launched in March, 2000 allowing people to publish decentralized websites (Freesites). Freesites are not stored on central servers but instead are distributed across the machines of the encrypted network's users.",Object(s.jsx)("br",{})," ",Object(s.jsx)("br",{})," A little after that, the BitTorrent protocol was created by Bram Cohen. BitTorrent was and still is particularly well suited to transferring large files in a P2P fashion, allowing simultaneous downloads from multiple peers.",Object(s.jsx)("br",{})," ",Object(s.jsx)("br",{})," The next notable development arrived after the financial crash which very nearly brought the global economy to its knees. In 2009 Satoshi Nakamoto released Bitcoin and gave the world a 'trustless' decentralized digital currency that is not controlled by bank, government or institution. The blockchain - the immutable ledger that records all Bitcoin transactions - was something very new, solving at a stroke the difficult and long-standing problem of creating a trustless source of the truth for transactions.\xa0 The ownership of 'addresses' in the network can be proven by the usage of private keys in a Public Key Infrastructure (PKI) - hence the term cryptocurrency; however, connections between Bitcoin nodes are not fully encrypted.",Object(s.jsx)("br",{})," ",Object(s.jsx)("br",{})," The Safe Network is the next big step in the evolution of P2P networks, combining the vision of decentralized file sharing and decentralized web sites together with an internal cryptocurrency - Safe Network Token (SNT) (formerly known as Safecoin) - and several additional innovations to enhance security, privacy, performance and stability. MaidSafe, a Scottish company with developers around the world, has been researching and developing this project since 2006.\xa0 Since that time, many more people have come to recognize the vital importance of a global, secure and private decentralized platform for storage and communication.",Object(s.jsx)("br",{})," "]}),Object(s.jsx)("h3",{children:"20 Fundamental Principles of the Safe Network"}),Object(s.jsx)("p",{children:" There are a number of core ideas that have driven each stage of the design of the Safe Network. These can be distilled into the following 20 fundamental principles."}),Object(s.jsx)("p",{children:"The Safe Network will:"}),Object(s.jsxs)("ol",{children:[" ",Object(s.jsxs)("li",{children:["Allow a person to create an account and login anonymously and without intervention. ",Object(s.jsx)("br",{})," Creating a new account and logging into the Network will never require a third party."]}),Object(s.jsxs)("li",{children:["Enable users to securely and with no controlling intermediaries share information and messages.",Object(s.jsx)("br",{}),"The Safe Network will never allow third parties to either read or store the information sent by a user without that user\u2019s consent."]}),Object(s.jsx)("li",{children:"Allow the transfer of the Network currency Safe Network Token to any user free of transaction costs."}),Object(s.jsxs)("li",{children:["Enable Users to anonymously create and share data worldwide. ",Object(s.jsx)("br",{}),"The Network will always ensure that the user has the ability to send transaction messages and posts with a temporary single-use ID that is not linked to any known identity on the Network."]}),Object(s.jsx)("li",{children:"Let anyone browse content anonymously and free of charge and without the need to create an account."}),Object(s.jsx)("li",{children:"Allow users to associate multiple identities with their account."}),Object(s.jsx)("li",{children:"Let users utilize any of their identities to send/receive Safe Network Token."}),Object(s.jsx)("li",{children:"Store data in perpetuity. All public/published data on the Network will be immutable and available on the Network indefinitely."}),Object(s.jsx)("li",{children:"Never require passwords to be stored on the Network or on machines used to access the Network."}),Object(s.jsx)("li",{children:"Allow any user, on any machine, to access the Network leaving no trace of their presence or activity on the machine."}),Object(s.jsxs)("li",{children:["Scrub Client IP addresses from the first hop. ",Object(s.jsx)("br",{}),"As soon as you have connected to the network, your IP address is wiped."]}),Object(s.jsxs)("li",{children:["Only accept more Vaults (networked storage provided by users' machines) when it needs them. ",Object(s.jsx)("br",{})," This is to prevent a bad actor from flooding the network with poorly performing or malicious Vaults and also to enable the Network to balance its resources automatically according to demand."]}),Object(s.jsxs)("li",{children:["Increase farming rewards when it needs more resources (e.g. more Vaults to increase storage capacity) and decrease rewards when resources are plentiful. ",Object(s.jsx)("br",{}),"This is the primary mechanism for balancing supply and demand."]}),Object(s.jsxs)("li",{children:["Rank nodes over time and increase trust in higher ranked nodes.",Object(s.jsx)("br",{}),"The aim is to maximize performance and defend against certain attacks."]}),Object(s.jsxs)("li",{children:["Not have servers! ",Object(s.jsx)("br",{}),"The Safe Network will never rely on servers (as the term is traditionally understood) as to do so introduces a third-party weakness that undermines the entire Network."]}),Object(s.jsxs)("li",{children:["Digitally sign all transactions. ",Object(s.jsx)("br",{}),"To ensure that the transactions have been authorized in accordance with the rules of the Network."]}),Object(s.jsx)("li",{children:"Ensure that Client-to-Client direct messages (i.e. those not transmitted via other nodes in the Network) are free."}),Object(s.jsxs)("li",{children:["Never use time as a network tool. ",Object(s.jsx)("br",{})," There can be no concept of time in a truly decentralized network without reaching out to centralized servers and services."]}),Object(s.jsx)("li",{children:"Only use encrypted services and encrypted traffic."}),Object(s.jsxs)("li",{children:["Allow real-time upgrades in a secure manner. ",Object(s.jsx)("br",{}),"The Network will refuse upgrades that could break it."]})," "]}),Object(s.jsx)("p",{children:"We expand on these fundamental principles in the chapters that follow. Combined they aim to give all users the freedom to safely store data on the Network, to share information with others securely, to publish websites cheaply and easily and to communicate using secure channels and apps."}),Object(s.jsxs)("p",{children:["For a fuller version of this list see the Safe Network website. ",Object(s.jsx)("a",{href:"https://safenetwork.tech/fundamentals/",children:"https://safenetwork.tech/fundamentals/"})]})]})},c=a.p+"static/media/networking_layers.f0097177.jpg",h=a.p+"static/media/stack.4ed8d5de.png",l=function(){return Object(s.jsxs)("div",{className:"chapter",children:[Object(s.jsx)("h2",{id:"ch2",children:"2. A fully autonomous data network"}),Object(s.jsx)("p",{children:"To enable Secure Access For Everyone, Safe is an \u2018autonomous data network\u2019. This means it is capable of performing networking and storage tasks such as managing and optimizing workloads, routing, failover, authentication and access control without any human intervention. Opportunities for powerful groups to aggregate control or prevent access are minimized."}),Object(s.jsx)("p",{children:"Unlike the current Internet, Safe infrastructure is not defined by a set of federated servers, VMs, owned storage locations or identifiable nodes. Unlike blockchains, it is designed to store and manage live data rather than pointers to data and to transact in real-time. And unlike BitTorrent, it does not rely on centralized components of the Web to locate and track files."}),Object(s.jsx)("div",{className:"Full-width-pic",align:"center",children:Object(s.jsx)("img",{className:"Img",src:c,alt:"Networking layers",align:"center"})}),Object(s.jsx)("p",{children:"Many features in the Safe Network are innovations, but there is no intention to reinvent the wheel. It builds on existing decentralized technologies such as BitTorrent and Kademlia and is based on the physical and data infrastructure of the Internet. Early development of Safe happened in parallel with blockchain, and it has taken an alternative route to solve the decentralization puzzle."}),Object(s.jsx)("p",{children:"The Safe Network can be seen as a secure, encrypted, intelligent layer that sits on top of the current Internet, complementing the top three layers in the OSI model and adding resources in the application layer. This enables secure, anonymous, decentralized data storage and networking."}),Object(s.jsx)("p",{children:"Going a little deeper, Safe introduces some changes to the networking and application layers as shown below."}),Object(s.jsx)("p",{children:"The Safe Network core libraries are written in the Rust programming language. The diagram below shows the basic hierarchy."}),Object(s.jsx)("div",{className:"Full-width-pic",align:"center",children:Object(s.jsx)("img",{className:"Img",src:h,alt:"Stack",align:"center"})}),Object(s.jsx)("h3",{children:"quic-p2p"}),Object(s.jsx)("p",{children:"QUIC peer-to-peer (quic-p2p or qp2p) is based on the QUIC protocol created at Google. It is a networking library that enables peers on a P2P network to communicate securely, and to re-join the network without requiring a hard-coded list of known peers; such a list would be an obvious security hole. It supports multiple protocols allowing ordinary PCs and smartphones to connect to each other and is cryptographically secure."}),Object(s.jsx)("h3",{children:"Network"}),Object(s.jsx)("p",{children:"On top of qp2p sits the network overlay which forms the \u2018brain\u2019 of the Safe Network. Its purpose is to create a decentralized Internet and route information between the Nodes."}),Object(s.jsx)("p",{children:"Network routing is based on an algorithm that extends Kademlia DHT routing (see Chapter 4). It uses 32-byte (256 bit) XOR addresses to locate data on the network. It is mathematically guaranteed that messages can be routed from any part of the network to any other destination."}),Object(s.jsx)("p",{children:"Routing works on the principle of Group Consensus. For actions that mutate data or change the network a supermajority of the group of Nodes responsible for undertaking that action must first agree that it is valid."}),Object(s.jsx)("p",{children:" In order to guarantee strong consistency, the Network uses conflict-free replicated data types (CRDTs) for storing data, Byzantine Reliable Broadcast (BRB) for messaging, and Boneh-Lynn-Shacham (BLS) threshold cryptography to reach local consensus (See Chapter 7)."}),Object(s.jsx)("p",{children:"Client connections managed by qp2p are mediated via the Client API. Sitting above that, the Safe Network API allows clients such as end user devices and apps to make use of the network, including storing, sharing and reading data. There is a command line interface (CLI) for this purpose, and apps written in Rust can access network functions directly via the API. Apps written in other languages, including the Safe Browser - a JavaScript app, do the same via the language bindings layer. "}),Object(s.jsx)("p",{children:"Nodes and Clients provide the main means for users to interact with the Network, either by providing resources in return for payment by running a Node or by storing data and browsing the Safe web as a Client. They are discussed further in the next chapter."}),Object(s.jsx)("p",{children:"All Safe Network code is open source and licensed under GPLv3."}),Object(s.jsx)("h3",{children:"Tell me more\u2026"}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{href:"https://github.com/maidsafe/safe_network",children:" The Safe Network Core. API message definitions, routing and nodes, client core API. (Github)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{href:"https://github.com/maidsafe/quic-p2p",children:" quic-p2p - a peer-to-peer communications library for Rust based on QUIC protocol (Github)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{href:"https://docs.rs/quinn/0.7.2/quinn/index.html",children:" Quinn - QUIC protocol in Rust"})}),Object(s.jsx)("p",{children:"\xa0"})]})},d=a.p+"static/media/app_auth_flow.35eb1829.jpg",p=function(){return Object(s.jsxs)("div",{className:"chapter",children:[Object(s.jsx)("h2",{id:"ch3",children:"3. Nodes and Clients"}),Object(s.jsx)("p",{children:"The existing Internet is formed of servers and clients. Clients request data and servers provide it. When you browse the Web, you enter the address of the page into the browser (client software) and the browser requests data from the website in question which is stored on a specific server (server software)."}),Object(s.jsx)("p",{children:"The Safe Network does not use a client-server model. Instead stored data is spread across a network made up of the spare computing resources of its users. When a request for some content is made, a message goes out across the Network and machines that hold the constituent parts of that content return them to the requester."}),Object(s.jsx)("p",{children:"Safe has two basic components: Nodes and Clients."}),Object(s.jsxs)("div",{className:"Keep-it-simple",children:[Object(s.jsx)("h3",{children:"Keep it simple!"}),Object(s.jsx)("p",{children:"The Safe Network is comprised of its users' machines (Nodes) linked together by Node software which routes data and messages securely between them. These machines provide the Network's storage by allocating a portion of their hard drives for this purpose \u2013 and earning the Safe Network Token currency in return."}),Object(s.jsx)("p",{children:"You don't have to run a Node to use the Network any more than you have to run a web server to use the Web. Client software allows users create a Safe (a secure, private data store), store data and browse the Safe web securely and anonymously without being part of the Network. A single computer can run both Node and Client software at the same time.\xa0\xa0 "})]}),Object(s.jsx)("h3",{children:"The Node"}),Object(s.jsx)("p",{children:"The Safe Network is formed of interconnected machines running Node software. Node software connects the devices to each other using existing protocols like TCP and UDP, manages data and routes it around the Network. It allows users to store data on their devices, potentially earning SNT currency in return. This process of providing a service in return for a reward is analogous to Bitcoin mining. On the Safe Network it's called Farming and the people who provide the resources are called Farmers (see Chapter 8)."}),Object(s.jsx)("p",{children:"Node software is a small executable file that connects the user\u2019s machine to the Safe Network, turning it into a routing node and also allocating some disk space for storage. It manages the storage of data chunks on the user\u2019s computer and in that way provides storage capacity to the Network. It also routes and caches data chunks (these are encrypted) over the Network via fully encrypted connections to other Nodes. Nodes are clustered logically into small groups, each of which is responsible for looking after the data stored within a certain range of Network addresses, called a Section (see Chapter 4)."}),Object(s.jsxs)("div",{className:"What-does-that-mean",children:[Object(s.jsx)("h3",{children:"What does that mean?"}),Object(s.jsx)("p",{children:"quic-p2p/qp2p \u2013 a software library that allows machines to connect to each other in a secure and reliable peer-to-peer fashion and to reconnect after leaving without requiring a hard-coded list of other devices."}),Object(s.jsx)("p",{children:"Node \u2013 the machines that make up the Safe Network run Node software. Nodes provide routing and communications capabilities to the Network and also store data in the form of chunks, for which they can earn Safe Network Token (Farming) when that data is retrieved."}),Object(s.jsx)("p",{children:"Client \u2013 a program that allows users to connect to the network and make use of its services."}),Object(s.jsx)("p",{children:"Safe \u2013 a secure store on the Network."}),Object(s.jsx)("p",{children:"Safe Browser \u2013 a browser for surfing the Safe web."}),Object(s.jsx)("p",{children:"Authenticator - enables users to create and access Safes without going via a server (Self-Authentication) and also to approve or deny access to their data by apps."}),Object(s.jsx)("p",{children:"CLI - command line interface for typing commands into a terminal rather than using a GUI."}),Object(s.jsx)("p",{children:"Self-Authentication - enables secure and anonymous connection to the Network without a central server to mediate the login process."}),Object(s.jsx)("p",{children:"Farming \u2013 earning Safe Network Token by providing resources (Storage, Bandwidth, CPU, online time) to the Network"}),Object(s.jsx)("p",{children:"Safe Network Token \u2013 the currency of the Safe Network, earned by storing data, spent by uploading data."})]}),Object(s.jsx)("p",{children:"The forming and splitting of Sections happens in a fully autonomous way as Nodes join and leave the Network. The same goes for the routing of chunks across the Network. There are no central servers, authorities or agents needed to maintain this Network (unlike, say, like BitTorrent which uses trackers)."}),Object(s.jsx)("p",{children:"Nodes fulfil several different functions. They route and store chunks of data; they cryptographically check messages; they cluster into  Sections each of which  which manage a crtain portion of the Network; and they take decisions about what should and should not happen, such as whether a new Node should be allowed to join the Network."}),Object(s.jsx)("p",{children:"Running a Node in the Safe Network is called Farming because users look after the data until it is needed, at which point they may earn payment for their efforts (see Chapter 8)."}),Object(s.jsx)("h3",{children:"The Client"}),Object(s.jsx)("p",{children:"Just as you don\u2019t need to run a web server to use the Web, so you don\u2019t have to run a Node to access the Safe Network. Ordinary users interact with the network via the Client. Currently the Client software provided is the command line interface (CLI) tool. Earlier iterations of the Network included a Browser and a user-friendly Safe Network App together with an  Authenticator. These will be revisited in due course."}),Object(s.jsx)("p",{children:"Self-Authentication is a key innovation of the Network. At no point does the Network ever store a user\u2019s credentials. Therefore, there is no chance of passwords being attacked on the Network. Instead, the user can create a Safe, a private data store, and login securely and anonymously with no central server required to mediate the login process or trusted third parties to store and manage the users\u2019 credentials. With Self-Authentication, the user generates his or her own credentials which are stored on the Safe Network in such a way that they are cryptographically obscured from all other parts of the Network."}),Object(s.jsx)("p",{children:"Because users control their own data, decentralized applications (DApps) such as the Safe Browser, require the user to authorize them to manipulate their data. For the user, the authorization process is simply a matter of clicking a button."}),Object(s.jsx)("div",{className:"Full-width-pic",align:"center",children:Object(s.jsx)("img",{className:"Img",src:d,alt:"App auth flow",width:"70%",align:"center"})}),Object(s.jsx)("p",{children:"Any user (even if they have not created a Safe) can request (GET) data from the network for free. For example, they can browse a safe:// site or download a publicly-posted song or movie for zero cost. It\u2019s only when the user wants to store (PUT) data onto the network that an account with Safe Network Token is needed."}),Object(s.jsx)("h3",{children:"Tell me more..."}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{href:"http://www.enterprisenetworkingplanet.com/datacenter/datacenter-blog/on-the-verge-of-autonomous-networking.html",children:"On the Verge of Autonomous Networking (Enterprise Networking Planet)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{href:"http://docs.maidsafe.net/Whitepapers/pdf/AutonomousNetwork.pdf",children:"Autonomous Network (MaidSafe whitepaper, 2010)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{href:"https://github.com/maidsafe/safe_client_libs",children:"Safe Client libraries (Github)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{href:"https://github.com/maidsafe/safe-network-app",children:"Safe Network App (Github)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{href:"https://github.com/maidsafe/safe_browser",children:"Safe Browser (Github)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{href:"https://github.com/maidsafe/safe_browser",children:"Safe Mobile Browser (Github)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{href:"https://github.com/maidsafe/sn_cli#safe-network-cli",children:"Safe CLI User Guide -  a CLI (Command Line Interface) for the Safe Network (Github)"})})]})},u=a.p+"static/media/xor_addresses.f75d3162.jpg",b=function(){return Object(s.jsxs)("div",{className:"chapter",children:[Object(s.jsx)("h2",{id:"ch4",children:"4. The architecture of the Safe Network"}),Object(s.jsx)("p",{children:"Browsing sites and storing data on the Safe Network is as simple as on the current Web but with greatly enhanced privacy, security and control. The Safe Network is designed with ease of use in mind for app developers, too. Developing simple apps for Safe is just a short step from what developers are familiar with in terms of APIs and methodologies. However, those wishing to perform more complex system-level tasks will need to go deeper into its architecture - there are some big differences between traditional client-server systems and decentralized architectures. This chapter provides a brief introduction to the topic."}),Object(s.jsx)("h3",{children:"Sections"}),Object(s.jsx)("p",{children:"The first step in understanding the architecture of the Safe Network is to take a look at distributed hash tables (DHTs)."}),Object(s.jsx)("p",{children:"Petar Maymounkov and David Mazi\xe8res released the Kademlia distributed hash table in 2002. The idea is that nodes form a network overlay, and are identified with a different node identification system. So a node with an IP address of 96.251.182.97 might have a 256 bit XOR address that looks like this: 17846cb8a4b53c9e44c616d2415a15984283eee975a1dac8f488dd91d0aed1cd."}),Object(s.jsx)("p",{children:"Bitwise Exclusive OR (XOR) has the feature that each address is a unique distance from any other address in the entire address range. XOR distance bears no relation to physical distance. Indeed, two pieces of data on the network may be very close XOR-wise but be sitting on machines located on opposite sides of the world."}),Object(s.jsxs)("p",{children:["MaidSafe developed an enhancement to Kademlia by splitting the 256-bit address range into so-called 'Disjoint Sections', or Sections for short. A 256-bit address space has 2",Object(s.jsx)("sup",{children:"256"})," -1 possible addresses which is an extremely large number to manage, but it can be split up into smaller Sections based on address, with each Section being managed by a group of Nodes (also generally known as a Section)."]}),Object(s.jsx)("p",{children:"The Nodes managing a Section must reach agreement (consensus) before authorising any mutation (Network-changing event) happening within that Section. As a collective, they can also provide \u2018section authority\u2019 to messages that travel over the wider Network so that other Nodes and/or Sections can cryptographically verify the validity of the message and the action it contains. These Section signatures are stored in \u2018SectionChains\u2019 which are secured and held by members of that Section, and by neighbouring Sections. This is known as group agreement (or local consensus)."}),Object(s.jsxs)("div",{className:"What-does-that-mean",children:[Object(s.jsx)("h3",{children:"What does that mean?"}),Object(s.jsx)("p",{children:"Distributed hash table \u2013 a map of where data is stored on a distributed network."}),Object(s.jsx)("p",{children:"XOR networking \u2013 a way of randomizing the physical location of data on a distributed network and ensuring each location is unique."}),Object(s.jsx)("p",{children:"Section \u2013 a subset of addresses on the network. The word Section is also applied to a group of Nodes that manage a subset of addresses."}),Object(s.jsx)("p",{children:"Supermajority \u2013 larger than a simple majority, so e.g 5 out of 7 rather than 4 out of 7."}),Object(s.jsx)("p",{children:"Elders \u2013 Nodes with decision-making powers, the oldest 7 Nodes in a Section (see Chapter 5)."}),Object(s.jsx)("p",{children:"Adults \u2013 Nodes that perfom storage duties but do not make decisions (see Chapter 5)."}),Object(s.jsx)("p",{children:"Infants \u2013 Nodes witing to join the Network but not yet accepted."}),Object(s.jsx)("p",{children:"Agreement \u2013  when the required proportion of decision-making Nodes (Elders - see Chapter 5) in a Section vote an event to be valid."}),Object(s.jsx)("p",{children:"group_size \u2013 a parameter stipulating the minimum number of Elders in a Section (curently set at 7)."}),Object(s.jsx)("p",{children:"Bootstrapping \u2013 starting up the Safe Network by connecting together a minimum number of Nodes. Bootstrapping is also used to describe a new Node joining the Network."}),Object(s.jsx)("p",{children:"Bootstrap node \u2013 a node to which a new Node initially connects. Any Node can potentially be a bootstrap node, so long as its IP address is written in the Node\u2019s configuration file, or, for subsequent connections, its cache. "}),Object(s.jsx)("p",{children:"Hash function \u2013 a function used to map data of arbitrary size to data of fixed size (e.g. a 256-bit string of characters) called a hash. Any change to the original data will result in a completely different hash. Safe uses the SHA-3 hash function."}),Object(s.jsx)("p",{children:"SectionChain \u2013 a sequence of public keys, each signed by the previous one, that's updated every time an Elder is changed and acts as proof that the Section is valid."}),Object(s.jsx)("p",{children:"Sharding \u2013 on Safe Network this refers to the splitting of the Network into individual sections, each managed by a unique Group of Nodes."})]}),Object(s.jsx)("p",{children:"Importantly, on joining or rejoining the Safe Network a Node cannot simply pick its own XOR address - in other words, it can\u2019t choose the Section it will be part of. Instead, it has to wait to be allocated to a Section that is chosen by the Network. When this occurs, the Node receives the Section's Routing Table and learns the exact unique address range (and therefore the data) that it will be responsible for."}),Object(s.jsx)("p",{children:"Content stored on the Safe Network is first broken into chunks, hashed and then encrypted (see Chapter 6). Those chunks are run through a hashing algorithm to create a unique 256-bit hash for each chunk. Only chunks that are exactly identical will have the same hash value. This hash serves as the XOR address on the Network where that chunk will be stored, which in turn determines the Section that will manage it."}),Object(s.jsx)("p",{children:"Chunks with hashes that lie within a certain address range (say 000010... to 000011...) will be secured, stored and managed by a the Section that is closest (in XOR terms) to that address. The membership of this Section will change over time as new Nodes join and others leave."}),Object(s.jsx)("p",{children:"When the Network starts up, the initial Nodes are responsible for the whole 256-bit address range. But as more Nodes join the Network will split into two Sections. As still more Nodes join, the Sections will continue to split, each managed autonompusly by its Elders (Nodes with decision-making powers, see Chapter 5). This is known as \u2018Sharding\u2019 and is a crucial part of the way in which the Network solves the challenges of scalability."}),Object(s.jsx)("p",{className:"Pullquote",children:'"The hash of a chunk of data serves as the XOR address on the Network where it will be stored, which in turn determines the Section that will manage it"'}),Object(s.jsx)("div",{className:"Full-width-pic",align:"center",children:Object(s.jsx)("img",{className:"Img",src:u,alt:"Networking layers",width:"70%",align:"center"})}),Object(s.jsx)("p",{children:Object(s.jsx)("em",{children:"Each Section (range of XOR addresses) is managed by a group of Nodes. The most trusted Nodes in a Section are called Elders. Elders have voting rights and can also communicate with Elders in other Sections."})}),Object(s.jsx)("p",{children:" Experiments are ongoing to find the optimum number of Nodes per Section, but it will probably be around 100."}),Object(s.jsx)("p",{children:"If a particular Section grows significantly in the eyes of the Network, it will split into two smaller Sections. "}),Object(s.jsx)("p",{children:"If a Section finds its membership dropping below a certain limit (group_size) then it requests that Nodes be relocated to it earlier or that it has priority for Infant nodes joining the network. Given these balancing mechanisms is extremely unlikely that a Section will become too small (~7 nodes) to be viable."}),Object(s.jsx)("h3",{children:"Agreement"}),Object(s.jsx)("p",{children:"The Elder Nodes managing a Section must reach consensus among themselves on Network events under their control before they can happen. They also \u2018Section-sign\u2019 messages that travel over the wider Network. Elders in Sections recieving these messages need to be sure they are from from valid Sections. Because Section membership is fluid, every time it changes (Elder churn) a new public key is created and signed by the current Elders using the previous key. This series of public keys, each signed by the previous one is called a SectionChain and serves to prove the validity of the Section (See BLS-DKG, Anti-Entropy, Chapter 7). "}),Object(s.jsx)("p",{children:"SectionChains allow Section authority to be baked into the data management process, providing a simple decentralized record of which Section signed which data."}),Object(s.jsxs)("div",{className:"Keep-it-simple",children:[Object(s.jsx)("h3",{children:"Keep it simple!"}),Object(s.jsx)("p",{children:"In order for something to occur in their Section that might alter it, the Elder Nodes must first agree that the action is valid. A supermajority (at least 5 out of 7 votes) is required. If agreement is not reached, the actor requesting the change - say, trying to write data to the Network - must try again.  "})]}),Object(s.jsx)("p",{className:"Pullquote",children:'"No node in the Safe Network has a complete overview of the network"'}),Object(s.jsx)("p",{children:"The closer a Node is to a certain address space on the Safe Network, the more information it has about data that is stored at that address. And logically, the further away a Node is, the less information it has. The bigger the Network becomes, the more secure it will get because an individual Node will have influence over a decreasing range of addresses."}),Object(s.jsx)("p",{children:"An action or event happening in a Section is only valid once a supermajority of Elders (5 out of 7) has approved it. "}),Object(s.jsx)("h3",{children:"Tell me more..."}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{href:"http://www.globule.org/publi/SDST_acmcs2009.html",children:"A Survey of DHT Security Techniques (Globule)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{href:"https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf ",children:"Kademlia: A Peer-to-peer information system based on the XOR Metric (Whitepaper, 2010)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{href:"http://docs.maidsafe.net/Whitepapers/pdf/MaidSafeDistributedHashTable.pdf ",children:"Distributed Hash Table (MaidSafe Whitepaper, 2010)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{href:"http://docs.maidsafe.net/Whitepapers/pdf/DHTbasedNATTraversal.pdf ",children:"DHT-based NAT Traversal (MaidSafe Whitepaper)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{href:"https://en.wikipedia.org/wiki/Disjoint-set_data_structure ",children:"Disjoint-set data structure (Wikipedia)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{href:"https://github.com/maidsafe/rfcs/blob/master/text/0037-disjoint-groups/0037-disjoint-groups.md ",children:"Disjoint Sections (MaidSafe RFC)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{href:"https://safenetforum.org/t/fast-ephemeral-routing/32173",children:"Fast Ephemeral Routing (RFC and discussion, introduces concept of SectionChains)"})})]})},f=a.p+"static/media/nodes_journey.7bf35734.png",m=function(){return Object(s.jsxs)("div",{className:"chapter",children:[Object(s.jsx)("h2",{id:"ch5",children:"5. Node Age"}),Object(s.jsx)("p",{children:"Node Age is a measure of how long a Node has been a reliable participant in the Network. It dictates the activities the Node can carry out and ultimately how much it will be paid (Chapter 9) "}),Object(s.jsx)("p",{children:"There are three categories of Node. Infants are Nodes waiting to join a Section, Adults are responsible for storing data and giving it up speedily on request, and Elders are the decision makers. In the current design there are seven Elders per Section and around 100 Adults."}),Object(s.jsx)("p",{children:"When a Node first joins the Network as an Infant, it first needs to discover the IP addresses of some existing Network participants. At launch, MaidSafe will temporarily provide a small number of bootstrap nodes (Internet-connected machines running the Node software). The IP addresses of these bootstrap nodes are included in the new Node's configuration file. Alternatively, if the Node owner already knows the IP addresses of some Nodes on the Network, for example machines run by a friend, these may be used instead. Through those bootstrap nodes it can connect to other known Nodes in the Network. The connection itself is fully encrypted (with the randomly-generated public keys of all valid Nodes being stored on the Network) and that initial connection is dropped immediately after the first hop once the new Node has connected to others in the Network."}),Object(s.jsxs)("div",{className:"Keep-it-simple",children:[Object(s.jsx)("h3",{children:"Keep it simple!"}),Object(s.jsx)("p",{children:"Just as children are not allowed to vote in elections, so a Node may not vote on Network events - such as whether a new member is allowed to join or whether a Section should split - until it has proven itself to be reliable. A Node gains trust each time it moves to a new Section whereupon its Node Age increases by 1. Once it is among the oldest in its Section (in terms of Node Age), it may be given voting rights as an Elder. Forcing Nodes to prove themselves in this way is an important security measure."})]}),Object(s.jsx)("p",{children:"A new Node connects to other Nodes over the qp2p layer, sending out a message to a network Elder whose IP address it knows or is in its config file saying it wants to join. At this stage the Infant Node has a Node Age of zero. It is not permitted to join the network until it is needed by the section of which the Elder is a part (say Section X)."}),Object(s.jsx)("p",{children:"A supermajority of Elders in Section X must agree that a new Node is needed before it is allowed to join. When they do, the Elders send out a Resource Proof request which forces the Infant Node to prove that it can perform a simple task (a proof of work)."}),Object(s.jsx)("p",{children:"After being accepted by Section X, the Node becomes an Adult with a Node Age of 5, and resides there for a number of churn events, roughly proportional to 2^age (i.e. 2^5). The starting value of 5 is thought to offer a reasonable balance between limiting strain on the network caused by rapid relocations and safety - the Node will have very little opportunity to act maliciously in the Section before it is relocated. This value may change with more testing. Section X will not accept any new joining Nodes until the relocation has taken place."}),Object(s.jsx)("p",{children:"After a certain amount of time our Adult Node is relocated to another section, Section Y, selected as being closest to the hash of the Node's ID (public key). Section Y must accept the new Node because relocation requests have Network Authority, meaning it is to be trusted (see Chapter 9) Before being relocated to Section Y the Node\u2019s age is increased from 5 to 6, meaning it will remain in Section Y for a longer time  - proportional to  2^6. So long as it proves itself reliable in Section Y, the Node's age will be upped to 7, it will be given a new ID and it will be relocated to Section Z, where it will remain for a time proportional to 2^7 \u2026 and so on. "}),Object(s.jsx)("p",{children:"The process of increasing Node Age is exponential. The older the Node is the longer it must prove itself before it can increase its age. Newer Nodes are more likely to be moved to a new Section -  and thus increment their Node Age - than older, more trusted ones are. When it is the seventh oldest Node in the Section, it may be promoted to an Elder."}),Object(s.jsx)("p",{children:"Nodes can be demoted too. If trust is lost it must be re-earned. If the Adult Node restarts or misbehaves, it will be relocated to a new Section with its age halved. If it is found to be less than half as responsive as its neighbour(s) in dealing with requests to store or release data, it will be ejected from the Network and will need to start again as an Infant. "}),Object(s.jsx)("p",{children:"If an Elder proves unreliable, it will also be demoted to an Adult or ejected by the other Elders, following a similar mechanism, with the oldest Adult in the Section promoted to Elder status in its place."}),Object(s.jsx)("p",{children:"Because only Nodes that have proved their value to the Network can vote, it is close to impossible for\xa0 an attacker to target a particular Section on the Safe Network. Node Ageing and churn (nodes swapping Sections) are thus vital security features."}),Object(s.jsx)("p",{children:"Only the most trusted Nodes in a Section, those Nodes with the greatest Node Age, become Elders. Other Nodes (Infants, Adults) simply receive notification of their decisions."}),Object(s.jsx)("div",{className:"Full-width-pic",align:"center",children:Object(s.jsx)("img",{className:"Img",src:f,alt:"Node's journey",align:"center"})}),Object(s.jsxs)("div",{className:"What-does-that-mean",children:[Object(s.jsx)("h3",{children:"What does that mean?"}),Object(s.jsx)("p",{children:"qp2p \u2013 a networking library that enables peers on a P2P network to communicate securely, and to re-join the network without requiring a hard-coded list of known peers."}),Object(s.jsx)("p",{children:"Resource Proof \u2013 a test of bandwidth and CPU power. If a Node trying to join the Network fails the test or takes to long to return it, it will not be allowed to join."}),Object(s.jsx)("p",{children:"Node Age \u2013 a measure of the trustworthiness of a Node. After the initial connection, a Node gets moved at random from Section to Section, building its reputation or Node Age. Once its Node Age reaches a certain value it can be an active participant in the decisions of the Section as an Elder."}),Object(s.jsx)("p",{children:"Churn \u2013 the act of Nodes leaving a group or new Nodes joining. Churn means that Sections are not static for long."}),Object(s.jsx)("p",{children:"Elder \u2013 a node with voting rights in its Group. Elders are simply those nodes with the greatest Node Age in the Group."}),Object(s.jsx)("p",{children:"Adult \u2013 a node that has no voting rights but can store data."}),Object(s.jsx)("p",{children:"Infant \u2013 a node that has recently joined the Network. It has no voting rights and cannot store data."})]}),Object(s.jsx)("h3",{children:"\xa0Tell me more..."}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"Introduction & Technical Overview of Safe Consensus",href:"https://blog.maidsafe.net/2016/06/23/introduction-technical-overview-of-safe-consensus/",children:"Introduction & Technical Overview of Safe Consensus (MaidSafe blog, 2016)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{href:"http://conferences.sigcomm.org/imc/2006/papers/p19-stutzbach2.pdf",children:"Understanding Churn in Peer-to-Peer Networks (Sigcomm, Research paper, 2006)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{href:"https://safenetforum.org/t/node-ageing-rfc/11377/1",children:"Node Ageing RFC (and forum discussion)"})})]})},j=a.p+"static/media/password-passphrase.8557f476.jpeg",w=function(){return Object(s.jsxs)("div",{className:"chapter",children:[Object(s.jsx)("h2",{id:"ch6",children:"6. Encryption and authentication"}),Object(s.jsx)("p",{children:"Content on the Safe Network is stored as encrypted chunks. The original content can be recreated from these chunks provided we have a map of where the chunks are plus the keys to decrypt them. A 'file' on the Safe network is really a structure containing some metadata, such as the file name plus a Data Map which points to the location of the chunks. Files are kept in folders which are created as part of the Self-Encryption process (see below) and are encrypted, meaning their contents are only accessible to their owner by default. However, in the case of public content they are not encrypted meaning the files are accessible."}),Object(s.jsx)("p",{children:"The API makes it impossible to upload unencrypted (plain text) content to the network."}),Object(s.jsxs)("div",{className:"Keep-it-simple",children:[Object(s.jsx)("h3",{children:"Keep it simple!"}),Object(s.jsx)("p",{children:"All content on the Safe Network is encrypted by default. When a content is stored on the Network it is first broken into chunks, hashed and then encrypted and these chunks are themselves encrypted using the hash of another chunk from the same file. This is Self-Encryption - a method patented by MaidSafe but now open-sourced. When content is made public it's containing folder is decrypted, meaning anyone can reassemble the chunks."})]}),Object(s.jsxs)("p",{children:["At the network level, the Safe Network uses the TCP, UTP and \xb5TP protocols and all the data moved by these protocols is encrypted from 'bit 1'. This means that the first connection to the Safe Network that a Node or Client makes is to a bootstrap server, one of a number of temporary servers run by MaidSafe to allow new machines to join. The randomly generated public keys for these bootstrap servers are retrieved from the network by the Client, so communications between the Network and the user are always encrypted, never in plain text. Note that any Node on the Network can be used as a bootstrap server so long as its IP address is added to the configuration file of the joining Node. It ",Object(s.jsx)("em",{children:"does not"})," have to be one provided by MaidSafe. "]}),Object(s.jsx)("p",{children:"Clients and Nodes in the Network get a list of IPs and public keys of other users to connect to. These connections are also encrypted from bit 1. "}),Object(s.jsx)("h3",{children:"Clients connect anonymously"}),Object(s.jsx)("p",{children:"To ensure anonymity, the identity of a Client connecting to the Network must be hidden from the Nodes that comprise it. For this reason, the initial connection between a Client and a Node is a two-step process. First it connects via IP to a Node whose IP address is in its config file or cache. This Node knows the Client's IP address and will allow it to connect to a Section via a Section Elder's XOR address. After relocation to a new Section (Chapter 5), that initial Node has no connection with the Client and cannot track its activities. The Nodes in the new Section cannot see the Client's IP address but they know its public key and XOR address. All connections between the Client and the Section(s) are fully encrypted."}),Object(s.jsx)("h3",{children:"Self-encryption of content"}),Object(s.jsx)("p",{children:"All content (documents, images, videos, etc) on the Safe Network is encrypted. When a Client uploads a piece of content to the Network (for example an mp4 video) it is first broken into chunks and those chunks are then Self-Encrypted, a process patented by MaidSafe by which each chunk is encrypted using its own hash and the hashes of the two previous chunks in the same file. These encrypted chunks are then hashed again to arrive at the XOR address where the chunk will be stored. At the same time a Data Map is created on the Client device, which maps the chunk number to the XOR address of the chunk and the hash to decrypt it and its two successors, allowing the content to be recreated. A number of copies of each chunk are stored by Nodes in the Section to ensure redundancy."}),Object(s.jsx)("p",{children:"Data Maps and other metadata are not encrypted, but on the network they are kept inside encrypted folders if the data is private."}),Object(s.jsx)("p",{children:"The Client retains the Data Map for the content it has uploaded and keys to decrypt it locally. That way no keys or passwords need ever leave a person's device. Users can choose to share content with others by sharing their keys / Data Map with them. They can also choose to make the content fully public, in which case the folders containing the relevant fiiles are unencrypted."}),Object(s.jsx)("div",{className:"Pullquote",children:Object(s.jsx)("p",{children:'"The Safe Network provides a platform for applications that is both highly secure and anonymized by design"'})}),Object(s.jsx)("h3",{children:"Multilayered encryption"}),Object(s.jsx)("p",{children:"The Safe Network uses several layers of encryption to protect a user's anonymity and privacy. Several extra layers are active when people use direct messaging or create a public profile. The Network is designed to be as 'zero-knowledge' as possible, to the extent that Farmers cannot possibly figure out what chunks from which private file they are storing - even if it's their own. By utilizing multiple levels of encryption as well as obfuscating the identity of its users after the first hop, the Safe Network provides a platform for applications that is both highly secure and anonymized by design."}),Object(s.jsx)("h3",{children:"BLS-DKG"}),Object(s.jsx)("p",{children:"Safe uses Boneh-Lynn-Shacham Distributed Key Generation (BLS-DKG) to secure the Elder voting process and to authenticate messages passed betwen Sections. BLS-DKG is a threshold cryptographic system, meaning that authorization is only given once a predefined number of key shares have been received and combined to create a valid key. If 5 out of 7 Elders (a supermajority) each return a key share indicating that they have voted for an event then it is valid without requiring the other 2 to do so, i.e. it is Byzantine Fault Tolerant. BLS-DKG is covered in more detail in Chapter 7."}),Object(s.jsx)("h4",{children:"Safe credentials"}),Object(s.jsx)("p",{children:"BLS-DKG is useful in other areas too, including helping users handle their authentication credentials. "}),Object(s.jsx)("p",{children:"A Safe is the term used to describe a place on the Network for the user's private data, and the act of creating a Safe is really the act of creating some credentials, with which to 'unlock' the Safe. "}),Object(s.jsx)("p",{children:"Credentials are thus extremely important, but credential loss can be a serious problem on decentralized networks where there is no central authority to help recover or reset forgotten passwords. The tempation may be to choose simple credentials that are easy to remember, but these will likely be insecure (easily guessed or cracked) and prone to collisions - other people may choose the same ones and inadvertantly stumble upon the user's private information."}),Object(s.jsx)("p",{children:"The Safe Network requires at least two separate credentials, generally referred to as 'access keys', with the option to add more. In combination, these access keys must have sufficient entropy (randomness) to make collisions vanishingly unlikely."}),Object(s.jsxs)("p",{children:["Creating a Safe for the first time requires the user to choose a password (the first access key) from which a second access key is generated in the form of a passphrase (12 random words with a checksum in the style of BIP39), which the user writes down, perhaps keeping copies in a few safe places. With these two access keys, we have ",Object(s.jsx)("strong",{children:"something you know"})," (the password), and ",Object(s.jsx)("strong",{children:"something you have"})," (the passphrase), and in combination, we can generate a suitable amount of entropy to avoid collisions. This is the minimum requrement for creating a Safe."]}),Object(s.jsx)("div",{className:"Full-width-pic",align:"center",children:Object(s.jsx)("img",{src:j,alt:"password-passphrase",width:"70%",align:"center"})}),Object(s.jsx)("p",{children:"The user may also choose to to create a third access key, a device key, on a trusted smartphone or computer, which is where BLS-DKG comes in, enabling a 2-of-3 key scheme. "}),Object(s.jsxs)("p",{children:["Now instead of requiring the passphrase, on this trusted device the user can just use the password and the device key, maybe utilising some inbuilt biometrics too, for an element of ",Object(s.jsx)("strong",{children:"something you are"}),"."]}),Object(s.jsx)("p",{children:"Additional access keys can be created to provide more flexibility and resilience. A backup passphrase is one example, and additional devices can be set up too. The if the user forgets the password or loses a device, a combination of another device and or passphrase will allow the passwpord to be reset. "}),Object(s.jsx)("p",{children:"In this way Safe Network caters for people with security needs ranging from the everyday to the extreme."}),Object(s.jsxs)("div",{className:"What-does-that-mean",children:[Object(s.jsx)("h3",{children:"What does that mean?"}),Object(s.jsx)("p",{children:"Self-Encryption - Content uploaded to the Safe Network is broken up into chunks. These chunks are then hashed, encrypted locally using the AES-256 encryption algorithm and the hashes of neighbouring chunks. Because content is encrypted and decrypted locally, there is no need for keys to leave the user's machine."}),Object(s.jsx)("p",{children:"File \u2013 contains instructions for recreating content from encrypted chunks."}),Object(s.jsx)("p",{children:"Folder \u2013 container for files and other folders. Unencrypted for public data."}),Object(s.jsx)("p",{children:"Data Map \u2013 a record of content chunks and their corresponding locations on the Network. Only those in possession of the Data Map can recreate the file. "}),Object(s.jsx)("p",{children:"BLS-DKG \u2013 a cryptographic system that authenticates the sender of a message, allows for multiple parties to quickly come to a consensus, and can enable multi-signature transactions and n-of-k credentials "}),Object(s.jsx)("p",{children:"Byzantine Fault Tolerance \u2013 the ability of a decentralized network to function properly even if up to a third of the nodes (plus 1) is corrupt or faulty. "}),Object(s.jsx)("p",{children:"n-of-k \u2013 if you have k different credentials you need at least n of them to proceed, e.g. 2 out of 3 keys required to unlock a Safe. "}),Object(s.jsx)("p",{children:"Safe \u2013 a private data store on the Network. "}),Object(s.jsx)("p",{children:"BIP39 \u2013 Bitcoin Improvement Proposal 39, creates a random-looking set of words which are processed to generate cryptographic keys."})]}),Object(s.jsx)("h3",{children:"Tell me more..."}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"sodium",href:"https://github.com/maidsafe/rust_sodium",target:"_blank",rel:"noopener noreferrer",children:"Connecting to the Sodium crypto library"})}),Object(s.jsx)("p",{title:"Crypto 101 ",children:Object(s.jsx)("a",{title:"Crypto 101 ",href:"https://www.crypto101.io/ ",target:"_blank",rel:"noopener noreferrer",children:"Crypto 101\xa0"})}),Object(s.jsxs)("p",{children:[Object(s.jsx)("a",{title:"Self encrypting files",href:"https://github.com/maidsafe/self_encryption",children:"Self encrypting files (convergent encryption plus obfuscation) (GitHub)"})," "]}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"Self Encryption",href:"https://www.youtube.com/watch?v=Jnvwv4z17b4",target:"_blank",rel:"noopener noreferrer",children:"Self Encryption on the Safe Network (YouTube)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"Self-encrypting Data",href:"http://docs.maidsafe.net/Whitepapers/pdf/SelfEncryptingData.pdf",target:"_blank",rel:"noopener noreferrer",children:"Self-encrypting Data (MaidSafe Whitepaper)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"UDP Hole Punching ",href:"https://github.com/maidsafe/rfcs/blob/04f276056bf909f415b47ae341b16ce78af0c7a4/text/0008-udp-hole-punching/0008-udp-hole-punching.md",target:"_blank",rel:"noopener noreferrer",children:"UDP Hole Punching (MaidSafe RFC) "})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"bip39 ",href:"https://iancoleman.io/bip39/",target:"_blank",rel:"noopener noreferrer",children:"BIP39 Mnemonic Code Converter  "})})]})},g=function(){return Object(s.jsxs)("div",{className:"chapter",children:[Object(s.jsx)("h2",{id:"ch7",children:"7. Network-wide consensus not required"}),Object(s.jsx)("h3",{children:"A hard problem"}),Object(s.jsx)("p",{children:"Truly decentralized networks can have no master node or oracle to judge what is true or valid and what is not. Instead, the nodes that make up the Network must come to an agreement among themselves about which of many possible versions of \u201cthe truth\u201d they will accept."}),Object(s.jsx)("p",{children:"Discrepancies can arise for many reasons, but a frequent cause is the physical distance between nodes. As an example, let\u2019s say node Alice in Sydney relays a message to node Bob in Edinburgh. Before the signal can travel halfway around the world, node Carol in London transmits a different message to Bob. Because London is much closer to Edinburgh, Carol's message arrives before Alice's, even though it was sent later. Without a central time-clock, how can we decide which is the correct order of events? "}),Object(s.jsx)("p",{children:"In our example, the nodes that make up the network must vote on which message - Alice's or Carol's - they will accept as being sent first, based on information about the two events that each has received. What\u2019s more, the Network must account for the fact that a certain proportion of the nodes may be unreliable or even actively malicious and yet still converge on one rules-based version of the truth. This is called Byzantine Fault Tolerance (BFT). The way the maths works out, up to one-third of the nodes could be corrupt (Byzantine) and a BFT network will still function reliably. (If more than a third are corrupt, BFT becomes mathematically impossible according to current theory.)"}),Object(s.jsx)("h3",{children:"Proof of Work"}),Object(s.jsx)("p",{children:"The Bitcoin blockchain uses Proof of Work (PoW) to solve these problems of achieving decentralized consensus over the ordering of events to prevent the problem of double-spend \u2013 being able to spend the same coin twice \u2013 and Byzantine behaviour. Miners battle to verify a block of transactions. If there are two simultaneous winners the chain will split and for a time there are two versions of the truth, i.e. two chains emanating from the disputed block. Ultimately, though, after a few blocks have been added one chain will be longer than the other, and it is this chain that will be accepted as the true state. The failed blocks go back into the pot to be verified again. This is how the Bitcoin blockchain (and most other blockchains) achieves consensus. This mechanism also offers a defence against the 51 percent attack (see Chapter 12)."}),Object(s.jsx)("p",{children:"Since miners are (ideally) independent operators distributed all over the world, and because it takes a lot of energy to verify a block, it is extremely difficult and expensive to deliberately influence the growth of one sub-chain over another. Difficult but not impossible: if one miner or mining group manages to consolidate more than half of the mining power, that miner can then spend some Bitcoin, split the chain and then grow the sub-chain that does not contain the transaction. Effectively this rogue miner is rewriting history. Once that sub-chain is accepted as \u2018the truth\u2019 the original transaction officially never happened according to the ledger, and the miner is free to spend the coins again."}),Object(s.jsx)("p",{children:"This is the Sybil attack, also known as the 51 percent attack because it becomes possible when one entity owns more than half of the mining power."}),Object(s.jsx)("p",{children:"While such attacks have been successfully launched against some cryptocurrencies, Ethereum Classic being one example, Proof of Work has generally been rather effective in protecting against 51 percent attacks and at achieving BFT consensus across the network. But it is slow, massively energy-intensive and it doesn\u2019t scale. Also, the consensus is probabilistic rather than deterministic: after some time, you might be 99.9 percent sure that all nodes agree on network state, but never 100 percent."}),Object(s.jsx)("p",{children:"The Safe Network does not use a blockchain or PoW for consensus. Instead it uses a combination of lightweight mechanisms that together achieve the same goal, including Boneh-Lynn-Shacham Distributed Key Generation (BLS-DKG), Byzantine Reliable Broadcast (BRB) and Conflict-free Data Types (CRDTs)."}),Object(s.jsx)("h3",{children:"Boneh-Lynn-Shacham Distributed Key Generation"}),Object(s.jsx)("p",{children:"BLS-DKG is a cryptographic signature scheme that allows the recipient of a signed message to verify with certainty that the sender is authentic since there can only ever be one valid signature for any public-key\u2013message combination. This is obviously extremely useful in a decentralized network where there is no central source of authority and only a limited amount is known about other players. The 'distributed key generation' (DKG) part of the name refers to the fact that a certain number of parties (a threshold) must participate in generating a public\u2013private key pair, with the private key split up and distributed between them. Since they each hold a part of the private key, all parties must also participate in order to decrypt a message encoded with the public key, making BLS a great fit for Elders voting on decisions in a Section, or indeed for multisig transactions where more than one signature is required before payment."}),Object(s.jsx)("p",{children:"BLS-DKG has other desirable properties too, including small-sized keys and signatures which make for efficient and fast operations and it can operate asynchronously. In short, it is a quick, secure and reliable way to obtain agreement in certain circumstances without having to rely on a full ABFT consensus algorithm. "}),Object(s.jsxs)("div",{className:"What-does-that-mean",children:[Object(s.jsx)("h3",{children:"What does that mean?"}),Object(s.jsx)("p",{children:"Byzantine Fault Tolerance \u2013  the ability of a decentralized network to function properly even if up to a third of the nodes (plus 1) is corrupt or faulty."}),Object(s.jsx)("p",{children:"Byzantine Reliable Broadcast \u2013  A pattern used by the Safe Network that forces the requester to do the work of obtaining authority from the network before it can make a change. "}),Object(s.jsx)("p",{children:"Asynchronous \u2013 Not time-dependent. A system that supports asynchronicity should come to consenus no matter what order the various messages arrive in."}),Object(s.jsx)("p",{children:"Proof-of-Work \u2013 the consensus algorithm used by the Bitcoin blockchain to confirm that transactions are valid and to deter attacks."}),Object(s.jsx)("p",{children:"BLS-DKG \u2013 a cryptographic system that authenticates the sender of a message, allows for multiple parties to quickly come to agreement, and can enable multi-signature transactions."}),Object(s.jsx)("p",{children:"CRDTs \u2013 Data structures that obey certain mathematical rules which ensure that when multiple versions of data exist across a distributed network, eventually these will always converge onto one 'true' version."}),Object(s.jsx)("p",{children:"Anti-Entropy \u2013 A way of preventing a Section from making changes while its membership is in a state of flux."}),Object(s.jsx)("p",{children:"Malice Detection \u2013  detecting and ejecting nodes that are acting suspiciously."})]}),Object(s.jsx)("h3",{children:"Byzantine Reliable Broadcast "}),Object(s.jsx)("p",{children:"Byzantine Reliable Broadcast guarantees that all processes in a distributed system deliver the same set of messages, even if up to a third are Byzantine (unreliable or malicious). In the Safe Network its use allows us to forces the requester to do the work of obtaining Section Authority. The requester (say, a Client wanting to store a data chunk) is responsible for aggregating the individual signature shares from the Elders in a Section to create a SectionSignature, after which the requested operation becomes valid and can be resubmitted to the Section."}),Object(s.jsx)("p",{children:"The BRB setup adopted by Safe Network derives from the AT2 distributed networking ABFT algorithm, which suppots simple cryptocurrency transactions without needing network-wide consensus. However, the Safe Network does not use AT2 for such tansactions, it uses DBCs instead (see Chapter 8)."}),Object(s.jsx)("p",{children:'The Safe Network uses BRB to quickly enforce consensus at a Section-wide rather than a Network-wide level, and to push a lot of the work involved onto the Client. So if a Client wants to store or alter data held by a Section, it asks the Elders to sign an agreement. The Elders check the logic and then each sends back a signed agreement (a BLS key share). The Client collects these key shares and once a supemajority has arrived (say 5 out of 7 Elders agree) it a valid key and sends its request plus the key back to the Elders. The Elders now see a valid message "Please deduct from my account the sum of X" and carry out the command. The Client can perform this task of aggregating votes much more efficiently than the Elders, who would otherwise have to come to agreement between themselves via a resource-intensive consensus mechanism.'}),Object(s.jsx)("p",{children:"If the Client tries to talk to only a few Elders or to the same Elder twice it will fail to gather sufficent votes."}),Object(s.jsx)("h3",{children:"Anti-Entropy"}),Object(s.jsx)("p",{children:"A major hurdle that any decentralized network which will experience churn must overcome is keeping the nodes up to date with the network\u2019s current state. Who has joined and who has left? Who are the current Elders in any given section? Elders are by definition relatively dependable and churn amongst them is minimal, but Safe Network is asynchronous and communications between section Elders and external actors may be few and far between. The Elders in a section may have churned many times between contacts and the external actor's information may be out of date."}),Object(s.jsx)("p",{children:"It\u2019s vital actors wishing to make changes on the network have an up-to-date \u2018understanding\u2019 of the section before they are allowed to do so, otherwise data could be written to Elders that no longer exist."}),Object(s.jsx)("p",{children:"Entropy, or disorder, is a characteristic of a constantly changing network. We cannot reduce it but we can wait for periods of stability among Elders before allowing a change in their Section. Anti-Entropy (AE) is the mechanism for doing this. AE forces all Nodes that want to perform data operations on the network to prove the information they hold on the Network stucture is up to date (see Chapter 9)."}),Object(s.jsx)("h3",{children:"Conflict-free Replicated Data Types (CRDTs)"}),Object(s.jsx)("p",{children:"There's another way to ensure consistency asynchronously across a decentralized network without consensus: CRDTs. With CRDTs consistency is inherent in the data structure itself. If different versions of the same data exist across a set of connected nodes (or replicas as they are known in CRDT-speak), they will all eventually converge on the same state. If some data is changed on an offline replica, as soon as connection is re-established this change will propagate to all other replicas, even if the same data was changed on another replica in its absense. At the end of the process, everyone will have the exact same version."}),Object(s.jsx)("p",{children:"At the start of this chapter we mentioned the problem of users sending messages from different places and the difficulty of agreeing their order. With CRDTs it is not necessary to try enforce an order or agree on it before changes can be applied. If Bob sees Alice's message before Carol's then that's the order that will be replicated around the network. No questions asked. If Bob receives Alice's and Carol's messages at exactly the same time he just picks an order randomly (A-C or C-A) and all replicas will accept that as the correct state."}),Object(s.jsx)("p",{children:"CRDTs can range from simple counters to more complex structures, such as documents on which many people collaborate. Because CRDTs follow a strict set of rules based on metadata contained within their structure, conflicts (i.e. the persistence of multiple states of the same data) are automatically avoided without any special code or user intervention required."}),Object(s.jsx)("p",{children:"Not every data structure can be a CRDT, but where it's possible it makes the job of ensuring consistency significantly easier. Changes can be made locally to CRDTs in complete confidence that they will be valid whatever may be happening elsewhere. This combines well with the AT2-type process described above: the Client can only request changes to CRDT data that are valid and once these have been approved by a quorum of Elders they cannot fail. Once again, this takes strain off the network."}),Object(s.jsx)("p",{children:"On the Safe Network mutable data types are being formatted as CRDTs (see Chapter 10)."}),Object(s.jsxs)("div",{className:"Keep-it-simple",children:[Object(s.jsx)("h3",{children:"Keep it simple"}),Object(s.jsx)("p",{children:"Voting nodes (Elders) need to be able to agree on the current state of the network, even if there are many different possible versions so that operations are carried out consistently. However, many typical operations - paying for data to be stored, transfering funds, editing data - can be performed locally requiring only that the operation is consistent with the data type and Network logic, that it has been approved by a certain number of Elders, and that if other Sections need to be involved, those Elders can prove they are who they claim to be. By using a combination of BLS-DKG, BRB, Anti-Entropy and CRDTs, the Safe Network keeps operations local which is simpler, more efficient and in keeping with the core principles of decentralization."})]}),Object(s.jsx)("h3",{children:"Tell me more \u2026"}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"Signature-Free Asynchronous Byzantine",href:"https://hal.inria.fr/hal-00944019/document",target:"_blank",rel:"noopener noreferrer",children:"Signature-Free Asynchronous Byzantine Consensus with t < n/3 and O(n2) Messages (Mostefaoui et al) "})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"eth classic",href:"https://medium.com/datadriveninvestor/ethereum-classic-hacked-by-51-attack-f62c70cadd5c",target:"_blank",rel:"noopener noreferrer",children:"Ethereum Classic \u201cHACKED\u201d by 51% attack! (Medium)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"bft",href:"https://people.csail.mit.edu/silvio/Selected%20Scientific%20Papers/Distributed%20Computation/BYZANTYNE%20AGREEMENT%20MADE%20TRIVIAL.pdf",target:"_blank",rel:"noopener noreferrer",children:"Byzantine Agreement, Made Trivial (Micali) (MIT)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"BLS",href:"https://en.wikipedia.org/wiki/Boneh%E2%80%93Lynn%E2%80%93Shacham",target:"_blank",rel:"noopener noreferrer",children:"Boneh-Lynn-Shacham (Wikipedia)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"BLSa",href:"https://www.youtube.com/watch?v=vBU70EjwGfw",target:"_blank",rel:"noopener noreferrer",children:"BLS Threshold Crypto - Interface for Rust library threshold_crypto (Ian Coleman)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"CRDTa",href:"https://bartoszsypytkowski.com/the-state-of-a-state-based-crdts/",target:"_blank",rel:"noopener noreferrer",children:"An introduction to state-based CRDTs"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"CRDTb",href:"https://www.youtube.com/watch?v=B5NULPSiOGw",target:"_blank",rel:"noopener noreferrer",children:"CRDTs and the Quest for Distributed Consistency (YouTube)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"CRDTc",href:"https://www.youtube.com/watch?v=vBU70EjwGfw",target:"_blank",rel:"noopener noreferrer",children:"CRDTs for Non Academics (YouTube)"})})]})},y=a.p+"static/media/proof_of_resource.9d566729.jpg",k=a.p+"static/media/resources_and_currency.057abfd3.jpg",x=a.p+"static/media/dbc.a8e045d3.jpg",v=function(){return Object(s.jsxs)("div",{className:"chapter",children:[Object(s.jsx)("h2",{id:"ch8",children:"8. Safe Network Token and Digital Bearer Certificates"}),Object(s.jsx)("p",{children:"The financial incentive for Node operators to join the Network and cooperate toward the goal of secure data storage is to earn Safe Network Token (SNT). The idea behind Safe Network Token is similar to that of Bitcoin: to ensure that cooperative participation is a more rational course of action than uncooperative or malicious participation. SNT can be spent on the Network or exchanged for other currencies."}),Object(s.jsx)("p",{children:"The amount of data that a user can store on the Safe Network depends on the SNT balance of the user's account."}),Object(s.jsxs)("div",{className:"Keep-it-simple",children:[Object(s.jsx)("h3",{children:"Keep it simple!"}),Object(s.jsx)("p",{children:"Farming is the process by which users who lend out spare storage can earn Safe Network Token, the currency of the Safe Network. Safe Network Token can be spent on the Network, for example by uploading files."})]}),Object(s.jsx)("p",{children:"When a user of the Network requests some content, for example by browsing a website, a number of things happen. First, the Client software makes a request for the required data chunks. This message is sent to the Sections where the chunks are stored. The Client knows which Sections to contact because they are closest to the addresses of the chunks. The Section Elders then tell the Adults storing the chunks to deliver them to the Client."}),Object(s.jsx)("p",{children:"Likewise when a Client wants to store data it contacts the relevant Sections. In return it receives a quote which it pays. That payment is split between the elders and the adults that store the chunks."}),Object(s.jsx)("p",{children:"The rate of payment will depend on the farming_rate, which is a variable based on the quantity of free resources in the Network as well as the number of Safe Network Token in circulation. The Network will always try to maintain free space of at least 30 percent of its total capacity (to cover a disconnection or outage in certain parts of the Network). When the free space drops below 30 percent of the total capacity, the farming_rate will go up. Also, when there are too many Farmers providing storage space the farming_rate will go down. This happens automatically, and the effect is to create an incentive for farmers to provide storage when the overall spare capacity is low, and a disincentive when the amount of free space is high.\xa0"}),Object(s.jsxs)("div",{className:"What-does-that-mean",children:[Object(s.jsx)("h3",{children:"What does that mean?"}),Object(s.jsx)("p",{children:"Farming - a Node is paid for looking afte a data chunk."}),Object(s.jsx)("p",{children:"farming_rate - a variable used to attract or discourage Farmers in order to maintain a certain level of free space (about 30 percent of the total capacity)."}),Object(s.jsx)("p",{children:"MaidSafeCoin - a cryptocurrency token currently available for purchase that will be exchangeable for Safe Network Token once the network is live."}),Object(s.jsx)("p",{children:"Proof of Resource\xa0 - 1. a test of whether a Node that wants to join the network has sufficient bandwidth and CPU power. If it fails the test it will not be allowed to join. 2. Random checks are occasionally made by Elders to ensure that the Node is indeed maintaining chunks it is supposed to be storing. If it fails the challenge (by not providing the demanded proof) its Node Age is diminished."})]}),Object(s.jsx)("div",{className:"Full-width-pic",align:"center",children:Object(s.jsx)("img",{className:"Img1",src:y,alt:"POR",align:"center"})}),Object(s.jsx)("p",{children:"The Network will balance itself in a way that's completely independent of the price of SNT. By adjusting the farming_rate according to the amount of free available space on the Network users storing data are charged at the optimum rate. While the storing rate is high (available free space is lower) users are discouraged from storing thus helping to free up more space. This dynamic pricing should translate into very competitive prices for data storage."}),Object(s.jsx)("p",{children:"Everyone with a suitable device and sufficient bandwidth is welcome to farm and thereby contribute to the network - including data centre owners. Nodes are continuously rewarded according to the quality of the resource they provide using Node Age and other features collectively known as Proof of Resource. To minimize the risk of centralization, however, the use of huge farming rigs will be economically disadvantageous compared with running multiple smaller nodes."}),Object(s.jsx)("div",{className:"Pullquote",children:'"There\'s more incentive for Farmers to provide storage when the overall spare capacity is low, and less incentive when the amount of free space is high"'}),Object(s.jsx)("p",{children:"While it cannot be guaranteed, the signs are that bandwidth and storage capacity will continue to increase rapidly for the next decade or two. This means that data will never\xa0have to be deleted, with all public information stored for the foreseeable future.\xa0\xa0"}),Object(s.jsx)("div",{className:"Full-width-pic",align:"center",children:Object(s.jsx)("img",{src:k,alt:"resources and currency",width:"70%",align:"center"})}),Object(s.jsx)("p",{children:"The supply of SNT will be limited to 4.3 billion coins, each with its own unique identity. Safe Network Tokens will be recycled when users exchange them for Network services, which means that there is always a supply for Farmers to earn."}),Object(s.jsx)("p",{children:"Note: At the time of writing the Safe Network is still pre-release (Alpha) and SNT is not yet implemented. However, a token called MaidSafeCoin (MAID) can be purchased on cryptocurrency exchanges. When the Network goes live MAID will be exchanged for SNT on a 1:1 basis."}),Object(s.jsx)("h3",{children:"Digital Bearer Certificates"}),Object(s.jsx)("p",{children:"A Digital Bearer Certificate (DBC) is a unique \u2018digital voucher\u2019 which has value by virtue of the fact it has been provably issued by a trusted mint as part of an economic system, like a banknote. Unlike a banknote, however, to spend a DBC you need to get it reissued by a mint. The mint can take your DBC and reissue it as two or more new DBCs if you wish (e.g. payment to a shop, the remainder as change to you), and multiple DBCs can be reissued as a single DBC."}),Object(s.jsx)("p",{children:"DBCs provide a quick, safe, flexible way to make payments that is compatible with multisig/threshold signature cryptography and can be used online and offline. They simplify many aspects of the Safe Network economy remove the need for section wallets or similar mechanisms to manage SNT transfers."}),Object(s.jsx)("h4",{children:"Advantages of DBCs on Safe"}),Object(s.jsx)("p",{children:"A mint is responsible for issuing and reissuing DBCs, and checking they are valid and have not already been spent. Mints can be trusted because they are hosted by section Elders, nodes that have already gained the trust of the Network. Any mint action must be authorized by a supermajority (5 out of 7) of Elders. This is vital in protecting against Sybil attacks. The DBC system takes advantage of the sharded nature of the Network to remove the single point of failure of a typical centralised mint. Each Section has a mint, and is responsible for reissuing only those DBCs with an ID within its address range. In addition, the natural random distribution imposed by XOR means that DBCs will be scattered across Sections. Furthermore, a DBC issued by one Section will likely need to be spent in another Section, which limits the control any Section may exert over money supply."}),Object(s.jsx)("div",{className:"Full-width-pic",align:"center",children:Object(s.jsx)("img",{className:"Img",src:x,alt:"dbc",width:"70%",align:"center"})}),Object(s.jsx)("ul",{children:Object(s.jsxs)("em",{children:[Object(s.jsx)("li",{children:"id = hash of current DBC"}),Object(s.jsx)("li",{children:"output_number  = index of split"}),Object(s.jsx)("li",{children:"owner = owner of public key"}),Object(s.jsx)("li",{children:"inputs = hash of input DBC (0 if genesis)"}),Object(s.jsx)("li",{children:"outputs = hash of current DBC (same as id)"}),Object(s.jsx)("li",{children:"data = encapsulation of the above, plus the keys used to create it and those required to spend it"})]})}),Object(s.jsx)("h4",{children:"Reissuing DBCs"}),Object(s.jsx)("p",{children:"Unlike cash, DBCs have owners. Also they need to be \u2018reissued\u2019 to a payee by a mint before they can be spent. This is to prevent double-spend. Reissuing is the process of checking that the DBC is valid and has not already been spent, and using a hash of the DBC (its output) to create a new DBC, or DBCs: in the reissuing process multiple DBCs can be combined into a new DBC \u2013 or several new DBCs \u2013 or a single DBC can be reissued as several new DBCs with their values adding up to the total of the original, as in the example below."}),Object(s.jsx)("h4",{children:"The Spentbook"}),Object(s.jsx)("p",{children:"Before spending a DBC the Client must create a Spentbook entry. This is an immutable data item stored on Adult Nodes on the Network. It contains details of the desired transaction. When reissuing a DBC, the Mint checks to see if a Spentbook entry exists for that DBC and if so it will not perform the reissue. This ensures that once the transaction (DBC reissue) has occurred, the same DBC cannot be spent again."}),Object(s.jsx)("h4",{children:"Unlinkability"}),Object(s.jsx)("p",{children:"It is important for privacy and fungibility (the ability to convert a currency into any other) that transactions are not easily traceable back to individuals. To achieve this DBC transactions will be limited to fixed denominations. The following transactions: 2 x 1000 + 1 x 100 + 1 x 50 + 2 x 10 + 1 x 5 + 3 x 1 are far less linkable to individual parties than a single transaction of 2,178 SNT would be.  "}),Object(s.jsx)("p",{children:"Other techniques under investigation for delinking transactions include hiding the amounts transacted from a mint, and using blind signatures. At the time of writing the exact combination of these methods that will be used to make transactions unlinkable was still under discussion."}),Object(s.jsx)("p",{children:"As well as enabling private, simple and rapid transactions between individuals, DBCs are also the medium by which people can pay for uploads and for that payment to be shared between the Elders and Adults involved."}),Object(s.jsx)("h3",{children:"Tell me more..."}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"denominations",href:"https://safenetforum.org/t/update-21-october-2021/35708",target:"_blank",rel:"noopener noreferrer",children:"Discussion of denominations (Safe Network Forum)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"linkability",href:"https://safenetforum.org/t/update-09-september-2021/35514#more-on-dbcs-2",target:"_blank",rel:"noopener noreferrer",children:"Discussion of unlinkability (Safe Network Forum)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"blind signatures",href:"https://safenetforum.org/t/update-21-october-2021/35708",target:"_blank",rel:"noopener noreferrer",children:"Blind Signatures for Untraceable Payments (White paper, David Chaum, 1998)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"Digital Money and DBCs",href:"https://opaque.link/post/digitalmoneydbc/",target:"_blank",rel:"noopener noreferrer",children:"Digital Money and DBCs (Jonathan 'Smuggler' Logan, 2018)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"scrit",href:"https://github.com/scritcash/scrit-whitepaper/blob/master/scrit-whitepaper.pdf",target:"_blank",rel:"noopener noreferrer",children:"Scrit: An Untraceable Distributed Electronic Cash System (Jonathan 'Smuggler' Logan, 2019)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"pedersen",href:"https://safenetforum.org/t/update-july-29th-2021/35288#pedersen-commitments-and-range-proofs-2",target:"_blank",rel:"noopener noreferrer",children:"Pedersen Commitments and Range Proofs (Safe Network Forum)"})}),Object(s.jsxs)("p",{children:[Object(s.jsx)("a",{title:"Safecoin ",href:"https://safenetwork.tech/safecoin/",target:"_blank",rel:"noopener noreferrer",children:"This is Safecoin (Safe Network website)"})," \xa0\xa0"]}),Object(s.jsxs)("p",{children:[Object(s.jsx)("a",{title:"Safecoin Implementation",href:" https://github.com/maidsafe/rfcs/blob/master/text/0012-safecoin-implementation/0012-safecoin-implementation.md",target:"_blank",rel:"noopener noreferrer",children:"Safecoin Implementation (MaidSafe RFC)"})," \xa0"]}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"Farm Attempt ",href:"https://github.com/maidsafe/rfcs/blob/master/text/ ",target:"_blank",rel:"noopener noreferrer",children:"Farm Attempt (MaidSafe RFC)"})})]})},O=a.p+"static/media/supermajority.5eb8aa40.png",N=a.p+"static/media/ae1.e1bf78b5.png",S=a.p+"static/media/ae2.3bdc4cc8.png",T=a.p+"static/media/ae3.37d26212.png",C=a.p+"static/media/ae4.53952674.png",A=a.p+"static/media/ae5.a40a0e39.png",B=a.p+"static/media/ae6.c1291727.png",I=a.p+"static/media/ae7.d094d5cb.png",E=a.p+"static/media/ae8.ecc2b23d.png",D=a.p+"static/media/ae9.642819f2.png",R=a.p+"static/media/ae10.f6139819.png",q=a.p+"static/media/ae11.bac0af29.png",P=function(){return Object(s.jsxs)("div",{className:"chapter",children:[Object(s.jsx)("h2",{id:"ch9",children:"9. Safe Network Anti-Entropy"}),Object(s.jsx)("p",{children:"A major hurdle that any decentralized network that will experience churn, such as Safe, must overcome is keeping the participants up to date with the network\u2019s current state. Who has joined and who has left? Who are the current Elders in any given Section?"}),Object(s.jsx)("p",{children:"Elders are by definition relatively dependable and churn amongst them is minimal, but Safe is asynchronous and communications between Section Elders and external actors may be few and far between. The Elders in a Section may have churned many times between contacts."}),Object(s.jsx)("p",{children:"It\u2019s vital that actors wishing to make a change on the Network have an up-to-date \u2018understanding\u2019 of the affected Section before they are allowed to do so, otherwise data could be written to Elders that no longer exist and be lost."}),Object(s.jsx)("p",{children:"Entropy, or  disorder, is a characteristic of a constantly changing network. We cannot reduce it but we can wait for periods of stability among Elders before allowing a change in their Section. Anti-Entropy is the mechanism for doing this."}),Object(s.jsx)("p",{children:"Even during periods of massive change such as a large global event, AE enables the network to inform actors attempting to mutate data that they must wait until the change is over before they can try again."}),Object(s.jsx)("p",{children:"On Safe, the AE mechanism is applied to all messages that can mutate the Network, such as a PUT request. It requires the requesting actor - be that a Client, an Adult or another Section - to prove that the information they hold on the affected Section is current before they proceed. Until then they cannot make a change.\xa0"}),Object(s.jsx)("p",{children:"AE reduces the synchronisation issue to a series of questions to which the answer is yes or no. If the answer is no (your information is not current), you need to update your records and try again. There is no halfway house."}),Object(s.jsx)("p",{children:"In this way AE forces all Nodes that want to perform data operations on the Network to prove they are up to date.\xa0"}),Object(s.jsx)("h3",{children:"Core concepts and mechanisms"}),Object(s.jsxs)("ul",{children:[Object(s.jsxs)("li",{children:[Object(s.jsx)("strong",{children:"Supermajority"})," \u2013 Any action affecting a Section must be agreed by more than 2/3 of the Elders. For a Section containing seven Elders, two can disagree and the agreement will still go ahead. This allows BFT-type guarantees that provided 2/3 of Nodes can be trusted, agreement will be reached in the event of conflict."]}),Object(s.jsxs)("li",{children:[Object(s.jsx)("strong",{children:"Distributed Key Generation (DKG)"})," \u2013 To generate a new BLS SectionKey, the participation of a supermajority of Elders is required."]}),Object(s.jsxs)("li",{children:[Object(s.jsx)("strong",{children:"New key per churn event"})," \u2013 every time an Elder is promoted or demoted, a new round of DKG takes place.\xa0"]}),Object(s.jsxs)("li",{children:[Object(s.jsx)("strong",{children:"Atomic functionality"})," - it works or it doesn't - in case of any conflict or disagreement the actor is requested to try again."]})]}),Object(s.jsx)("h3",{children:"SectionChain and ProofChain"}),Object(s.jsx)("p",{children:"A SectionChain is a cryptographically secure linked list of BLS SectionKeys, each signed by the previous key in the list going back all the way to Genesis. That way, if you trust Genesis (as you must) then you can trust the validity of the latest key."}),Object(s.jsx)("p",{children:"If an actor contacting the Section holds an old key, the Section Elders send the actor a ProofChain (plus the SAP, see below) to bring it up to date."}),Object(s.jsx)("p",{children:"A ProofChain is simply the most recent part of the SectionChain going back only as far as the last key held by the actor, plus one.\xa0"}),Object(s.jsx)("h3",{children:"SectionAuthorityProvider and SectionActor"}),Object(s.jsx)("p",{children:"As well as updating the requesting actor with the ProofChain, the Elders also send it the SectionAuthorityProvider (SAP), which gives up-to-date information about the Section and its Elders."}),Object(s.jsx)("p",{children:"The SAP shows us exactly which Elders are in the Section at the present time as well as the current SectionKey."}),Object(s.jsx)("p",{children:"The SAP together with the requirement for a supermajority for agreement allows Section Elders to be treated as a single entity - a SectionActor - rather than as autonomous individuals: they act together or not at all.\xa0"}),Object(s.jsx)("h3",{children:"The three update scenarios"}),Object(s.jsx)("p",{children:"On messaging a Section an actor includes what it understands to be that Section\u2019s latest SectionKey."}),Object(s.jsxs)("ol",{type:"1",children:[Object(s.jsx)("li",{children:"If the SectionKey is correct and current the message is processed."}),Object(s.jsx)("li",{children:"If the key is out of date the Section returns the message with a ProofChain and the SAP to authenticate the Elders. The actor updates its records and tries again."}),Object(s.jsx)("li",{children:"If the SectionKey is not recognised the message is\xa0ignored."})]}),Object(s.jsx)("h3",{children:"Voting and conflict resolution"}),Object(s.jsx)("p",{children:"If an Elder sees a change in Section membership it broadcasts this to the other Elders in the Section and they vote on whether and how the Section state has changed by creating a message containing the proposal and signing it with their BLS shared secret key. Every time the state changes a new round of BLS-DKG is required and a new SectionKey is created.\xa0"}),Object(s.jsx)("p",{children:"However, due to differences in connection speed and other factors, not all Elders see the same state at the same time (see Chapter 7)."}),Object(s.jsx)("p",{children:"In the event of a conflict, agreement must be reached before the Section\u2019s state is communicated to the outside world, because we can only ever have one version of the truth.\xa0"}),Object(s.jsx)("img",{className:"Img",src:O,alt:"supermajority",width:"70%",align:"center"}),Object(s.jsx)("p",{children:"This is where the supermajority comes into play. A supermajority (e.g. 5 out of 7 Nodes) is required to generate a new Section key, and it is also (non-coincidentally) how Elders arrive at an agreement.\xa0"}),Object(s.jsx)("p",{children:"If five Elders see a Node leave (and generate a new key A) and five see another Node join (and generate a new key B) there must be a minimum of three Elders that see both versions. Under BFT at least one of these Elders must be honest. Therefore, both keys A and B are rejected and a new round of DKG takes place."}),Object(s.jsx)("p",{children:"While this process is happening, any requests for data mutation from outside actors will be rejected. This prevents a client manipulating different Elders within a Section by forking the decision-making process."}),Object(s.jsx)("h3",{children:"How AE works \u2013 an example"}),Object(s.jsx)("p",{children:"Let\u2019s consider the example of a Client requesting a Section to PUT a chunk of data, and assume that the Client has not contacted our Section before. Incidentally, AE works in the same way for communications between Adults and Elders and between Sections too."}),Object(s.jsx)("p",{children:"1. The starting situation"}),Object(s.jsx)("img",{className:"Img",src:N,alt:"ae1",width:"70%",align:"center"}),Object(s.jsx)("p",{children:Object(s.jsx)("strong",{children:"\xa0"})}),Object(s.jsxs)("ul",{children:[Object(s.jsx)("li",{children:"Each Elder is in constant contact with all other Elders in the Section (connections not shown) and with all Adults."}),Object(s.jsx)("li",{children:"Elders churn rarely, Adults churn frequently."}),Object(s.jsx)("li",{children:"Every time the Elders churn a new BLS SectionKey is generated."}),Object(s.jsx)("li",{children:"The SAP is what\xa0defines the current Section."}),Object(s.jsx)("li",{children:"A Section is also defined by its unique XOR address prefix, eg 0011."}),Object(s.jsx)("li",{children:"Each Elder\xa0 has an ID, a BLS key, SectionChains from its own and other Sections and an address."}),Object(s.jsx)("li",{children:"Each Adult has an ID, a SectionChain and an address."})]}),Object(s.jsx)("p",{children:"2. Client broadcasts a request to all Elders in relevant secions simultaneously"}),Object(s.jsx)("img",{className:"Img",src:S,alt:"ae2",width:"70%",align:"center"}),Object(s.jsx)("p",{children:"3. SectionActor sends SectionChain and SAP"}),Object(s.jsx)("img",{className:"Img",src:T,alt:"ae3",width:"70%",align:"center"}),Object(s.jsx)("p",{children:"4. But before the Client can resend the message a churn event has occurred with Elder G leaving"}),Object(s.jsx)("img",{className:"Img",src:C,alt:"ae4",width:"70%",align:"center"}),Object(s.jsx)("p",{children:"5. The Elders vote on the change"}),Object(s.jsx)("img",{className:"Img",src:A,alt:"ae5",width:"70%",align:"center"}),Object(s.jsx)("p",{children:"If an Elder sees a change it messages the other Elders to tell them. The Elders vote on whether a churn event has occurred. In this example, most see that G has gone, one (perhaps geographically further away) can still see G. A supermajority votes that G has gone and a new SectionKey, K6, is generated. If the vote had been split without a supermajority it would simply have been rerun.\xa0"}),Object(s.jsx)("p",{children:"While the churn is occurring the Client\u2019s message is rejected, but as part of AE it will retry continually.\xa0"}),Object(s.jsx)("p",{children:"6. Unaware of the churn, the Client tries again attaching its latest key, K5, to the message"}),Object(s.jsx)("img",{className:"Img",src:B,alt:"ae6",width:"70%",align:"center"}),Object(s.jsx)("p",{children:"7. Key out of date, try again"}),Object(s.jsx)("img",{className:"Img",src:I,alt:"ae7",width:"70%",align:"center"}),Object(s.jsx)("p",{children:"8. But before it can try again there\u2019s more churn: Elder H arrives"}),Object(s.jsx)("img",{className:"Img",src:E,alt:"ae8",width:"70%",align:"center"}),Object(s.jsx)("p",{children:"9. The client tries once more but again it is out of date"}),Object(s.jsx)("img",{className:"Img",src:D,alt:"ae9",width:"70%",align:"center"}),Object(s.jsx)("p",{children:"10. Once again it is sent the updated ProofChain and SAP and told to try again"}),Object(s.jsx)("img",{className:"Img",src:R,alt:"ae10",width:"70%",align:"center"}),Object(s.jsx)("p",{children:"11. Success \u2013 the churn is over and authority is given"}),Object(s.jsx)("img",{className:"Img",src:q,alt:"ae11",width:"70%",align:"center"}),Object(s.jsxs)("p",{children:["The Client tries again and this time the keys match so everyone is in sync and the operation to store chunk ",Object(s.jsx)("em",{children:"A"})," can proceed. As part of AE a requesting actor will retry continually."]}),Object(s.jsx)("p",{children:"The assumption is that Elders churn rarely (that\u2019s why they are Elders) so the above scenario should be rare. Nevertheless, it will happen and AE needs to be able to handle the various combinations of Elders leaving and joining, even if this takes multiple rounds of DKG.\xa0"}),Object(s.jsx)("p",{children:"Some potentially difficult scenarios are taken care of by other mechanisms. For example, if an Elder leaves and tries to rejoin again it will find itself relocated to another Section with its Node Age halved (Chapter 5)."}),Object(s.jsxs)("div",{className:"Keep-it-simple",children:[Object(s.jsx)("h3",{children:"Keep it simple!"}),Object(s.jsx)("p",{children:"Anti-Entropy is a way to ensure that before data is changed on the network the Section in question is not in a state of churn and the actor requesting the change knows the current identities of the Elders in the Section."}),Object(s.jsx)("p",{children:"It is an efficient way to keep the network updated on a need-to-know basis with a minimum of messaging."}),Object(s.jsx)("p",{children:"Importantly, a Section cannot mutate data when it is between states. Only once churn has completed with the agreement of a supermajority of the Elders in the Section will requests for data mutation be accepted. Until then the actor must keep trying."})]}),Object(s.jsx)("h3",{children:"\xa0Tell me more..."}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"anti-entopy",href:"https://github.com/maidsafe/sn_entropy_check",target:"_blank",rel:"noopener noreferrer",children:"Anti-Entopy (GitHub)"})})]})},M=(a.p,function(){return Object(s.jsxs)("div",{className:"chapter",children:[Object(s.jsx)("h2",{id:"ch10",children:"10. Data types"}),Object(s.jsx)("p",{children:"A data type is a classification which describes how data can be created, transformed and used. All programming languages use them, and common examples include integer, string and boolean."}),Object(s.jsx)("p",{children:"The Safe Network provides two native data types for storing and retrieving data: Blob and Register, plus a third type, Multimap, which is a refinement of Register. Registers and Multimaps are mutable data types, whereas Blobs are immutable."}),Object(s.jsx)("p",{children:"Data itself comes in different forms too. Content or binary data is always encrypted and is spread out over the the Safe Network as immutable chunks (Blobs). It can be read by anyone with a data map, which shows how to decrypt and reconstruct the content from its constituent chunks. That data map part of a file which also contains other metadata such as filename and type (video, image, etc). So a 'file' on the Safe Network is really a set of instructions for finding the content's immutable constituent parts and assembling them to recreate the original content, together with information about what will be returned when you do."}),Object(s.jsx)("p",{children:"The FilesContainer is the equivalent of the familiar folder. We'll use folder from here on in as it's less confusing and the FilesContainer nomenclature may change. A folder contains files. Files and folders are mutable - they are metadata rather than data, and you can change the contents of a file and add or remove files from a folder. You can also nest folders within folders just as you can in most operating systems. "}),Object(s.jsx)("p",{children:"Content can be public or private. Data stored in a folder can be seen by anyone with the folder's FileMap. For private data, as with a file, the Client holds the FileMap. Sub folders have their own FileMaps and may be public or private too, independent of their parent folder."}),Object(s.jsx)("h3",{children:"Blob"}),Object(s.jsx)("p",{children:"A Blob is an immutable data type. Its Network address is derived from the hash of its content. This means the file cannot be edited in any way after it has been uploaded - any change would alter the hash and therefore its address meaning it could not be found. The data chunks created by Self-Encryption (see Chapter 6) are Blobs. "}),Object(s.jsx)("p",{children:"Data deduplication is a unique feature of the Safe Network and a side benefit of the process of Self-Encryption. Two identical Blobs will have the same hash value, and therefore only one (plus a few copies for redundancy) need be stored on the Network."}),Object(s.jsx)("p",{children:"Blobs can be cached by Clients, and fetching the same chunk next time can be quicker. Safe also has a planned feature called Opportunistic Caching in which more copies of popular data are created closer to where it is being requested, so popular websites and other data feeds will actually speed up as they get more visitors, rather than slowing down as they do on today's Web."}),Object(s.jsx)("h3",{children:"Register"}),Object(s.jsx)("p",{children:"A Register is a general CRDT mutable data type that holds a value. Registers are used to store appendable data - data can be added to a Register with previous values still being accessible. The Safe Network deploys a special type of Register called a Merkle Register which supports concurrent writes. If two actors write to a register at the same time a fork will be created with both versions kept available. It's then up to client software to decide which fork to choose, according to the app's own rules."}),Object(s.jsx)("h3",{children:"Multimap"}),Object(s.jsx)("p",{children:"A Multimap is a CRDT (Chapter 7) version of a Map data type."}),Object(s.jsxs)("p",{children:["A basic Map is composed of key-value pairs (e.g. ",Object(s.jsx)("em",{children:"key"})," 123: ",Object(s.jsx)("em",{children:"value"})," apple, ",Object(s.jsx)("em",{children:"key"})," 124: ",Object(s.jsx)("em",{children:"value"})," banana)."]}),Object(s.jsxs)("p",{children:["A Multimap is a more flexible type of Map built on the Register type which allows multiple vaules to be associated with each key (e.g. ",Object(s.jsx)("em",{children:"key"})," 123: ",Object(s.jsx)("em",{children:"value"})," apple, banana, cherry...). This means that multiple clients (e.g. apps) can edit a Multimap entry at the same time, the result being forks. "]}),Object(s.jsx)("p",{children:"Every time an operation is performed on a Multimap, a new hash is created as an identifier for the latest version. In the case of a fork with two branches, two hashes are created. Both branches will remain available to an application querying the Multimap, but it's highly likely that one chain will grow longer and most apps will choose to show this one by default. This is different from the previous Map used by Safe Network, in which versions changed in a linear fashion (v1, v2, v3...), and is akin to the way git branching works. "}),Object(s.jsx)("p",{children:"Files and folders are based on Registers and Multimaps, and Multimaps are used extensively in the NRS, which maps human-readable names to Network addresses, to maintain name mappings and to track versions of files. They store the current version of the data plus previous ones going back in time, including branches."}),Object(s.jsx)("p",{children:"Entries in a Multimap can be inserted, updated and deleted (or at least hidden)."}),Object(s.jsxs)("div",{className:"What-does-that-mean",children:[Object(s.jsx)("h3",{children:"What does that mean?"}),Object(s.jsx)("p",{children:"Data type - a classification which describes how data can be created, transformed and used. "}),Object(s.jsx)("p",{children:"File - contains a Data Map showing how to fetch chunks to recreate content, and meta data such as name, etc.   "}),Object(s.jsx)("p",{children:"Data Map  - a record of file chunks and their corresponding locations on the Network. Only those in possession of the Data Map can recreate the file.  "}),Object(s.jsx)("p",{children:"File Map - maps filenames/paths to metadata,"}),Object(s.jsx)("p",{children:"Concurrency control - managing the situation where multiple users may make changes to the same data at the same time. "}),Object(s.jsx)("p",{children:"CRDTs \u2013 Data structures that obey certain mathematical rules which ensure that when multiple versions of data exist across a distributed network, eventually these will always converge onto one 'true' version."}),Object(s.jsx)("p",{children:"XOR address - a unique 256-bit number. Every entity on the Network has an XOR address. "}),Object(s.jsx)("p",{children:"XOR URL - a base-32 encoded translation of the XOR address together with other information such as data type as required by applications. "}),Object(s.jsx)("p",{children:"PublicName -  the equivalent of a domain/site address."}),Object(s.jsx)("p",{children:"SafeID - the a equivalent of a 'username' or identity. The PublicName can also do double duty here as it\u2019s a public name with a @ in front. So a public name can be used as a SafeID, but a SafeID need not have a site"}),Object(s.jsx)("p",{children:"Network File Storage (NFS) - an API that allows a Client to access files stored on the Safe Network."}),Object(s.jsx)("p",{children:"Name Resolution System (NRS) - analogous to the Domain Name System (DNS) on the Internet, this is a system that translates an XOR address to a human-readable web address."}),Object(s.jsx)("p",{children:"Type tag - allows apps to identify the type of data, e.g. 15001 Public ID; 15002 Service Name; 15003 Email ID; 15004 Email Archive."}),Object(s.jsx)("p",{children:"Opportunistic Caching - automatic creation of more copies of popular data close to where it is being requested, so popular websites and other data feeds will actually speed up as they get more visitors, rather than slow down as they do on today's web."})]}),Object(s.jsx)("h3",{children:"Network File Storage"}),Object(s.jsx)("p",{children:"Data is saved using a combination of Multimap, Register and Blob to create an emulated file system on top of the Network called NFS (Network File Storage). NFS saves the content as a Blob. It then creates an entry in a folder (a FilesContainer) a Multimap entity, with the file name as the entry's key and the Blob's address as the entry's value. The file can be updated by uploading a new Blob and then altering the file's address in the folder structure to point to the new instance. "}),Object(s.jsx)("h3",{children:"Name Resolution System"}),Object(s.jsx)("p",{children:"Unlike the web, domains on Safe are permanent. On the web you need to keep paying for your domain or it will expire and can be given to someone else, or you can sell it to someone else of course. But on Safe, which has no centralised system like ICANN to administer them. Thus NRS is an entirely differnt system, which comes with tradeoffs. Pay once use forever is appealing of course, but it could lead to domain name squatting, where domians like 'google' are immediately registered with lucrative resale in mind. On the web this became less of a problem once more top level domains (TLDs, e.g. .tech, .lawyer, .biz) became available, copyright law caught up with te technology, and search engines made having a memorable .com domain less essemntial. But NRS effectively has one domain (like .com) which would likely lead to squatting, and there is currently no search engine for Safe. There are ways around this issue, such as reserving names, creating new TLDs, using petnames, or encouraging a market for alternatives to NRS, but at the time of writing this was still under discussion."}),Object(s.jsx)("p",{children:"As well as the human-readable Safe URL provided by NRS, files stored on the Network can also be accessed via their XOR-URL (e.g. safe://a078516207e36aa2371e17750c93276446bdb4867c027035531b89430aa8d3ae2fa4dbb59). This URL is a base-32 encoding of the file\u2019s XOR address and (optionally) its MIME type allowing data to be stored and retrieved by applications without reference to the storer\u2019s account (see Chapter 11)."}),Object(s.jsx)("h3",{children:"Tell me more..."}),Object(s.jsx)("p",{children:"\xa0"}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"data types",href:"https://safenetforum.org/t/update-30-september-2021/35595",target:"_blank",rel:"noopener noreferrer",children:"A deep dive into the Merkle Register "})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"data types",href:"https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging",target:"_blank",rel:"noopener noreferrer",children:"Git Branching - Basic Branching and Merging "})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"data types a",href:"https://github.com/maidsafe/rfcs/blob/d42c24db6ddfe58f14b347a5664710e493262ce9/text/0052-RDF-for-public-name-resolution/0052-RDF-for-public-name-resolution.md",target:"_blank",rel:"noopener noreferrer",children:"Data Hierarchy Refinement (MaidSafe RFC and forum discussion)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"md",href:"https://github.com/maidsafe/rfcs/blob/d42c24db6ddfe58f14b347a5664710e493262ce9/text/0052-RDF-for-public-name-resolution/0052-RDF-for-public-name-resolution.md",target:"_blank",rel:"noopener noreferrer",children:"RDF for the Public Name Resolution System (MaidSafe RFC)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"aod",href:"https://github.com/maidsafe/safe-nd",target:"_blank",rel:"noopener noreferrer",children:"Safe Network Data Types (Github)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"polyfuse",href:"https://github.com/ubnt-intrepid/polyfuse",target:"_blank",rel:"noopener noreferrer",children:"Polyfuse - A FUSE (Filesystem in Userspace) library for Rust.  (Github)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"tree",href:"https://forum.safedev.org/t/filetree-crdt-for-safe-network/2833",target:"_blank",rel:"noopener noreferrer",children:"FileTree CRDT for Safe Network  (MaidSafe forum discussion)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"cache",href:"https://maidsafe.net/features.htm",target:"_blank",rel:"noopener noreferrer",children:"Distributed network with opportunistic data caching (MaidSafe)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"wayback",href:"https://web.archive.org/",target:"_blank",rel:"noopener noreferrer",children:"Internet Archive Wayback Machine"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"safe_app",href:"https://docs.maidsafe.net/safe_app_nodejs/#nfs",target:"_blank",rel:"noopener noreferrer",children:"Maidsafe NFS API documentation"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"xorurls",href:"https://github.com/maidsafe/rfcs/blob/357384147ae005e4061079b27a30f43cf379fda5/text/0000-xor-urls/0000-xor-urls.md",target:"_blank",rel:"noopener noreferrer",children:"XOR-URLs (MaidSafe RFC)"})}),Object(s.jsx)("p",{children:Object(s.jsx)("a",{title:"base 32",href:"https://philzimmermann.com/docs/human-oriented-base-32-encoding.txt",target:"_blank",rel:"noopener noreferrer",children:"Human-oriented base-32 encoding (O'Whielacronx)"})})]})}),F=function(){return Object(s.jsxs)("div",{className:"chapter",children:[Object(s.jsx)("h2",{id:"ch11",children:"11. How Safe Network defends against common types of cyberattack"}),Object(s.jsx)("p",{children:"Safe Network has an interlocking set of features, each covering the others\u2019 vulnerabilities. This means that data security on Safe is maximized. While 100 percent security is impossible, this strength-in-depth means that the sort of attacks common on the current web will be much harder to carry out on SAFE."}),Object(s.jsx)("h3",{children:Object(s.jsx)("strong",{children:"Features"})}),Object(s.jsxs)("p",{children:[Object(s.jsx)("em",{children:"Random address allocation"}),Object(s.jsx)("strong",{children:" \u2013 "}),"a new Node joining the Network cannot set its own address and thus cannot decide which Section it joins or which data it will be looking after. This prevents an attacker from being able to target a particular Section to add bad nodes. On a random distribution, the attacker would need to control approximately a third of all nodes to launch such an attack (see Chapter 4)."]}),Object(s.jsxs)("p",{children:[Object(s.jsx)("em",{children:"Nodes are added only as needed -"})," Each Section only accepts a Node if needed, meaning an attacker might have to wait a very long time to its Node accepted. Even after that, a new Node will be moved between Sections before it can become an Elder (see Chapter 5)."]}),Object(s.jsxs)("p",{children:[Object(s.jsx)("em",{children:"Node ageing"})," - only Nodes that have proved their worth over time (Elders) are allowed to vote on the validity of events in a Section. Nodes that do not pull their weight or act as they will be expelled and/or their Node Age reset to a lower value (see Chapter 5)."]}),Object(s.jsxs)("p",{children:[Object(s.jsx)("em",{children:"Churn"})," - Nodes are constantly joining or leaving Sections. Membership is fluid."]}),Object(s.jsxs)("p",{children:[Object(s.jsx)("em",{children:"Encryption"})," - All data on the Safe Network is protected by several layers of encryption. Even public data is encrypted (in this case the keys are shared to allow others to decrypt it \u2013 see Chapter 6)."]}),Object(s.jsxs)("p",{children:[Object(s.jsx)("em",{children:"Self-Encryption"})," - content stored on the Network are broken into chunks with each chunk encrypted using its own hash and the hashes of the two previous chunks. These chunks are stored at geographically random locations (the XOR location being the hash of the encrypted chunk) with a number of copies retained for redundancy. Without a Data Map, the chunks cannot be retrieved and decrypted. (Chapter 6)."]}),Object(s.jsxs)("p",{children:[Object(s.jsx)("em",{children:"XOR Networking"})," - Randomizes the geographical distribution of the chunks. Only someone in possession of the Data Map (i.e. the data owner) can find the chunks and piece them together again to recreate the content. An attacker trying to fake a chunk could not do so as its hash - and therefore its address on the Network - would be different. It could not be used to create a corrupted version of the file (see Chapter 5)."]}),Object(s.jsxs)("p",{children:[Object(s.jsx)("em",{children:"Self-Authentication"})," - A user can create a Safe securely and anonymously without requiring any central server to mediate the login process or any trusted third party to store and manage users\u2019 credentials (see Chapter 3)."]}),Object(s.jsxs)("p",{children:[Object(s.jsx)("em",{children:"Anonymization"})," - To retain anonymity, the identity of a Client connecting to the Network must be obfuscated from the nodes that comprise it. For this reason connections between Clients and Nodes in the Safe Network always occur via a Node the IP of which is in the config file. Any Node can perform this role and rather than accepting the config file the user may prefer to connect via a known node of his or her choosing. Thereafter, the initial Node drops the connection and cannot track the Client's activity (see Chapter 4)."]}),Object(s.jsxs)("p",{children:[Object(s.jsx)("em",{children:"Disjoint Sections"})," - Addresses on the Safe Network are grouped into Sections with each Section looked after by a group of Nodes. Those Nodes know everything about the Section for which they are responsible but very little about the rest of the Network. Moreover, the membership of a Section is constantly changing and they will frequently split. So even if an attacker could control a Section his potential for damage would be limited (see Chapter 5)."]}),Object(s.jsxs)("p",{children:[Object(s.jsx)("em",{children:"BLS-DKG"})," - BLS cryptography (see Chapter 7, 8) allows secure authentication of Sections and multi-signature transactions. "]}),Object(s.jsxs)("p",{children:[Object(s.jsx)("em",{children:"Malice Detection"})," - The BLS signature scheme allows for the detection of invalid messages. If these reach a certain threshold the node will be demoted. If a node signs a message that is malicious the signature is forwarded to other Elders who can vote to kill the Node (see Chapter 7)."]}),Object(s.jsx)("h3",{children:Object(s.jsx)("strong",{children:"Defence against common attacks"})}),Object(s.jsxs)("p",{children:[Object(s.jsx)("em",{children:"Sybil attack"})," - In a Sybil attack, the attacker subverts the reputation system of a peer-to-peer network by creating a large number of pseudonymous identities, using them to gain a disproportionately large influence."]}),Object(s.jsx)("p",{children:"An attacker owning a large number of Nodes could potentially control individual Sections and block actions happening to data in those Sections (GET, PUT, transfer Safe Network Token). However, they would need to control more than a third of the Elders, and remember they cannot choose the Sections they join. Even then, the attacker would only have influence over the fraction of data controlled by the Group it is in (not the whole Network). Also, disrupting an individual\u2019s data would be impossible \u2013 the attacker cannot know where it is stored."}),Object(s.jsx)("p",{children:"Someone with enough Nodes could of course bring the Network down (for example by suddenly turning off all their Nodes). But this gets harder very quickly as the Network grows larger. A combination of Node Ageing, churn, rules on joining and the splitting of Sections would make this massively more difficult (and very expensive) on a large network."}),Object(s.jsx)("p",{children:"In addition, there are Malice Detection tests to identify misbehaving nodes."}),Object(s.jsxs)("p",{children:[Object(s.jsx)("em",{children:"Phishing, keylogging etc"})," - these attacks are feasible as the Network cannot protect endpoints. But such an attack would only compromise the user\u2019s own data (and that others have allowed the user to see). Using such a compromise as a springboard for a wider attack on a database or whatever would not be possible. This would be of dubious value to an attacker."]}),Object(s.jsxs)("p",{children:[Object(s.jsx)("em",{children:"Man in "}),Object(s.jsx)("em",{children:"the Middle attacks"})," - MitM attacks rely on data being unencrypted or the victim\u2019s browser accepting the attacker's certificate instead of the website\u2019s certificate. They will not work on SAFE."]}),Object(s.jsxs)("p",{children:[Object(s.jsx)("em",{children:"DDoS"})," - exceptionally difficult as there is no single point to attack. The Network will simply reroute around any nodes that are taken down."]}),Object(s.jsxs)("p",{children:[Object(s.jsx)("em",{children:"Quantum computing"})," - The encryption used on Safe is \u2018quantum resistant\u2019 (but not \u2018quantum proof\u2019). But the volume of encrypted packets means that there could only be targeted attempt at decryption, and decentralization makes such targeting difficult."]}),Object(s.jsxs)("p",{children:[Object(s.jsx)("em",{children:"Ransomware"})," \u2013Files are stored in immutable data and cannot be changed, so ransomware could not encrypt it, but it could potentially delete Data Maps or hide them, making data inaccessible."]})]})},W=function(){return Object(s.jsxs)("div",{children:[Object(s.jsx)("h2",{id:"ch12",children:"12. The promise of the Safe Network"}),Object(s.jsx)("p",{children:"The Safe Network is still in development. While many features and functionalities have already proven themselves under test conditions others, including Safe Network Token, are still to come.\xa0 As with any cutting-edge experimental technology, the proof of the pudding is in the eating. But let\u2019s assume for a moment that the Network is successful and is widely adopted for various use cases including Internet browsing, IoT connectivity, data security, personal information management, medical records and more."}),Object(s.jsx)("p",{children:"What would that world look like? First, most cyber attack strategies deployed today would be dead in the water. DDoS would not work as the Network would simply route around the affected nodes. Viruses and malware would be extremely limited in their depth of penetration. Ransomware would not raise a single dollar. Cyber attacks aimed at disabling national infrastructure or taking control of a driverless car would be extremely hard to pull off. Medical records and other personal data would be ours and ours alone, to share as we see fit. For users there can be a single sign-on to multiple services. XOR networking with opportunistic caching promises faster speeds, data storage should be extremely cheap and the Network will offer high levels of availability. For developers having a single storage architecture to address has the potential to simplify the systems programmer\u2019s job. And data deduplication would allow for both simplicity and resource savings."}),Object(s.jsx)("div",{className:"Pullquote",children:'"There would be a rebalancing of power from the data-haves to the data have-nots"'}),Object(s.jsx)("p",{children:"The Internet giants of today would no longer be able to harvest our data without our say so, nor could government spooks eavesdrop over their shoulders. There would be a rebalancing of power from the data-haves to the data have-nots. Censorship would be impossible and data could not be erased. Because the cost of entry will be low and access unrestricted, the ongoing net neutrality debate will end, and neutrality will have won the day."}),Object(s.jsx)("p",{children:"People in places with poor or restricted access to information will have those blockers lifted. Some may even make a decent living earning Safe Network Token. New business models based on consent would spring up in a world where data storage and networking and eventually compute is a commodity, and the world of information will be a much more level playing field."}),Object(s.jsx)("p",{children:"Isn\u2019t this all a bit idealistic? Well yes of course, but that\u2019s the nature of visions. Not everything will work as planned and we need to be hard-headed about that. Techno-utopianism is a dangerous thing. There are both predictable and unpredictable consequences of taking on the status quo, and indeed of deploying any new technology, and not all of them will be positive. Nevertheless, given where we are today, and where we are headed with the IoT, something like the Safe Network is most definitely needed to redress the power imbalance and to secure the data-driven future."}),Object(s.jsx)("h3",{children:"Roadmap"}),Object(s.jsxs)("p",{children:["As with all experimental research-driven projects the rate of progress is unpredictable, and MaidSafe avoid giving hard deadlines. However, there is a roadmap at ",Object(s.jsx)("a",{href:"https://safenetwork.tech/timeline/",children:"https://safenetwork.tech/timeline/"})," in which the next developments are laid out. The next MVP, Safe Fleming, will allow anyone with a computer and an internet connection to join the Network."]}),Object(s.jsx)("h2",{children:"About MaidSafe"}),Object(s.jsx)("p",{children:"MaidSafe is a company founded by David Irvine in 2006 with a mission to provide security and privacy for everyone by building a better digital world. This new platform is the Safe Network, which is the world\u2019s first autonomous and decentralized data network. The Network is made up of the unused hard drive space, processing power and bandwidth of its users. The Safe Network will include storage, peer-to-peer communications, transactions, Internet functionality and a wide variety of apps to name a few of its features. This paper was written and produced by members of the Safe Network Forum independently of MaidSafe.\xa0"}),Object(s.jsxs)("p",{children:["Join the debate at ",Object(s.jsx)("a",{href:"https://safenetforum.org/",children:"https://safenetforum.org"}),"\xa0"]}),Object(s.jsxs)("p",{children:["Website: ",Object(s.jsx)("a",{href:"http://www.safenetwork.tech/",children:"www.safenetwork.tech"})]}),Object(s.jsxs)("p",{children:["Developer forum: ",Object(s.jsx)("a",{href:"http://www.safedev.org/",children:"forum.safedev.org"})]}),Object(s.jsxs)("p",{children:["Developer hub: ",Object(s.jsx)("a",{href:"https://hub.safedev.org/",children:"https://hub.safedev.org/"})]}),Object(s.jsxs)("p",{children:["Github: ",Object(s.jsx)("a",{href:"https://github.com/maidsafe",children:"https://github.com/maidsafe"})]}),Object(s.jsxs)("p",{children:["Twitter: ",Object(s.jsx)("a",{href:"https://twitter.com/maidsafe",children:"https://twitter.com/maidsafe"})]}),Object(s.jsxs)("p",{children:["Twitter: ",Object(s.jsx)("a",{href:"https://twitter.com/maidsafe",children:"https://twitter.com/safenetworktech"})]}),Object(s.jsxs)("p",{children:["Reddit: ",Object(s.jsx)("a",{href:"https://reddit.com/r/safenetwork",children:"https://reddit.com/r/safenetwork"})]}),Object(s.jsxs)("p",{children:["Telegram: ",Object(s.jsx)("a",{href:"https://t.me/safenetwork",children:"https://t.me/safenetwork"})]})]})},z=function(){return Object(s.jsx)("div",{})},_=(a(10),function(e){return Object(s.jsxs)("div",{children:[Object(s.jsxs)("div",{className:"header",align:"center",children:[Object(s.jsx)("h1",{children:"The Safe Network Primer"}),Object(s.jsx)("p",{children:Object(s.jsx)("strong",{children:"An introductory guide to the world's first fully autonomous data and communications network"})}),Object(s.jsx)("p",{children:"Last update: November 2021"})]}),Object(s.jsx)("hr",{}),Object(s.jsx)("div",{align:" left ",children:Object(s.jsxs)("p",{children:["Major changes since last update:",Object(s.jsxs)("ul",{children:[Object(s.jsx)("li",{children:"Implemetation of Digital Bearer Certificates "}),Object(s.jsx)("li",{children:"Implementation of Anti-Entropy "}),Object(s.jsx)("li",{children:"Implementation of conflict-free data types (CRDTs)"}),Object(s.jsx)("li",{children:"New data CRDT types Register, Multimap"}),Object(s.jsx)("li",{children:"n of k user authorization"})]})]})}),Object(s.jsx)("hr",{})]})});var G=function(e){return Object(s.jsx)("div",{children:Object(s.jsx)("div",{className:"Topbar",style:{backgroundColor:e.bgcol,height:"10px"}})})};var L=function(){return Object(s.jsxs)("div",{className:"App",children:[Object(s.jsx)(_,{}),Object(s.jsx)(o,{}),Object(s.jsx)(G,{bgcol:"#1f3a80",word:""}),Object(s.jsx)(r,{}),Object(s.jsx)(G,{bgcol:"#1f3a70",word:""}),Object(s.jsx)(l,{}),Object(s.jsx)(G,{bgcol:"#1f3a60",word:""}),Object(s.jsx)(p,{}),Object(s.jsx)(G,{bgcol:"#1f3a50",word:""}),Object(s.jsx)(b,{}),Object(s.jsx)(G,{bgcol:"#1f3a40",word:""}),Object(s.jsx)(m,{}),Object(s.jsx)(G,{bgcol:"#1f3a30",word:""}),Object(s.jsx)(w,{}),Object(s.jsx)(G,{bgcol:"#1f3a20",word:""}),Object(s.jsx)(g,{}),Object(s.jsx)(G,{bgcol:"#1f3a10",word:""}),Object(s.jsx)(v,{}),Object(s.jsx)(G,{bgcol:"#1f3b90",word:""}),Object(s.jsx)(P,{}),Object(s.jsx)(G,{bgcol:"#1f3b80",word:""}),Object(s.jsx)(M,{}),Object(s.jsx)(G,{bgcol:"#1f3b70",word:""}),Object(s.jsx)(F,{}),Object(s.jsx)(G,{bgcol:"#1f3b60",word:""}),Object(s.jsx)(W,{}),Object(s.jsx)(G,{bgcol:"#1f3b50",word:""}),Object(s.jsx)(z,{})]})},K=Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));function U(e,t){navigator.serviceWorker.register(e).then((function(e){e.onupdatefound=function(){var a=e.installing;null!=a&&(a.onstatechange=function(){"installed"===a.state&&(navigator.serviceWorker.controller?(console.log("New content is available and will be used when all tabs for this page are closed. See https://bit.ly/CRA-PWA."),t&&t.onUpdate&&t.onUpdate(e)):(console.log("Content is cached for offline use."),t&&t.onSuccess&&t.onSuccess(e)))})}})).catch((function(e){console.error("Error during service worker registration:",e)}))}i.a.render(Object(s.jsx)(L,{}),document.getElementById("root")),function(e){if("serviceWorker"in navigator){if(new URL("/draft2",window.location.href).origin!==window.location.origin)return;window.addEventListener("load",(function(){var t="".concat("/draft2","/service-worker.js");K?(!function(e,t){fetch(e).then((function(a){var n=a.headers.get("content-type");404===a.status||null!=n&&-1===n.indexOf("javascript")?navigator.serviceWorker.ready.then((function(e){e.unregister().then((function(){window.location.reload()}))})):U(e,t)})).catch((function(){console.log("No internet connection found. App is running in offline mode.")}))}(t,e),navigator.serviceWorker.ready.then((function(){console.log("This web app is being served cache-first by a service worker. To learn more, visit https://bit.ly/CRA-PWA")}))):U(t,e)}))}}()},8:function(e,t,a){}},[[11,1,2]]]);
//# sourceMappingURL=main.800d46b5.chunk.js.map